<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/mochawesome-merge/node_modules/path-scurry Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_4db87b524e85caa157404e0d2b772b3a.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">path-scurry Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for path-scurry:</div>
<div class="dyncontent">
<div class="center"><img src="dir_4db87b524e85caa157404e0d2b772b3a_dep.png" border="0" usemap="#adir__4db87b524e85caa157404e0d2b772b3a__dep" loading="lazy" alt="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/mochawesome-merge/node_modules/path-scurry"/></div>
</div>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9964"></a>
path-scurry</h1>
<p>Extremely high performant utility for building tools that read the file system, minimizing filesystem and path string munging operations to the greatest degree possible.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9965"></a>
Ugh, yet another file traversal thing on npm?</h1>
<p>Yes. None of the existing ones gave me exactly what I wanted.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9966"></a>
Well what is it you wanted?</h1>
<p>While working on <a href="http://npm.im/glob">glob</a>, I found that I needed a module to very efficiently manage the traversal over a folder tree, such that:</p>
<ol type="1">
<li>No <span class="tt">readdir()</span> or <span class="tt">stat()</span> would ever be called on the same file or directory more than one time.</li>
<li>No <span class="tt">readdir()</span> calls would be made if we can be reasonably sure that the path is not a directory. (Ie, a previous <span class="tt">readdir()</span> or <span class="tt">stat()</span> covered the path, and <span class="tt">ent.isDirectory()</span> is false.)</li>
<li><span class="tt">path.resolve()</span>, <span class="tt">dirname()</span>, <span class="tt">basename()</span>, and other string-parsing/munging operations are be minimized. This means it has to track "provisional" child nodes that may not exist (and if we find that they <em>don't</em> exist, store that information as well, so we don't have to ever check again).</li>
<li>The API is not limited to use as a stream/iterator/etc. There are many cases where an API like node's <span class="tt">fs</span> is preferrable.</li>
<li>It's more important to prevent excess syscalls than to be up to date, but it should be smart enough to know what it <em>doesn't</em> know, and go get it seamlessly when requested.</li>
<li>Do not blow up the JS heap allocation if operating on a directory with a huge number of entries.</li>
<li>Handle all the weird aspects of Windows paths, like UNC paths and drive letters and wrongway slashes, so that the consumer can return canonical platform-specific paths without having to parse or join or do any error-prone string munging.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9967"></a>
PERFORMANCE</h1>
<p>JavaScript people throw around the word "blazing" a lot. I hope that this module doesn't blaze anyone. But it does go very fast, in the cases it's optimized for, if used properly.</p>
<p>PathScurry provides ample opportunities to get extremely good performance, as well as several options to trade performance for convenience.</p>
<p>Benchmarks can be run by executing <span class="tt">npm run bench</span>.</p>
<p>As is always the case, doing more means going slower, doing less means going faster, and there are trade offs between speed and memory usage.</p>
<p>PathScurry makes heavy use of <a href="http://npm.im/lru-cache">LRUCache</a> to efficiently cache whatever it can, and <span class="tt">Path</span> objects remain in the graph for the lifetime of the walker, so repeated calls with a single PathScurry object will be extremely fast. However, adding items to a cold cache means "doing more", so in those cases, we pay a price. Nothing is free, but every effort has been made to reduce costs wherever possible.</p>
<p>Also, note that a "cache as long as possible" approach means that changes to the filesystem may not be reflected in the results of repeated PathScurry operations.</p>
<p>For resolving string paths, <span class="tt">PathScurry</span> ranges from 5-50 times faster than <span class="tt">path.resolve</span> on repeated resolutions, but around 100 to 1000 times <em>slower</em> on the first resolution. If your program is spending a lot of time resolving the <em>same</em> paths repeatedly (like, thousands or millions of times), then this can be beneficial. But both implementations are pretty fast, and speeding up an infrequent operation from 4Âµs to 400ns is not going to move the needle on your app's performance.</p>
<p>For walking file system directory trees, a lot depends on how often a given PathScurry object will be used, and also on the walk method used.</p>
<p>With default settings on a folder tree of 100,000 items, consisting of around a 10-to-1 ratio of normal files to directories, PathScurry performs comparably to <a href="http://npm.im/@nodelib/fs.walk">@nodelib/fs.walk</a>, which is the fastest and most reliable file system walker I could find. As far as I can tell, it's almost impossible to go much faster in a Node.js program, just based on how fast you can push syscalls out to the fs thread pool.</p>
<p>On my machine, that is about 1000-1200 completed walks per second for async or stream walks, and around 500-600 walks per second synchronously.</p>
<p>In the warm cache state, PathScurry's performance increases around 4x for async <span class="tt">for await</span> iteration, 10-15x faster for streams and synchronous <span class="tt">for of</span> iteration, and anywhere from 30x to 80x faster for the rest.</p>
<div class="fragment"><div class="line"># walk 100,000 fs entries, 10/1 file/dir ratio</div>
<div class="line"># operations / ms</div>
<div class="line"> New PathScurry object  |  Reuse PathScurry object</div>
<div class="line">     stream:  1112.589  |  13974.917</div>
<div class="line">sync stream:   492.718  |  15028.343</div>
<div class="line"> async walk:  1095.648  |  32706.395</div>
<div class="line">  sync walk:   527.632  |  46129.772</div>
<div class="line"> async iter:  1288.821  |   5045.510</div>
<div class="line">  sync iter:   498.496  |  17920.746</div>
</div><!-- fragment --><p>A hand-rolled walk calling <span class="tt">entry.readdir()</span> and recursing through the entries can benefit even more from caching, with greater flexibility and without the overhead of streams or generators.</p>
<p>The cold cache state is still limited by the costs of file system operations, but with a warm cache, the only bottleneck is CPU speed and VM optimizations. Of course, in that case, some care must be taken to ensure that you don't lose performance as a result of silly mistakes, like calling <span class="tt">readdir()</span> on entries that you know are not directories.</p>
<div class="fragment"><div class="line"># manual recursive iteration functions</div>
<div class="line">      cold cache  |  warm cache</div>
<div class="line">async:  1164.901  |  17923.320</div>
<div class="line">   cb:  1101.127  |  40999.344</div>
<div class="line">zalgo:  1082.240  |  66689.936</div>
<div class="line"> sync:   526.935  |  87097.591</div>
</div><!-- fragment --><p>In this case, the speed improves by around 10-20x in the async case, 40x in the case of using <span class="tt">entry.readdirCB</span> with protections against synchronous callbacks, and 50-100x with callback deferrals disabled, and <em>several hundred times faster</em> for synchronous iteration.</p>
<p>If you can think of a case that is not covered in these benchmarks, or an implementation that performs significantly better than PathScurry, please <a href="https://github.com/isaacs/path-scurry/issues">let me know</a>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9968"></a>
USAGE</h1>
<div class="fragment"><div class="line">// hybrid module, load with either method</div>
<div class="line">import { PathScurry, Path } from &#39;path-scurry&#39;</div>
<div class="line">// or:</div>
<div class="line">const { PathScurry, Path } = require(&#39;path-scurry&#39;)</div>
<div class="line"> </div>
<div class="line">// very simple example, say we want to find and</div>
<div class="line">// delete all the .DS_Store files in a given path</div>
<div class="line">// note that the API is very similar to just a</div>
<div class="line">// naive walk with fs.readdir()</div>
<div class="line">import { unlink } from &#39;fs/promises&#39;</div>
<div class="line"> </div>
<div class="line">// easy way, iterate over the directory and do the thing</div>
<div class="line">const pw = new PathScurry(process.cwd())</div>
<div class="line">for await (const entry of pw) {</div>
<div class="line">  if (entry.isFile() &amp;&amp; entry.name === &#39;.DS_Store&#39;) {</div>
<div class="line">    unlink(entry.fullpath())</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// here it is as a manual recursive method</div>
<div class="line">const walk = async (entry: Path) =&gt; {</div>
<div class="line">  const promises: Promise&lt;any&gt; = []</div>
<div class="line">  // readdir doesn&#39;t throw on non-directories, it just doesn&#39;t</div>
<div class="line">  // return any entries, to save stack trace costs.</div>
<div class="line">  // Items are returned in arbitrary unsorted order</div>
<div class="line">  for (const child of await pw.readdir(entry)) {</div>
<div class="line">    // each child is a Path object</div>
<div class="line">    if (child.name === &#39;.DS_Store&#39; &amp;&amp; child.isFile()) {</div>
<div class="line">      // could also do pw.resolve(entry, child.name),</div>
<div class="line">      // just like fs.readdir walking, but .fullpath is</div>
<div class="line">      // a *slightly* more efficient shorthand.</div>
<div class="line">      promises.push(unlink(child.fullpath()))</div>
<div class="line">    } else if (child.isDirectory()) {</div>
<div class="line">      promises.push(walk(child))</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  return Promise.all(promises)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">walk(pw.cwd).then(() =&gt; {</div>
<div class="line">  console.log(&#39;all .DS_Store files removed&#39;)</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">const pw2 = new PathScurry(&#39;/a/b/c&#39;) // pw2.cwd is the Path for /a/b/c</div>
<div class="line">const relativeDir = pw2.cwd.resolve(&#39;../x&#39;) // Path entry for &#39;/a/b/x&#39;</div>
<div class="line">const relative2 = pw2.cwd.resolve(&#39;/a/b/d/../x&#39;) // same path, same entry</div>
<div class="line">assert.equal(relativeDir, relative2)</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md9969"></a>
API</h1>
<p><a href="https://isaacs.github.io/path-scurry">Full TypeDoc API</a></p>
<p>There are platform-specific classes exported, but for the most part, the default <span class="tt">PathScurry</span> and <span class="tt">Path</span> exports are what you most likely need, unless you are testing behavior for other platforms.</p>
<p>Intended public API is documented here, but the full documentation does include internal types, which should not be accessed directly.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9970"></a>
Interface <span class="tt">PathScurryOpts</span></h2>
<p>The type of the <span class="tt">options</span> argument passed to the <span class="tt">PathScurry</span> constructor.</p>
<ul>
<li><p class="startli"><span class="tt">nocase</span>: Boolean indicating that file names should be compared case-insensitively. Defaults to <span class="tt">true</span> on darwin and win32 implementations, <span class="tt">false</span> elsewhere.</p>
<p class="startli"><b>Warning</b> Performing case-insensitive matching on a case-sensitive filesystem will result in occasionally very bizarre behavior. Performing case-sensitive matching on a case-insensitive filesystem may negatively impact performance.</p>
</li>
<li><p class="startli"><span class="tt">childrenCacheSize</span>: Number of child entries to cache, in order to speed up <span class="tt">resolve()</span> and <span class="tt">readdir()</span> calls. Defaults to <span class="tt">16 * 1024</span> (ie, <span class="tt">16384</span>).</p>
<p class="startli">Setting it to a higher value will run the risk of JS heap allocation errors on large directory trees. Setting it to <span class="tt">256</span> or smaller will significantly reduce the construction time and data consumption overhead, but with the downside of operations being slower on large directory trees. Setting it to <span class="tt">0</span> will mean that effectively no operations are cached, and this module will be roughly the same speed as <span class="tt">fs</span> for file system operations, and <em>much</em> slower than <span class="tt">path.resolve()</span> for repeated path resolution.</p>
</li>
<li><span class="tt">fs</span> An object that will be used to override the default <span class="tt">fs</span> methods. Any methods that are not overridden will use Node's built-in implementations.<ul>
<li>lstatSync</li>
<li>readdir (callback <span class="tt">withFileTypes</span> Dirent variant, used for readdirCB and most walks)</li>
<li>readdirSync</li>
<li>readlinkSync</li>
<li>realpathSync</li>
<li>promises: Object containing the following async methods:<ul>
<li>lstat</li>
<li>readdir (Dirent variant only)</li>
<li>readlink</li>
<li>realpath</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9971"></a>
Interface <span class="tt">WalkOptions</span></h2>
<p>The options object that may be passed to all walk methods.</p>
<ul>
<li><span class="tt">withFileTypes</span>: Boolean, default true. Indicates that <span class="tt">Path</span> objects should be returned. Set to <span class="tt">false</span> to get string paths instead.</li>
<li><p class="startli"><span class="tt">follow</span>: Boolean, default false. Attempt to read directory entries from symbolic links. Otherwise, only actual directories are traversed. Regardless of this setting, a given target path will only ever be walked once, meaning that a symbolic link to a previously traversed directory will never be followed.</p>
<p class="startli">Setting this imposes a slight performance penalty, because <span class="tt">readlink</span> must be called on all symbolic links encountered, in order to avoid infinite cycles.</p>
</li>
<li><span class="tt">filter</span>: Function <span class="tt">(entry: Path) =&gt; boolean</span>. If provided, will prevent the inclusion of any entry for which it returns a falsey value. This will not prevent directories from being traversed if they do not pass the filter, though it will prevent the directories themselves from being included in the results. By default, if no filter is provided, then all entries are included in the results.</li>
<li><span class="tt">walkFilter</span>: Function <span class="tt">(entry: Path) =&gt; boolean</span>. If provided, will prevent the traversal of any directory (or in the case of <span class="tt">follow:true</span> symbolic links to directories) for which the function returns false. This will not prevent the directories themselves from being included in the result set. Use <span class="tt">filter</span> for that.</li>
</ul>
<p>Note that TypeScript return types will only be inferred properly from static analysis if the <span class="tt">withFileTypes</span> option is omitted, or a constant <span class="tt">true</span> or <span class="tt">false</span> value.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9972"></a>
Class <span class="tt">PathScurry</span></h2>
<p>The main interface. Defaults to an appropriate class based on the current platform.</p>
<p>Use <span class="tt">PathScurryWin32</span>, <span class="tt">PathScurryDarwin</span>, or <span class="tt">PathScurryPosix</span> if implementation-specific behavior is desired.</p>
<p>All walk methods may be called with a <span class="tt">WalkOptions</span> argument to walk over the object's current working directory with the supplied options.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9973"></a>
<span class="tt">async pw.walk(entry?: string | Path | WalkOptions, opts?: WalkOptions)</span></h3>
<p>Walk the directory tree according to the options provided, resolving to an array of all entries found.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9974"></a>
<span class="tt">pw.walkSync(entry?: string | Path | WalkOptions, opts?: WalkOptions)</span></h3>
<p>Walk the directory tree according to the options provided, returning an array of all entries found.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9975"></a>
<span class="tt">pw.iterate(entry?: string | Path | WalkOptions, opts?: WalkOptions)</span></h3>
<p>Iterate over the directory asynchronously, for use with <span class="tt">for
await of</span>. This is also the default async iterator method.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9976"></a>
<span class="tt">pw.iterateSync(entry?: string | Path | WalkOptions, opts?: WalkOptions)</span></h3>
<p>Iterate over the directory synchronously, for use with <span class="tt">for of</span>. This is also the default sync iterator method.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9977"></a>
<span class="tt">pw.stream(entry?: string | Path | WalkOptions, opts?: WalkOptions)</span></h3>
<p>Return a <a href="http://npm.im/minipass">Minipass</a> stream that emits each entry or path string in the walk. Results are made available asynchronously.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9978"></a>
<span class="tt">pw.streamSync(entry?: string | Path | WalkOptions, opts?: WalkOptions)</span></h3>
<p>Return a <a href="http://npm.im/minipass">Minipass</a> stream that emits each entry or path string in the walk. Results are made available synchronously, meaning that the walk will complete in a single tick if the stream is fully consumed.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9979"></a>
<span class="tt">pw.cwd</span></h3>
<p>Path object representing the current working directory for the PathScurry.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9980"></a>
<span class="tt">pw.chdir(path: string)</span></h3>
<p>Set the new effective current working directory for the scurry object, so that <span class="tt">path.relative()</span> and <span class="tt">path.relativePosix()</span> return values relative to the new cwd path.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9981"></a>
<span class="tt">pw.depth(path?: Path | string): number</span></h3>
<p>Return the depth of the specified path (or the PathScurry cwd) within the directory tree.</p>
<p>Root entries have a depth of <span class="tt">0</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9982"></a>
<span class="tt">pw.resolve(...paths: string[])</span></h3>
<p>Caching <span class="tt">path.resolve()</span>.</p>
<p>Significantly faster than <span class="tt">path.resolve()</span> if called repeatedly with the same paths. Significantly slower otherwise, as it builds out the cached Path entries.</p>
<p>To get a <span class="tt">Path</span> object resolved from the <span class="tt">PathScurry</span>, use <span class="tt">pw.cwd.resolve(path)</span>. Note that <span class="tt">Path.resolve</span> only takes a single string argument, not multiple.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9983"></a>
<span class="tt">pw.resolvePosix(...paths: string[])</span></h3>
<p>Caching <span class="tt">path.resolve()</span>, but always using posix style paths.</p>
<p>This is identical to <span class="tt">pw.resolve(...paths)</span> on posix systems (ie, everywhere except Windows).</p>
<p>On Windows, it returns the full absolute UNC path using <span class="tt">/</span> separators. Ie, instead of <span class="tt">'C:\\foo\\bar</span>, it would return <span class="tt">//?/C:/foo/bar</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9984"></a>
<span class="tt">pw.relative(path: string | Path): string</span></h3>
<p>Return the relative path from the PathWalker cwd to the supplied path string or entry.</p>
<p>If the nearest common ancestor is the root, then an absolute path is returned.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9985"></a>
<span class="tt">pw.relativePosix(path: string | Path): string</span></h3>
<p>Return the relative path from the PathWalker cwd to the supplied path string or entry, using <span class="tt">/</span> path separators.</p>
<p>If the nearest common ancestor is the root, then an absolute path is returned.</p>
<p>On posix platforms (ie, all platforms except Windows), this is identical to <span class="tt">pw.relative(path)</span>.</p>
<p>On Windows systems, it returns the resulting string as a <span class="tt">/</span>-delimited path. If an absolute path is returned (because the target does not share a common ancestor with <span class="tt">pw.cwd</span>), then a full absolute UNC path will be returned. Ie, instead of <span class="tt">'C:\\foo\\bar</span>, it would return <span class="tt">//?/C:/foo/bar</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9986"></a>
<span class="tt">pw.basename(path: string | Path): string</span></h3>
<p>Return the basename of the provided string or Path.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9987"></a>
<span class="tt">pw.dirname(path: string | Path): string</span></h3>
<p>Return the parent directory of the supplied string or Path.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9988"></a>
<span class="tt">async pw.readdir(dir = pw.cwd, opts = { withFileTypes: true })</span></h3>
<p>Read the directory and resolve to an array of strings if <span class="tt">withFileTypes</span> is explicitly set to <span class="tt">false</span> or Path objects otherwise.</p>
<p>Can be called as <span class="tt">pw.readdir({ withFileTypes: boolean })</span> as well.</p>
<p>Returns <span class="tt">[]</span> if no entries are found, or if any error occurs.</p>
<p>Note that TypeScript return types will only be inferred properly from static analysis if the <span class="tt">withFileTypes</span> option is omitted, or a constant <span class="tt">true</span> or <span class="tt">false</span> value.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9989"></a>
<span class="tt">pw.readdirSync(dir = pw.cwd, opts = { withFileTypes: true })</span></h3>
<p>Synchronous <span class="tt">pw.readdir()</span></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9990"></a>
<span class="tt">async pw.readlink(link = pw.cwd, opts = { withFileTypes: false })</span></h3>
<p>Call <span class="tt">fs.readlink</span> on the supplied string or Path object, and return the result.</p>
<p>Can be called as <span class="tt">pw.readlink({ withFileTypes: boolean })</span> as well.</p>
<p>Returns <span class="tt">undefined</span> if any error occurs (for example, if the argument is not a symbolic link), or a <span class="tt">Path</span> object if <span class="tt">withFileTypes</span> is explicitly set to <span class="tt">true</span>, or a string otherwise.</p>
<p>Note that TypeScript return types will only be inferred properly from static analysis if the <span class="tt">withFileTypes</span> option is omitted, or a constant <span class="tt">true</span> or <span class="tt">false</span> value.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9991"></a>
<span class="tt">pw.readlinkSync(link = pw.cwd, opts = { withFileTypes: false })</span></h3>
<p>Synchronous <span class="tt">pw.readlink()</span></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9992"></a>
<span class="tt">async pw.lstat(entry = pw.cwd)</span></h3>
<p>Call <span class="tt">fs.lstat</span> on the supplied string or Path object, and fill in as much information as possible, returning the updated <span class="tt">Path</span> object.</p>
<p>Returns <span class="tt">undefined</span> if the entry does not exist, or if any error is encountered.</p>
<p>Note that some <span class="tt">Stats</span> data (such as <span class="tt">ino</span>, <span class="tt">dev</span>, and <span class="tt">mode</span>) will not be supplied. For those things, you'll need to call <span class="tt">fs.lstat</span> yourself.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9993"></a>
<span class="tt">pw.lstatSync(entry = pw.cwd)</span></h3>
<p>Synchronous <span class="tt">pw.lstat()</span></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9994"></a>
<span class="tt">pw.realpath(entry = pw.cwd, opts = { withFileTypes: false })</span></h3>
<p>Call <span class="tt">fs.realpath</span> on the supplied string or Path object, and return the realpath if available.</p>
<p>Returns <span class="tt">undefined</span> if any error occurs.</p>
<p>May be called as <span class="tt">pw.realpath({ withFileTypes: boolean })</span> to run on <span class="tt">pw.cwd</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9995"></a>
<span class="tt">pw.realpathSync(entry = pw.cwd, opts = { withFileTypes: false })</span></h3>
<p>Synchronous <span class="tt">pw.realpath()</span></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9996"></a>
Class <span class="tt">Path</span> implements <a href="https://nodejs.org/docs/latest/api/fs.html#class-fsdirent">fs.Dirent</a></h2>
<p>Object representing a given path on the filesystem, which may or may not exist.</p>
<p>Note that the actual class in use will be either <span class="tt">PathWin32</span> or <span class="tt">PathPosix</span>, depending on the implementation of <span class="tt">PathScurry</span> in use. They differ in the separators used to split and join path strings, and the handling of root paths.</p>
<p>In <span class="tt">PathPosix</span> implementations, paths are split and joined using the &lsquo;&rsquo;/'<span class="tt"> character, and </span>'/'` is the only root path ever in use.</p>
<p>In <span class="tt">PathWin32</span> implementations, paths are split using either &lsquo;&rsquo;/'<span class="tt"> or </span>'\'<span class="tt"> and joined using </span>'\'<span class="tt">, and multiple roots may
be in use based on the drives and UNC paths encountered. UNC
paths such as </span>//?/C:/<span class="tt"> that identify a drive letter, will be
treated as an alias for the same root entry as their associated
drive letter (in this case </span>'C:\'`).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9997"></a>
<span class="tt">path.name</span></h3>
<p>Name of this file system entry.</p>
<p><b>Important</b>: <em>always</em> test the path name against any test string using the <span class="tt">isNamed</span> method, and not by directly comparing this string. Otherwise, unicode path strings that the system sees as identical will not be properly treated as the same path, leading to incorrect behavior and possible security issues.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9998"></a>
<span class="tt">path.isNamed(name: string): boolean</span></h3>
<p>Return true if the path is a match for the given path name. This handles case sensitivity and unicode normalization.</p>
<p>Note: even on case-sensitive systems, it is <b>not</b> safe to test the equality of the <span class="tt">.name</span> property to determine whether a given pathname matches, due to unicode normalization mismatches.</p>
<p>Always use this method instead of testing the <span class="tt">path.name</span> property directly.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9999"></a>
<span class="tt">path.isCWD</span></h3>
<p>Set to true if this <span class="tt">Path</span> object is the current working directory of the <span class="tt">PathScurry</span> collection that contains it.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10000"></a>
<span class="tt">path.getType()</span></h3>
<p>Returns the type of the Path object, &lsquo;'File&rsquo;<span class="tt">, </span>'Directory'`, etc.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10001"></a>
<span class="tt">path.isType(t: type)</span></h3>
<p>Returns true if <span class="tt">is{t}()</span> returns true.</p>
<p>For example, &lsquo;path.isType('Directory&rsquo;)<span class="tt"> is equivalent to
</span>path.isDirectory()`.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10002"></a>
<span class="tt">path.depth()</span></h3>
<p>Return the depth of the Path entry within the directory tree. Root paths have a depth of <span class="tt">0</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10003"></a>
<span class="tt">path.fullpath()</span></h3>
<p>The fully resolved path to the entry.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10004"></a>
<span class="tt">path.fullpathPosix()</span></h3>
<p>The fully resolved path to the entry, using <span class="tt">/</span> separators.</p>
<p>On posix systems, this is identical to <span class="tt">path.fullpath()</span>. On windows, this will return a fully resolved absolute UNC path using <span class="tt">/</span> separators. Eg, instead of &lsquo;'C:\foo\bar&rsquo;<span class="tt">, it will
return </span>'//?/C:/foo/bar'`.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10005"></a>
<span class="tt">path.isFile()</span>, <span class="tt">path.isDirectory()</span>, etc.</h3>
<p>Same as the identical <span class="tt">fs.Dirent.isX()</span> methods.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10006"></a>
<span class="tt">path.isUnknown()</span></h3>
<p>Returns true if the path's type is unknown. Always returns true when the path is known to not exist.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10007"></a>
<span class="tt">path.resolve(p: string)</span></h3>
<p>Return a <span class="tt">Path</span> object associated with the provided path string as resolved from the current Path object.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10008"></a>
<span class="tt">path.relative(): string</span></h3>
<p>Return the relative path from the PathWalker cwd to the supplied path string or entry.</p>
<p>If the nearest common ancestor is the root, then an absolute path is returned.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10009"></a>
<span class="tt">path.relativePosix(): string</span></h3>
<p>Return the relative path from the PathWalker cwd to the supplied path string or entry, using <span class="tt">/</span> path separators.</p>
<p>If the nearest common ancestor is the root, then an absolute path is returned.</p>
<p>On posix platforms (ie, all platforms except Windows), this is identical to <span class="tt">pw.relative(path)</span>.</p>
<p>On Windows systems, it returns the resulting string as a <span class="tt">/</span>-delimited path. If an absolute path is returned (because the target does not share a common ancestor with <span class="tt">pw.cwd</span>), then a full absolute UNC path will be returned. Ie, instead of <span class="tt">'C:\\foo\\bar</span>, it would return <span class="tt">//?/C:/foo/bar</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10010"></a>
<span class="tt">async path.readdir()</span></h3>
<p>Return an array of <span class="tt">Path</span> objects found by reading the associated path entry.</p>
<p>If path is not a directory, or if any error occurs, returns <span class="tt">[]</span>, and marks all children as provisional and non-existent.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10011"></a>
<span class="tt">path.readdirSync()</span></h3>
<p>Synchronous <span class="tt">path.readdir()</span></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10012"></a>
<span class="tt">async path.readlink()</span></h3>
<p>Return the <span class="tt">Path</span> object referenced by the <span class="tt">path</span> as a symbolic link.</p>
<p>If the <span class="tt">path</span> is not a symbolic link, or any error occurs, returns <span class="tt">undefined</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10013"></a>
<span class="tt">path.readlinkSync()</span></h3>
<p>Synchronous <span class="tt">path.readlink()</span></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10014"></a>
<span class="tt">async path.lstat()</span></h3>
<p>Call <span class="tt">lstat</span> on the path object, and fill it in with details determined.</p>
<p>If path does not exist, or any other error occurs, returns <span class="tt">undefined</span>, and marks the path as "unknown" type.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10015"></a>
<span class="tt">path.lstatSync()</span></h3>
<p>Synchronous <span class="tt">path.lstat()</span></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10016"></a>
<span class="tt">async path.realpath()</span></h3>
<p>Call <span class="tt">realpath</span> on the path, and return a Path object corresponding to the result, or <span class="tt">undefined</span> if any error occurs.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10017"></a>
<span class="tt">path.realpathSync()</span></h3>
<p>Synchornous <span class="tt">path.realpath()</span> </p>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_8983b1862dce8a71846356b6209105f4.html">EcoEats-Project</a></li><li class="navelem"><a href="dir_5091f2b68170d33f954320199e2fed0a.html">node_modules</a></li><li class="navelem"><a href="dir_32da1e408bd1a560ca3963e5914fe141.html">mochawesome-merge</a></li><li class="navelem"><a href="dir_81aba10f5fe76f6b312a6595a182f761.html">node_modules</a></li><li class="navelem"><a href="dir_4db87b524e85caa157404e0d2b772b3a.html">path-scurry</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
