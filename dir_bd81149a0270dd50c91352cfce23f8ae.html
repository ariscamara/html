<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/minimatch Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_bd81149a0270dd50c91352cfce23f8ae.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">minimatch Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for minimatch:</div>
<div class="dyncontent">
<div class="center"><img src="dir_bd81149a0270dd50c91352cfce23f8ae_dep.png" border="0" usemap="#adir__bd81149a0270dd50c91352cfce23f8ae__dep" loading="lazy" alt="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/minimatch"/></div>
</div>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9650"></a>
minimatch</h1>
<p>A minimal matching utility.</p>
<p>This is the matching library used internally by npm.</p>
<p>It works by converting glob expressions into JavaScript <span class="tt">RegExp</span> objects.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9651"></a>
Usage</h1>
<div class="fragment"><div class="line">// hybrid module, load with require() or import</div>
<div class="line">import { minimatch } from &#39;minimatch&#39;</div>
<div class="line">// or:</div>
<div class="line">const { minimatch } = require(&#39;minimatch&#39;)</div>
<div class="line"> </div>
<div class="line">minimatch(&#39;bar.foo&#39;, &#39;*.foo&#39;) // true!</div>
<div class="line">minimatch(&#39;bar.foo&#39;, &#39;*.bar&#39;) // false!</div>
<div class="line">minimatch(&#39;bar.foo&#39;, &#39;*.+(bar|foo)&#39;, { debug: true }) // true, and noisy!</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md9652"></a>
Features</h1>
<p>Supports these glob features:</p>
<ul>
<li>Brace Expansion</li>
<li>Extended glob matching</li>
<li>"Globstar" <span class="tt">**</span> matching</li>
<li><a href="https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html">Posix character classes</a>, like <span class="tt">[[:alpha:]]</span>, supporting the full range of Unicode characters. For example, <span class="tt">[[:alpha:]]</span> will match against &lsquo;'é&rsquo;<span class="tt">, though </span>[a-zA-Z]<span class="tt"> will not. Collating symbol and set
  matching is not supported, so </span>[[=e=]]<span class="tt"> will _not_ match </span>'é'<span class="tt">
  and </span>[[.ch.]]<span class="tt"> will not match </span>'ch'<span class="tt"> in locales where </span>ch` is considered a single character.</li>
</ul>
<p>See:</p>
<ul>
<li><span class="tt">man sh</span></li>
<li><span class="tt">man bash</span> <a href="https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html">Pattern Matching</a></li>
<li><span class="tt">man 3 fnmatch</span></li>
<li><span class="tt">man 5 gitignore</span></li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9653"></a>
Windows</h1>
<p><b>Please only use forward-slashes in glob expressions.</b></p>
<p>Though windows uses either <span class="tt">/</span> or <span class="tt">\</span> as its path separator, only <span class="tt">/</span> characters are used by this glob implementation. You must use forward-slashes <b>only</b> in glob expressions. Back-slashes in patterns will always be interpreted as escape characters, not path separators.</p>
<p>Note that <span class="tt">\</span> or <span class="tt">/</span> <em>will</em> be interpreted as path separators in paths on Windows, and will match against <span class="tt">/</span> in glob expressions.</p>
<p>So just always use <span class="tt">/</span> in patterns.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9654"></a>
UNC Paths</h2>
<p>On Windows, UNC paths like <span class="tt">//?/c:/...</span> or <span class="tt">//ComputerName/Share/...</span> are handled specially.</p>
<ul>
<li>Patterns starting with a double-slash followed by some non-slash characters will preserve their double-slash. As a result, a pattern like <span class="tt">//*</span> will match <span class="tt">//x</span>, but not <span class="tt">/x</span>.</li>
<li>Patterns staring with <span class="tt">//?/&lt;drive letter&gt;:</span> will <em>not</em> treat the <span class="tt">?</span> as a wildcard character. Instead, it will be treated as a normal string.</li>
<li>Patterns starting with <span class="tt">//?/&lt;drive letter&gt;:/...</span> will match file paths starting with <span class="tt">&lt;drive letter&gt;:/...</span>, and vice versa, as if the <span class="tt">//?/</span> was not present. This behavior only is present when the drive letters are a case-insensitive match to one another. The remaining portions of the path/pattern are compared case sensitively, unless <span class="tt">nocase:true</span> is set.</li>
</ul>
<p>Note that specifying a UNC path using <span class="tt">\</span> characters as path separators is always allowed in the file path argument, but only allowed in the pattern argument when <span class="tt">windowsPathsNoEscape: true</span> is set in the options.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9655"></a>
Minimatch Class</h1>
<p>Create a minimatch object by instantiating the <span class="tt">minimatch.Minimatch</span> class.</p>
<div class="fragment"><div class="line">var Minimatch = require(&#39;minimatch&#39;).Minimatch</div>
<div class="line">var mm = new Minimatch(pattern, options)</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9656"></a>
Properties</h2>
<ul>
<li><span class="tt">pattern</span> The original pattern the minimatch object represents.</li>
<li><span class="tt">options</span> The options supplied to the constructor.</li>
<li><p class="startli"><span class="tt">set</span> A 2-dimensional array of regexp or string expressions. Each row in the array corresponds to a brace-expanded pattern. Each item in the row corresponds to a single path-part. For example, the pattern <span class="tt">{a,b/c}/d</span> would expand to a set of patterns like: </p><pre class="fragment">  [ [ a, d ]
  , [ b, c, d ] ]
</pre><p class="startli">If a portion of the pattern doesn't have any "magic" in it (that is, it's something like <span class="tt">"foo"</span> rather than <span class="tt">fo*o?</span>), then it will be left as a string rather than converted to a regular expression.</p>
</li>
<li><span class="tt">regexp</span> Created by the <span class="tt">makeRe</span> method. A single regular expression expressing the entire pattern. This is useful in cases where you wish to use the pattern somewhat like <span class="tt">fnmatch(3)</span> with <span class="tt">FNM_PATH</span> enabled.</li>
<li><span class="tt">negate</span> True if the pattern is negated.</li>
<li><span class="tt">comment</span> True if the pattern is a comment.</li>
<li><span class="tt">empty</span> True if the pattern is <span class="tt">""</span>.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9657"></a>
Methods</h2>
<ul>
<li><span class="tt">makeRe()</span> Generate the <span class="tt">regexp</span> member if necessary, and return it. Will return <span class="tt">false</span> if the pattern is invalid.</li>
<li><span class="tt">match(fname)</span> Return true if the filename matches the pattern, or false otherwise.</li>
<li><span class="tt">matchOne(fileArray, patternArray, partial)</span> Take a <span class="tt">/</span>-split filename, and match it against a single row in the <span class="tt">regExpSet</span>. This method is mainly for internal use, but is exposed so that it can be used by a glob-walker that needs to avoid excessive filesystem calls.</li>
<li><p class="startli"><span class="tt">hasMagic()</span> Returns true if the parsed pattern contains any magic characters. Returns false if all comparator parts are string literals. If the <span class="tt">magicalBraces</span> option is set on the constructor, then it will consider brace expansions which are not otherwise magical to be magic. If not set, then a pattern like <span class="tt">a{b,c}d</span> will return <span class="tt">false</span>, because neither <span class="tt">abd</span> nor <span class="tt">acd</span> contain any special glob characters.</p>
<p class="startli">This does <b>not</b> mean that the pattern string can be used as a literal filename, as it may contain magic glob characters that are escaped. For example, the pattern <span class="tt">\\*</span> or <span class="tt">[*]</span> would not be considered to have magic, as the matching portion parses to the literal string &lsquo;&rsquo;<em>'<span class="tt"> and would match a path named </span>'</em>'<span class="tt">,
  not </span>'\*'<span class="tt"> or </span>'[*]'<span class="tt">. The </span>minimatch.unescape()` method may be used to remove escape characters.</p>
</li>
</ul>
<p>All other methods are internal, and will be called as necessary.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9658"></a>
minimatch(path, pattern, options)</h2>
<p>Main export. Tests a path against the pattern using the options.</p>
<div class="fragment"><div class="line">var isJS = minimatch(file, &#39;*.js&#39;, { matchBase: true })</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9659"></a>
minimatch.filter(pattern, options)</h2>
<p>Returns a function that tests its supplied argument, suitable for use with <span class="tt">Array.filter</span>. Example:</p>
<div class="fragment"><div class="line">var javascripts = fileList.filter(minimatch.filter(&#39;*.js&#39;, { matchBase: true }))</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9660"></a>
minimatch.escape(pattern, options = {})</h2>
<p>Escape all magic characters in a glob pattern, so that it will only ever match literal strings</p>
<p>If the <span class="tt">windowsPathsNoEscape</span> option is used, then characters are escaped by wrapping in <span class="tt">[]</span>, because a magic character wrapped in a character class can only be satisfied by that exact character.</p>
<p>Slashes (and backslashes in <span class="tt">windowsPathsNoEscape</span> mode) cannot be escaped or unescaped.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9661"></a>
minimatch.unescape(pattern, options = {})</h2>
<p>Un-escape a glob string that may contain some escaped characters.</p>
<p>If the <span class="tt">windowsPathsNoEscape</span> option is used, then square-brace escapes are removed, but not backslash escapes. For example, it will turn the string &lsquo;&rsquo;[*]'<span class="tt"> into </span>*<span class="tt">, but it will not turn
</span>'\*'<span class="tt"> into </span>'*'<span class="tt">, because </span>` is a path separator in <span class="tt">windowsPathsNoEscape</span> mode.</p>
<p>When <span class="tt">windowsPathsNoEscape</span> is not set, then both brace escapes and backslash escapes are removed.</p>
<p>Slashes (and backslashes in <span class="tt">windowsPathsNoEscape</span> mode) cannot be escaped or unescaped.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9662"></a>
minimatch.match(list, pattern, options)</h2>
<p>Match against the list of files, in the style of fnmatch or glob. If nothing is matched, and options.nonull is set, then return a list containing the pattern itself.</p>
<div class="fragment"><div class="line">var javascripts = minimatch.match(fileList, &#39;*.js&#39;, { matchBase: true })</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9663"></a>
minimatch.makeRe(pattern, options)</h2>
<p>Make a regular expression object from the pattern.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9664"></a>
Options</h1>
<p>All options are <span class="tt">false</span> by default.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9665"></a>
debug</h2>
<p>Dump a ton of stuff to stderr.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9666"></a>
nobrace</h2>
<p>Do not expand <span class="tt">{a,b}</span> and <span class="tt">{1..3}</span> brace sets.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9667"></a>
noglobstar</h2>
<p>Disable <span class="tt">**</span> matching against multiple folder names.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9668"></a>
dot</h2>
<p>Allow patterns to match filenames starting with a period, even if the pattern does not explicitly have a period in that spot.</p>
<p>Note that by default, <span class="tt">a/**/b</span> will <b>not</b> match <span class="tt">a/.d/b</span>, unless <span class="tt">dot</span> is set.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9669"></a>
noext</h2>
<p>Disable "extglob" style patterns like <span class="tt">+(a|b)</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9670"></a>
nocase</h2>
<p>Perform a case-insensitive match.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9671"></a>
nocaseMagicOnly</h2>
<p>When used with <span class="tt">{nocase: true}</span>, create regular expressions that are case-insensitive, but leave string match portions untouched. Has no effect when used without <span class="tt">{nocase: true}</span></p>
<p>Useful when some other form of case-insensitive matching is used, or if the original string representation is useful in some other way.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9672"></a>
nonull</h2>
<p>When a match is not found by <span class="tt">minimatch.match</span>, return a list containing the pattern itself if this option is set. When not set, an empty list is returned if there are no matches.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9673"></a>
magicalBraces</h2>
<p>This only affects the results of the <span class="tt">Minimatch.hasMagic</span> method.</p>
<p>If the pattern contains brace expansions, such as <span class="tt">a{b,c}d</span>, but no other magic characters, then the <span class="tt">Minimatch.hasMagic()</span> method will return <span class="tt">false</span> by default. When this option set, it will return <span class="tt">true</span> for brace expansion as well as other magic glob characters.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9674"></a>
matchBase</h2>
<p>If set, then patterns without slashes will be matched against the basename of the path if it contains slashes. For example, <span class="tt">a?b</span> would match the path <span class="tt">/xyz/123/acb</span>, but not <span class="tt">/xyz/acb/123</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9675"></a>
nocomment</h2>
<p>Suppress the behavior of treating <span class="tt">#</span> at the start of a pattern as a comment.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9676"></a>
nonegate</h2>
<p>Suppress the behavior of treating a leading <span class="tt">!</span> character as negation.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9677"></a>
flipNegate</h2>
<p>Returns from negate expressions the same as if they were not negated. (Ie, true on a hit, false on a miss.)</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9678"></a>
partial</h2>
<p>Compare a partial path to a pattern. As long as the parts of the path that are present are not contradicted by the pattern, it will be treated as a match. This is useful in applications where you're walking through a folder structure, and don't yet have the full path, but want to ensure that you do not walk down paths that can never be a match.</p>
<p>For example,</p>
<div class="fragment"><div class="line">minimatch(&#39;/a/b&#39;, &#39;/a/*/c/d&#39;, { partial: true }) // true, might be /a/b/c/d</div>
<div class="line">minimatch(&#39;/a/b&#39;, &#39;/**/d&#39;, { partial: true }) // true, might be /a/b/.../d</div>
<div class="line">minimatch(&#39;/x/y/z&#39;, &#39;/a/**/z&#39;, { partial: true }) // false, because x !== a</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9679"></a>
windowsPathsNoEscape</h2>
<p>Use <span class="tt">\\</span> as a path separator <em>only</em>, and <em>never</em> as an escape character. If set, all <span class="tt">\\</span> characters are replaced with <span class="tt">/</span> in the pattern. Note that this makes it <b>impossible</b> to match against paths containing literal glob pattern characters, but allows matching with patterns constructed using <span class="tt">path.join()</span> and <span class="tt">path.resolve()</span> on Windows platforms, mimicking the (buggy!) behavior of earlier versions on Windows. Please use with caution, and be mindful of the caveat about Windows paths.</p>
<p>For legacy reasons, this is also set if <span class="tt">options.allowWindowsEscape</span> is set to the exact value <span class="tt">false</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9680"></a>
windowsNoMagicRoot</h2>
<p>When a pattern starts with a UNC path or drive letter, and in <span class="tt">nocase:true</span> mode, do not convert the root portions of the pattern into a case-insensitive regular expression, and instead leave them as strings.</p>
<p>This is the default when the platform is <span class="tt">win32</span> and <span class="tt">nocase:true</span> is set.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9681"></a>
preserveMultipleSlashes</h2>
<p>By default, multiple <span class="tt">/</span> characters (other than the leading <span class="tt">//</span> in a UNC path, see "UNC Paths" above) are treated as a single <span class="tt">/</span>.</p>
<p>That is, a pattern like <span class="tt">a///b</span> will match the file path <span class="tt">a/b</span>.</p>
<p>Set <span class="tt">preserveMultipleSlashes: true</span> to suppress this behavior.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9682"></a>
optimizationLevel</h2>
<p>A number indicating the level of optimization that should be done to the pattern prior to parsing and using it for matches.</p>
<p>Globstar parts <span class="tt">**</span> are always converted to <span class="tt">*</span> when <span class="tt">noglobstar</span> is set, and multiple adjacent <span class="tt">**</span> parts are converted into a single <span class="tt">**</span> (ie, <span class="tt">a/**/**/b</span> will be treated as <span class="tt">a/**/b</span>, as this is equivalent in all cases).</p>
<ul>
<li><span class="tt">0</span> - Make no further changes. In this mode, <span class="tt">.</span> and <span class="tt">..</span> are maintained in the pattern, meaning that they must also appear in the same position in the test path string. Eg, a pattern like <span class="tt">a/*/../c</span> will match the string <span class="tt">a/b/../c</span> but not the string <span class="tt">a/c</span>.</li>
<li><span class="tt">1</span> - (default) Remove cases where a double-dot <span class="tt">..</span> follows a pattern portion that is not <span class="tt">**</span>, <span class="tt">.</span>, <span class="tt">..</span>, or empty &lsquo;&rsquo;'<span class="tt">. For
  example, the pattern </span>./a/b/../*<span class="tt"> is converted to </span>./a/*<span class="tt">, and
  so it will match the path string </span>./a/c<span class="tt">, but not the path
  string </span>./a/b/../c<span class="tt">. Dots and empty path portions in the
  pattern are preserved.</span></li>
<li><p class="startli"><span class="tt"></span>2` (or higher) - Much more aggressive optimizations, suitable for use with file-walking cases:</p><ul>
<li>Remove cases where a double-dot <span class="tt">..</span> follows a pattern portion that is not <span class="tt">**</span>, <span class="tt">.</span>, or empty &lsquo;&rsquo;'<span class="tt">. Remove empty
    and </span>.<span class="tt"> portions of the pattern, where safe to do so (ie,
    anywhere other than the last position, the first position, or
    the second position in a pattern starting with </span>/<span class="tt">, as this
    may indicate a UNC path on Windows).</span></li>
<li><span class="tt">Convert patterns containing </span><pre>/**/../</pre></li>
</ul>
<pre>/&lt;rest&gt;<span class="tt"> into the
    equivalent </span><pre>/{..,**}/</pre></pre><pre><pre>/&lt;rest&gt;<span class="tt">, where </span></pre></pre><pre><pre><span class="tt"> is a
    a pattern portion other than </span>.<span class="tt">, </span>..<span class="tt">, </span>**<span class="tt">, or empty
    </span>''<span class="tt">.
  - Dedupe patterns where a </span>**<span class="tt"> portion is present in one and
    omitted in another, and it is not the final path portion, and
    they are otherwise equivalent. So </span>{a/**/b,a/b}<span class="tt"> becomes
    </span>a/**/b<span class="tt">, because </span>**<span class="tt"> matches against an empty path portion.
  - Dedupe patterns where a </span>*<span class="tt"> portion is present in one, and a
    non-dot pattern other than </span>**<span class="tt">, </span>.<span class="tt">, </span>..<span class="tt">, or </span>''<span class="tt"> is in the
    same position in the other. So </span>a/{<em>,x}/b<span class="tt"> becomes </span>a/</em>/b<span class="tt">,
    because </span>*<span class="tt"> can match against </span>x`. While these optimizations improve the performance of file-walking use cases such as <a href="http://npm.im/glob">glob</a> (ie, the reason this module exists), there are cases where it will fail to match a literal string that would have been matched in optimization level 1 or 0. Specifically, while the <span class="tt">Minimatch.match()</span> method will optimize the file path string in the same ways, resulting in the same matches, it will fail when tested with the regular expression provided by <span class="tt">Minimatch.makeRe()</span>, unless the path string is first processed with <span class="tt">minimatch.levelTwoFileOptimize()</span> or similar. </pre></pre></li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9683"></a>
<pre><pre>platform</pre></pre></h2>
<pre><pre></pre></pre><pre><pre>When set to <span class="tt">win32</span>, this will trigger all windows-specific behaviors (special handling for UNC paths, and treating <span class="tt">\</span> as separators in file paths for comparison.)</pre></pre><pre><pre>Defaults to the value of <span class="tt">process.platform</span>.</pre></pre><pre><pre></pre></pre><h1 class="doxsection"><a class="anchor" id="autotoc_md9684"></a>
<pre><pre>Comparisons to other fnmatch/glob implementations</pre></pre></h1>
<pre><pre></pre></pre><pre><pre>While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.</pre></pre><pre><pre>If the pattern starts with a <span class="tt">!</span> character, then it is negated. Set the <span class="tt">nonegate</span> flag to suppress this behavior, and treat leading <span class="tt">!</span> characters normally. This is perhaps relevant if you wish to start the pattern with a negative extglob pattern like <span class="tt">!(a|B)</span>. Multiple <span class="tt">!</span> characters at the start of a pattern will negate the pattern multiple times.</pre></pre><pre><pre>If a pattern starts with <span class="tt">#</span>, then it is treated as a comment, and will not match anything. Use <span class="tt">\#</span> to match a literal <span class="tt">#</span> at the start of a line, or set the <span class="tt">nocomment</span> flag to suppress this behavior.</pre></pre><pre><pre>The double-star character <span class="tt">**</span> is supported by default, unless the <span class="tt">noglobstar</span> flag is set. This is supported in the manner of bsdglob and bash 4.1, where <span class="tt">**</span> only has special significance if it is the only thing in a path part. That is, <span class="tt">a/**/b</span> will match <span class="tt">a/x/y/b</span>, but <span class="tt">a/**b</span> will not.</pre></pre><pre><pre>If an escaped pattern has no matches, and the <span class="tt">nonull</span> flag is set, then minimatch.match returns the pattern as-provided, rather than interpreting the character escapes. For example, <span class="tt">minimatch.match([], "\\*a\\?")</span> will return <span class="tt">"\\*a\\?"</span> rather than <span class="tt">"*a?"</span>. This is akin to setting the <span class="tt">nullglob</span> option in bash, except that it does not resolve escaped pattern characters.</pre></pre><pre><pre>If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
<span class="tt">+(a|{b),c)}</span>, which would not be valid in bash or zsh, is expanded <b>first</b> into the set of <span class="tt">+(a|b)</span> and <span class="tt">+(a|c)</span>, and those patterns are checked for validity. Since those two are valid, matching proceeds.</pre></pre><pre><pre>Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<span class="tt">&lt;start&gt;!(&lt;pattern&gt;*|)*</span> will in bash match anything that does not start with <span class="tt">&lt;start&gt;&lt;pattern&gt;</span>. However, <span class="tt">&lt;start&gt;!(&lt;pattern&gt;*)*</span> <em>will</em> match paths starting with <span class="tt">&lt;start&gt;&lt;pattern&gt;</span>, because the empty string can match against the negated portion. In this library, <span class="tt">&lt;start&gt;!(&lt;pattern&gt;*|)*</span> will <em>not</em> match any pattern starting with <span class="tt">&lt;start&gt;</span>, due to a difference in precisely which patterns are considered "greedy" in Regular Expressions vs bash path expansion. This may be fixable, but not without incurring some complexity and performance costs, and the trade-off seems to not be worth pursuing.</pre></pre><pre><pre>Note that <span class="tt">fnmatch(3)</span> in libc is an extremely naive string comparison matcher, which does not do anything special for slashes. This library is designed to be used in glob searching and file walkers, and so it does do special things with <span class="tt">/</span>. Thus, <span class="tt">foo*</span> will not match <span class="tt">foo/bar</span> in this library, even though it would in <span class="tt">fnmatch(3)</span>. </pre></pre></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_8983b1862dce8a71846356b6209105f4.html">EcoEats-Project</a></li><li class="navelem"><a href="dir_5091f2b68170d33f954320199e2fed0a.html">node_modules</a></li><li class="navelem"><a href="dir_bd81149a0270dd50c91352cfce23f8ae.html">minimatch</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
