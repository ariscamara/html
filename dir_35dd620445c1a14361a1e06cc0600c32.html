<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/diff Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_35dd620445c1a14361a1e06cc0600c32.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">diff Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for diff:</div>
<div class="dyncontent">
<div class="center"><img src="dir_35dd620445c1a14361a1e06cc0600c32_dep.png" border="0" usemap="#adir__35dd620445c1a14361a1e06cc0600c32__dep" loading="lazy" alt="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/diff"/></div>
</div>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md5308"></a>
jsdiff</h1>
<p>A JavaScript text differencing implementation. Try it out in the <b><a href="https://kpdecker.github.io/jsdiff">online demo</a></b>.</p>
<p>Based on the algorithm proposed in <a href="http://www.xmailserver.org/diff2.pdf">"An O(ND) Difference Algorithm and its Variations" (Myers, 1986)</a>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md5309"></a>
Installation</h1>
<div class="fragment"><div class="line">npm install diff --save</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md5310"></a>
Usage</h1>
<p>Broadly, jsdiff's diff functions all take an old text and a new text and perform three steps:</p>
<ol type="1">
<li>Split both texts into arrays of "tokens". What constitutes a token varies; in <span class="tt">diffChars</span>, each character is a token, while in <span class="tt">diffLines</span>, each line is a token.</li>
<li><p class="startli">Find the smallest set of single-token <em>insertions</em> and <em>deletions</em> needed to transform the first array of tokens into the second.</p>
<p class="startli">This step depends upon having some notion of a token from the old array being "equal" to one from the new array, and this notion of equality affects the results. Usually two tokens are equal if <span class="tt">===</span> considers them equal, but some of the diff functions use an alternative notion of equality or have options to configure it. For instance, by default <span class="tt">diffChars("Foo", "FOOD")</span> will require two deletions (<span class="tt">o</span>, <span class="tt">o</span>) and three insertions (<span class="tt">O</span>, <span class="tt">O</span>, <span class="tt">D</span>), but <span class="tt">diffChars("Foo", "FOOD", {ignoreCase: true})</span> will require just one insertion (of a <span class="tt">D</span>), since <span class="tt">ignoreCase</span> causes <span class="tt">o</span> and <span class="tt">O</span> to be considered equal.</p>
</li>
<li>Return an array representing the transformation computed in the previous step as a series of change objects. The array is ordered from the start of the input to the end, and each change object represents <em>inserting</em> one or more tokens, <em>deleting</em> one or more tokens, or <em>keeping</em> one or more tokens.</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md5311"></a>
API</h2>
<ul>
<li><p class="startli"><span class="tt">Diff.diffChars(oldStr, newStr[, options])</span> - diffs two blocks of text, treating each character as a token.</p>
<p class="startli">("Characters" here means Unicode code points - the elements you get when you loop over a string with a <span class="tt">for ... of ...</span> loop.)</p>
<p class="startli">Returns a list of change objects.</p>
<p class="startli">Options</p><ul>
<li><span class="tt">ignoreCase</span>: If <span class="tt">true</span>, the uppercase and lowercase forms of a character are considered equal. Defaults to <span class="tt">false</span>.</li>
</ul>
</li>
<li><p class="startli"><span class="tt">Diff.diffWords(oldStr, newStr[, options])</span> - diffs two blocks of text, treating each word and each punctuation mark as a token. Whitespace is ignored when computing the diff (but preserved as far as possible in the final change objects).</p>
<p class="startli">Returns a list of change objects.</p>
<p class="startli">Options</p><ul>
<li><span class="tt">ignoreCase</span>: Same as in <span class="tt">diffChars</span>. Defaults to false.</li>
<li><p class="startli"><span class="tt">intlSegmenter</span>: An optional <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter"><span class="tt">Intl.Segmenter</span></a> object (which must have a <span class="tt">granularity</span> of &lsquo;'word&rsquo;<span class="tt">) for </span>diffWords` to use to split the text into words.</p>
<p class="startli">By default, <span class="tt">diffWords</span> does not use an <span class="tt">Intl.Segmenter</span>, just some regexes for splitting text into words. This will tend to give worse results than <span class="tt">Intl.Segmenter</span> would, but ensures the results are consistent across environments; <span class="tt">Intl.Segmenter</span> behaviour is only loosely specced and the implementations in browsers could in principle change dramatically in future. If you want to use <span class="tt">diffWords</span> with an <span class="tt">Intl.Segmenter</span> but ensure it behaves the same whatever environment you run it in, use an <span class="tt">Intl.Segmenter</span> polyfill instead of the JavaScript engine's native <span class="tt">Intl.Segmenter</span> implementation.</p>
<p class="startli">Using an <span class="tt">Intl.Segmenter</span> should allow better word-level diffing of non-English text than the default behaviour. For instance, <span class="tt">Intl.Segmenter</span>s can generally identify via built-in dictionaries which sequences of adjacent Chinese characters form words, allowing word-level diffing of Chinese. By specifying a language when instantiating the segmenter (e.g. &lsquo;new Intl.Segmenter('sv&rsquo;, {granularity: 'word'})`) you can also support language-specific rules, like treating Swedish's colon separated contractions (like <em>k:a</em> for <em>kyrka</em>) as single words; by default this would be seen as two words separated by a colon.</p>
</li>
</ul>
</li>
<li><span class="tt">Diff.diffWordsWithSpace(oldStr, newStr[, options])</span> - diffs two blocks of text, treating each word, punctuation mark, newline, or run of (non-newline) whitespace as a token.</li>
<li><p class="startli"><span class="tt">Diff.diffLines(oldStr, newStr[, options])</span> - diffs two blocks of text, treating each line as a token.</p>
<p class="startli">Options</p><ul>
<li><span class="tt">ignoreWhitespace</span>: <span class="tt">true</span> to ignore leading and trailing whitespace characters when checking if two lines are equal. Defaults to <span class="tt">false</span>.</li>
<li><span class="tt">ignoreNewlineAtEof</span>: <span class="tt">true</span> to ignore a missing newline character at the end of the last line when comparing it to other lines. (By default, the line &lsquo;'b<br  />
&rsquo;<span class="tt"> in text </span>'a\nb\nc'<span class="tt"> is not considered equal to the line </span>'b'<span class="tt"> in text </span>'a\nb'<span class="tt">; this option makes them be considered equal.) Ignored if </span>ignoreWhitespace<span class="tt"> or </span>newlineIsToken<span class="tt"> are also true.</span></li>
<li><span class="tt"></span>stripTrailingCr<span class="tt">: </span>true<span class="tt"> to remove all trailing CR (</span>\r<span class="tt">) characters before performing the diff. Defaults to </span>false<span class="tt">.
      This helps to get a useful diff when diffing UNIX text files against Windows text files.</span></li>
<li><span class="tt"></span>newlineIsToken<span class="tt">: </span>true<span class="tt"> to treat the newline character at the end of each line as its own token. This allows for changes to the newline structure to occur independently of the line content and to be treated as such. In general this is the more human friendly form of </span>diffLines<span class="tt">; the default behavior with this option turned off is better suited for patches and other computer friendly output. Defaults to </span>false`.</li>
</ul>
<p class="startli">Note that while using <span class="tt">ignoreWhitespace</span> in combination with <span class="tt">newlineIsToken</span> is not an error, results may not be as expected. With <span class="tt">ignoreWhitespace: true</span> and <span class="tt">newlineIsToken: false</span>, changing a completely empty line to contain some spaces is treated as a non-change, but with <span class="tt">ignoreWhitespace: true</span> and <span class="tt">newlineIsToken: true</span>, it is treated as an insertion. This is because the content of a completely blank line is not a token at all in <span class="tt">newlineIsToken</span> mode.</p>
<p class="startli">Returns a list of change objects.</p>
</li>
<li><p class="startli"><span class="tt">Diff.diffSentences(oldStr, newStr[, options])</span> - diffs two blocks of text, treating each sentence as a token. The characters <span class="tt">.</span>, <span class="tt">!</span>, and <span class="tt">?</span>, when followed by whitespace, are treated as marking the end of a sentence; nothing else is considered to mark a sentence end.</p>
<p class="startli">(For more sophisticated detection of sentence breaks, including support for non-English punctuation, consider instead tokenizing with an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter"><span class="tt">Intl.Segmenter</span></a> with &lsquo;granularity: 'sentence&rsquo;<span class="tt"> and passing the result to </span>Diff.diffArrays`.)</p>
<p class="startli">Returns a list of change objects.</p>
</li>
<li><p class="startli"><span class="tt">Diff.diffCss(oldStr, newStr[, options])</span> - diffs two blocks of text, comparing CSS tokens.</p>
<p class="startli">Returns a list of change objects.</p>
</li>
<li><p class="startli"><span class="tt">Diff.diffJson(oldObj, newObj[, options])</span> - diffs two JSON-serializable objects by first serializing them to prettily-formatted JSON and then treating each line of the JSON as a token. Object properties are ordered alphabetically in the serialized JSON, so the order of properties in the objects being compared doesn't affect the result.</p>
<p class="startli">Returns a list of change objects.</p>
<p class="startli">Options</p><ul>
<li><span class="tt">stringifyReplacer</span>: A custom replacer function. Operates similarly to the <span class="tt">replacer</span> parameter to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#the_replacer_parameter"><span class="tt">JSON.stringify()</span></a>, but must be a function.</li>
<li><span class="tt">undefinedReplacement</span>: A value to replace <span class="tt">undefined</span> with. Ignored if a <span class="tt">stringifyReplacer</span> is provided.</li>
</ul>
</li>
<li><p class="startli"><span class="tt">Diff.diffArrays(oldArr, newArr[, options])</span> - diffs two arrays of tokens, comparing each item for strict equality (===).</p>
<p class="startli">Options</p><ul>
<li><span class="tt">comparator</span>: <span class="tt">function(left, right)</span> for custom equality checks</li>
</ul>
<p class="startli">Returns a list of change objects.</p>
</li>
<li><p class="startli"><span class="tt">Diff.createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr[, oldHeader[, newHeader[, options]]])</span> - creates a unified diff patch by first computing a diff with <span class="tt">diffLines</span> and then serializing it to unified diff format.</p>
<p class="startli">Parameters:</p><ul>
<li><span class="tt">oldFileName</span> : String to be output in the filename section of the patch for the removals</li>
<li><span class="tt">newFileName</span> : String to be output in the filename section of the patch for the additions</li>
<li><span class="tt">oldStr</span> : Original string value</li>
<li><span class="tt">newStr</span> : New string value</li>
<li><span class="tt">oldHeader</span> : Optional additional information to include in the old file header. Default: <span class="tt">undefined</span>.</li>
<li><span class="tt">newHeader</span> : Optional additional information to include in the new file header. Default: <span class="tt">undefined</span>.</li>
<li><span class="tt">options</span> : An object with options.<ul>
<li><span class="tt">context</span> describes how many lines of context should be included. You can set this to <span class="tt">Number.MAX_SAFE_INTEGER</span> or <span class="tt">Infinity</span> to include the entire file content in one hunk.</li>
<li><span class="tt">ignoreWhitespace</span>: Same as in <span class="tt">diffLines</span>. Defaults to <span class="tt">false</span>.</li>
<li><span class="tt">stripTrailingCr</span>: Same as in <span class="tt">diffLines</span>. Defaults to <span class="tt">false</span>.</li>
</ul>
</li>
</ul>
</li>
<li><p class="startli"><span class="tt">Diff.createPatch(fileName, oldStr, newStr[, oldHeader[, newHeader[, options]]])</span> - creates a unified diff patch.</p>
<p class="startli">Just like Diff.createTwoFilesPatch, but with oldFileName being equal to newFileName.</p>
</li>
<li><p class="startli"><span class="tt">Diff.formatPatch(patch)</span> - creates a unified diff patch.</p>
<p class="startli"><span class="tt">patch</span> may be either a single structured patch object (as returned by <span class="tt">structuredPatch</span>) or an array of them (as returned by <span class="tt">parsePatch</span>).</p>
</li>
<li><p class="startli"><span class="tt">Diff.structuredPatch(oldFileName, newFileName, oldStr, newStr[, oldHeader[, newHeader[, options]]])</span> - returns an object with an array of hunk objects.</p>
<p class="startli">This method is similar to createTwoFilesPatch, but returns a data structure suitable for further processing. Parameters are the same as createTwoFilesPatch. The data structure returned may look like this:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  oldFileName: &#39;oldfile&#39;, newFileName: &#39;newfile&#39;,</div>
<div class="line">  oldHeader: &#39;header1&#39;, newHeader: &#39;header2&#39;,</div>
<div class="line">  hunks: [{</div>
<div class="line">    oldStart: 1, oldLines: 3, newStart: 1, newLines: 3,</div>
<div class="line">    lines: [&#39; line2&#39;, &#39; line3&#39;, &#39;-line4&#39;, &#39;+line5&#39;, &#39;\\ No newline at end of file&#39;],</div>
<div class="line">  }]</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli"><span class="tt">Diff.applyPatch(source, patch[, options])</span> - attempts to apply a unified diff patch.</p>
<p class="startli">Hunks are applied first to last. <span class="tt">applyPatch</span> first tries to apply the first hunk at the line number specified in the hunk header, and with all context lines matching exactly. If that fails, it tries scanning backwards and forwards, one line at a time, to find a place to apply the hunk where the context lines match exactly. If that still fails, and <span class="tt">fuzzFactor</span> is greater than zero, it increments the maximum number of mismatches (missing, extra, or changed context lines) that there can be between the hunk context and a region where we are trying to apply the patch such that the hunk will still be considered to match. Regardless of <span class="tt">fuzzFactor</span>, lines to be deleted in the hunk <em>must</em> be present for a hunk to match, and the context lines <em>immediately</em> before and after an insertion must match exactly.</p>
<p class="startli">Once a hunk is successfully fitted, the process begins again with the next hunk. Regardless of <span class="tt">fuzzFactor</span>, later hunks must be applied later in the file than earlier hunks.</p>
<p class="startli">If a hunk cannot be successfully fitted <em>anywhere</em> with fewer than <span class="tt">fuzzFactor</span> mismatches, <span class="tt">applyPatch</span> fails and returns <span class="tt">false</span>.</p>
<p class="startli">If a hunk is successfully fitted but not at the line number specified by the hunk header, all subsequent hunks have their target line number adjusted accordingly. (e.g. if the first hunk is applied 10 lines below where the hunk header said it should fit, <span class="tt">applyPatch</span> will <em>start</em> looking for somewhere to apply the second hunk 10 lines below where its hunk header says it goes.)</p>
<p class="startli">If the patch was applied successfully, returns a string containing the patched text. If the patch could not be applied (because some hunks in the patch couldn't be fitted to the text in <span class="tt">source</span>), <span class="tt">applyPatch</span> returns false.</p>
<p class="startli"><span class="tt">patch</span> may be a string diff or the output from the <span class="tt">parsePatch</span> or <span class="tt">structuredPatch</span> methods.</p>
<p class="startli">The optional <span class="tt">options</span> object may have the following keys:</p><ul>
<li><span class="tt">fuzzFactor</span>: Maximum Levenshtein distance (in lines deleted, added, or subtituted) between the context shown in a patch hunk and the lines found in the file. Defaults to 0.</li>
<li><span class="tt">autoConvertLineEndings</span>: If <span class="tt">true</span>, and if the file to be patched consistently uses different line endings to the patch (i.e. either the file always uses Unix line endings while the patch uses Windows ones, or vice versa), then <span class="tt">applyPatch</span> will behave as if the line endings in the patch were the same as those in the source file. (If <span class="tt">false</span>, the patch will usually fail to apply in such circumstances since lines deleted in the patch won't be considered to match those in the source file.) Defaults to <span class="tt">true</span>.</li>
<li><span class="tt">compareLine(lineNumber, line, operation, patchContent)</span>: Callback used to compare to given lines to determine if they should be considered equal when patching. Defaults to strict equality but may be overridden to provide fuzzier comparison. Should return false if the lines should be rejected.</li>
</ul>
</li>
<li><p class="startli"><span class="tt">Diff.applyPatches(patch, options)</span> - applies one or more patches.</p>
<p class="startli"><span class="tt">patch</span> may be either an array of structured patch objects, or a string representing a patch in unified diff format (which may patch one or more files).</p>
<p class="startli">This method will iterate over the contents of the patch and apply to data provided through callbacks. The general flow for each patch index is:</p><ul>
<li><span class="tt">options.loadFile(index, callback)</span> is called. The caller should then load the contents of the file and then pass that to the <span class="tt">callback(err, data)</span> callback. Passing an <span class="tt">err</span> will terminate further patch execution.</li>
<li><span class="tt">options.patched(index, content, callback)</span> is called once the patch has been applied. <span class="tt">content</span> will be the return value from <span class="tt">applyPatch</span>. When it's ready, the caller should call <span class="tt">callback(err)</span> callback. Passing an <span class="tt">err</span> will terminate further patch execution.</li>
</ul>
<p class="startli">Once all patches have been applied or an error occurs, the <span class="tt">options.complete(err)</span> callback is made.</p>
</li>
<li><p class="startli"><span class="tt">Diff.parsePatch(diffStr)</span> - Parses a patch into structured data</p>
<p class="startli">Return a JSON object representation of the a patch, suitable for use with the <span class="tt">applyPatch</span> method. This parses to the same structure returned by <span class="tt">Diff.structuredPatch</span>.</p>
</li>
<li><p class="startli"><span class="tt">Diff.reversePatch(patch)</span> - Returns a new structured patch which when applied will undo the original <span class="tt">patch</span>.</p>
<p class="startli"><span class="tt">patch</span> may be either a single structured patch object (as returned by <span class="tt">structuredPatch</span>) or an array of them (as returned by <span class="tt">parsePatch</span>).</p>
</li>
<li><span class="tt">Diff.convertChangesToXML(changes)</span> - converts a list of change objects to a serialized XML format</li>
<li><span class="tt">Diff.convertChangesToDMP(changes)</span> - converts a list of change objects to the format returned by Google's <a href="https://github.com/google/diff-match-patch">diff-match-patch</a> library</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5312"></a>
Universal <span class="tt">options</span></h3>
<p>Certain options can be provided in the <span class="tt">options</span> object of <em>any</em> method that calculates a diff (including <span class="tt">diffChars</span>, <span class="tt">diffLines</span> etc. as well as <span class="tt">structuredPatch</span>, <span class="tt">createPatch</span>, and <span class="tt">createTwoFilesPatch</span>):</p>
<ul>
<li><p class="startli"><span class="tt">callback</span>: if provided, the diff will be computed in async mode to avoid blocking the event loop while the diff is calculated. The value of the <span class="tt">callback</span> option should be a function and will be passed the computed diff or patch as its first argument.</p>
<p class="startli">(Note that if the ONLY option you want to provide is a callback, you can pass the callback function directly as the <span class="tt">options</span> parameter instead of passing an object with a <span class="tt">callback</span> property.)</p>
</li>
<li><span class="tt">maxEditLength</span>: a number specifying the maximum edit distance to consider between the old and new texts. You can use this to limit the computational cost of diffing large, very different texts by giving up early if the cost will be huge. This option can be passed either to diffing functions (<span class="tt">diffLines</span>, <span class="tt">diffChars</span>, etc) or to patch-creation function (<span class="tt">structuredPatch</span>, <span class="tt">createPatch</span>, etc), all of which will indicate that the max edit length was reached by returning <span class="tt">undefined</span> instead of whatever they'd normally return.</li>
<li><span class="tt">timeout</span>: a number of milliseconds after which the diffing algorithm will abort and return <span class="tt">undefined</span>. Supported by the same functions as <span class="tt">maxEditLength</span>.</li>
<li><span class="tt">oneChangePerToken</span>: if <span class="tt">true</span>, the array of change objects returned will contain one change object per token (e.g. one per line if calling <span class="tt">diffLines</span>), instead of runs of consecutive tokens that are all added / all removed / all conserved being combined into a single change object.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md5313"></a>
Defining custom diffing behaviors</h2>
<p>If you need behavior a little different to what any of the text diffing functions above offer, you can roll your own by customizing both the tokenization behavior used and the notion of equality used to determine if two tokens are equal.</p>
<p>The simplest way to customize tokenization behavior is to simply tokenize the texts you want to diff yourself, with your own code, then pass the arrays of tokens to <span class="tt">diffArrays</span>. For instance, if you wanted a semantically-aware diff of some code, you could try tokenizing it using a parser specific to the programming language the code is in, then passing the arrays of tokens to <span class="tt">diffArrays</span>.</p>
<p>To customize the notion of token equality used, use the <span class="tt">comparator</span> option to <span class="tt">diffArrays</span>.</p>
<p>For even more customisation of the diffing behavior, you can create a <span class="tt">new Diff.Diff()</span> object, overwrite its <span class="tt">castInput</span>, <span class="tt">tokenize</span>, <span class="tt">removeEmpty</span>, <span class="tt">equals</span>, and <span class="tt">join</span> properties with your own functions, then call its <span class="tt">diff(oldString, newString[, options])</span> method. The methods you can overwrite are used as follows:</p>
<ul>
<li><span class="tt">castInput(value, options)</span>: used to transform the <span class="tt">oldString</span> and <span class="tt">newString</span> before any other steps in the diffing algorithm happen. For instance, <span class="tt">diffJson</span> uses <span class="tt">castInput</span> to serialize the objects being diffed to JSON. Defaults to a no-op.</li>
<li><span class="tt">tokenize(value, options)</span>: used to convert each of <span class="tt">oldString</span> and <span class="tt">newString</span> (after they've gone through <span class="tt">castInput</span>) to an array of tokens. Defaults to returning &lsquo;value.split(&rsquo;')<span class="tt"> (returning an array of individual characters).</span></li>
<li><span class="tt"></span>removeEmpty(array)<span class="tt">: called on the arrays of tokens returned by </span>tokenize<span class="tt"> and can be used to modify them. Defaults to stripping out falsey tokens, such as empty strings. </span>diffArrays<span class="tt"> overrides this to simply return the </span>array<span class="tt">, which means that falsey values like empty strings can be handled like any other token by </span>diffArrays<span class="tt">.</span></li>
<li><span class="tt"></span>equals(left, right, options)<span class="tt">: called to determine if two tokens (one from the old string, one from the new string) should be considered equal. Defaults to comparing them with </span>===<span class="tt">.</span></li>
<li><span class="tt"></span>join(tokens)<span class="tt">: gets called with an array of consecutive tokens that have either all been added, all been removed, or are all common. Needs to join them into a single value that can be used as the </span>value<span class="tt"> property of the [change object](#change-objects) for these tokens. Defaults to simply returning </span>tokens.join('')<span class="tt">.</span></li>
<li><span class="tt"></span>postProcess(changeObjects)<span class="tt">: gets called at the end of the algorithm with the [change objects](#change-objects) produced, and can do final cleanups on them. Defaults to simply returning </span>changeObjects` unchanged.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md5314"></a>
Change Objects</h2>
<p>Many of the methods above return change objects. These objects consist of the following fields:</p>
<ul>
<li><span class="tt">value</span>: The concatenated content of all the tokens represented by this change object - i.e. generally the text that is either added, deleted, or common, as a single string. In cases where tokens are considered common but are non-identical (e.g. because an option like <span class="tt">ignoreCase</span> or a custom <span class="tt">comparator</span> was used), the value from the <em>new</em> string will be provided here.</li>
<li><span class="tt">added</span>: true if the value was inserted into the new string, otherwise false</li>
<li><span class="tt">removed</span>: true if the value was removed from the old string, otherwise false</li>
<li><span class="tt">count</span>: How many tokens (e.g. chars for <span class="tt">diffChars</span>, lines for <span class="tt">diffLines</span>) the value in the change object consists of</li>
</ul>
<p>(Change objects where <span class="tt">added</span> and <span class="tt">removed</span> are both false represent content that is common to the old and new strings.)</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md5315"></a>
Examples</h1>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5316"></a>
Basic example in Node</h3>
<div class="fragment"><div class="line">require(&#39;colors&#39;);</div>
<div class="line">const Diff = require(&#39;diff&#39;);</div>
<div class="line"> </div>
<div class="line">const one = &#39;beep boop&#39;;</div>
<div class="line">const other = &#39;beep boob blah&#39;;</div>
<div class="line"> </div>
<div class="line">const diff = Diff.diffChars(one, other);</div>
<div class="line"> </div>
<div class="line">diff.forEach((part) =&gt; {</div>
<div class="line">  // green for additions, red for deletions</div>
<div class="line">  let text = part.added ? part.value.bgGreen :</div>
<div class="line">             part.removed ? part.value.bgRed :</div>
<div class="line">                            part.value;</div>
<div class="line">  process.stderr.write(text);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">console.log();</div>
</div><!-- fragment --><p> Running the above program should yield</p>
<p><img src="images/node_example.png" alt="Node Example" class="inline"/></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5317"></a>
Basic example in a web page</h3>
<div class="fragment"><div class="line">&lt;pre id=&quot;display&quot;&gt;&lt;/pre&gt;</div>
<div class="line">&lt;script src=&quot;diff.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">&lt;script&gt;</div>
<div class="line">const one = &#39;beep boop&#39;,</div>
<div class="line">    other = &#39;beep boob blah&#39;,</div>
<div class="line">    color = &#39;&#39;;</div>
<div class="line">    </div>
<div class="line">let span = null;</div>
<div class="line"> </div>
<div class="line">const diff = Diff.diffChars(one, other),</div>
<div class="line">    display = document.getElementById(&#39;display&#39;),</div>
<div class="line">    fragment = document.createDocumentFragment();</div>
<div class="line"> </div>
<div class="line">diff.forEach((part) =&gt; {</div>
<div class="line">  // green for additions, red for deletions</div>
<div class="line">  // grey for common parts</div>
<div class="line">  const color = part.added ? &#39;green&#39; :</div>
<div class="line">    part.removed ? &#39;red&#39; : &#39;grey&#39;;</div>
<div class="line">  span = document.createElement(&#39;span&#39;);</div>
<div class="line">  span.style.color = color;</div>
<div class="line">  span.appendChild(document</div>
<div class="line">    .createTextNode(part.value));</div>
<div class="line">  fragment.appendChild(span);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">display.appendChild(fragment);</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --><p>Open the above .html file in a browser and you should see</p>
<p><img src="images/web_example.png" alt="Node Example" class="inline"/></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5318"></a>
Example of generating a patch from Node</h3>
<p>The code below is roughly equivalent to the Unix command <span class="tt">diff -u file1.txt file2.txt &gt; mydiff.patch</span>:</p>
<div class="fragment"><div class="line">const Diff = require(&#39;diff&#39;);</div>
<div class="line">const file1Contents = fs.readFileSync(&quot;file1.txt&quot;).toString();</div>
<div class="line">const file2Contents = fs.readFileSync(&quot;file2.txt&quot;).toString();</div>
<div class="line">const patch = Diff.createTwoFilesPatch(&quot;file1.txt&quot;, &quot;file2.txt&quot;, file1Contents, file2Contents);</div>
<div class="line">fs.writeFileSync(&quot;mydiff.patch&quot;, patch);</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md5319"></a>
Examples of parsing and applying a patch from Node</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md5320"></a>
Applying a patch to a specified file</h4>
<p>The code below is roughly equivalent to the Unix command <span class="tt">patch file1.txt mydiff.patch</span>:</p>
<div class="fragment"><div class="line">const Diff = require(&#39;diff&#39;);</div>
<div class="line">const file1Contents = fs.readFileSync(&quot;file1.txt&quot;).toString();</div>
<div class="line">const patch = fs.readFileSync(&quot;mydiff.patch&quot;).toString();</div>
<div class="line">const patchedFile = Diff.applyPatch(file1Contents, patch);</div>
<div class="line">fs.writeFileSync(&quot;file1.txt&quot;, patchedFile);</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md5321"></a>
Applying a multi-file patch to the files specified by the patch file itself</h4>
<p>The code below is roughly equivalent to the Unix command <span class="tt">patch &lt; mydiff.patch</span>:</p>
<div class="fragment"><div class="line">const Diff = require(&#39;diff&#39;);</div>
<div class="line">const patch = fs.readFileSync(&quot;mydiff.patch&quot;).toString();</div>
<div class="line">Diff.applyPatches(patch, {</div>
<div class="line">    loadFile: (patch, callback) =&gt; {</div>
<div class="line">        let fileContents;</div>
<div class="line">        try {</div>
<div class="line">            fileContents = fs.readFileSync(patch.oldFileName).toString();</div>
<div class="line">        } catch (e) {</div>
<div class="line">            callback(`No such file: ${patch.oldFileName}`);</div>
<div class="line">            return;</div>
<div class="line">        }</div>
<div class="line">        callback(undefined, fileContents);</div>
<div class="line">    },</div>
<div class="line">    patched: (patch, patchedContent, callback) =&gt; {</div>
<div class="line">        if (patchedContent === false) {</div>
<div class="line">            callback(`Failed to apply patch to ${patch.oldFileName}`)</div>
<div class="line">            return;</div>
<div class="line">        }</div>
<div class="line">        fs.writeFileSync(patch.oldFileName, patchedContent);</div>
<div class="line">        callback();</div>
<div class="line">    },</div>
<div class="line">    complete: (err) =&gt; {</div>
<div class="line">        if (err) {</div>
<div class="line">            console.log(&quot;Failed with error:&quot;, err);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md5322"></a>
Compatibility</h1>
<p>jsdiff supports all ES3 environments with some known issues on IE8 and below. Under these browsers some diff algorithms such as word diff and others may fail due to lack of support for capturing groups in the <span class="tt">split</span> operation.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md5323"></a>
License</h1>
<p>See <a href="https://github.com/kpdecker/jsdiff/blob/master/LICENSE">LICENSE</a>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md5324"></a>
Deviations from the published Myers diff algorithm</h1>
<p>jsdiff deviates from the published algorithm in a couple of ways that don't affect results but do affect performance:</p>
<ul>
<li>jsdiff keeps track of the diff for each diagonal using a linked list of change objects for each diagonal, rather than the historical array of furthest-reaching D-paths on each diagonal contemplated on page 8 of Myers's paper.</li>
<li>jsdiff skips considering diagonals where the furthest-reaching D-path would go off the edge of the edit graph. This dramatically reduces the time cost (from quadratic to linear) in cases where the new text just appends or truncates content at the end of the old text. </li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_8983b1862dce8a71846356b6209105f4.html">EcoEats-Project</a></li><li class="navelem"><a href="dir_5091f2b68170d33f954320199e2fed0a.html">node_modules</a></li><li class="navelem"><a href="dir_35dd620445c1a14361a1e06cc0600c32.html">diff</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
