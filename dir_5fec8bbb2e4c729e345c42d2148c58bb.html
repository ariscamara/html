<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/jsdom/node_modules/tough-cookie Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_5fec8bbb2e4c729e345c42d2148c58bb.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">tough-cookie Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for tough-cookie:</div>
<div class="dyncontent">
<div class="center"><img src="dir_5fec8bbb2e4c729e345c42d2148c58bb_dep.png" border="0" usemap="#adir__5fec8bbb2e4c729e345c42d2148c58bb__dep" loading="lazy" alt="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/jsdom/node_modules/tough-cookie"/></div>
</div>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8625"></a>
tough-cookie</h1>
<p><a href="https://tools.ietf.org/html/rfc6265">RFC 6265</a> Cookies and CookieJar for Node.js</p>
<p><a href="https://nodei.co/npm/tough-cookie/"><img src="https://nodei.co/npm/tough-cookie.png?downloads=true&amp;downloadRank=true&amp;stars=true" alt="npm package" class="inline"/></a></p>
<p><a href="https://travis-ci.org/salesforce/tough-cookie"><img src="https://travis-ci.org/salesforce/tough-cookie.svg?branch=master" alt="Build Status" style="pointer-events: none;" class="inline"/></a></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8626"></a>
Synopsis</h1>
<div class="fragment"><div class="line">var tough = require(&quot;tough-cookie&quot;);</div>
<div class="line">var Cookie = tough.Cookie;</div>
<div class="line">var cookie = Cookie.parse(header);</div>
<div class="line">cookie.value = &quot;somethingdifferent&quot;;</div>
<div class="line">header = cookie.toString();</div>
<div class="line">var cookiejar = new tough.CookieJar();</div>
<div class="line"> </div>
<div class="line">// Asynchronous!</div>
<div class="line">var cookie = await cookiejar.setCookie(</div>
<div class="line">  cookie,</div>
<div class="line">  &quot;https://currentdomain.example.com/path&quot;</div>
<div class="line">);</div>
<div class="line">var cookies = await cookiejar.getCookies(&quot;https://example.com/otherpath&quot;);</div>
<div class="line"> </div>
<div class="line">// Or with callbacks!</div>
<div class="line">cookiejar.setCookie(</div>
<div class="line">  cookie,</div>
<div class="line">  &quot;https://currentdomain.example.com/path&quot;,</div>
<div class="line">  function (err, cookie) {</div>
<div class="line">    /* ... */</div>
<div class="line">  }</div>
<div class="line">);</div>
<div class="line">cookiejar.getCookies(&quot;http://example.com/otherpath&quot;, function (err, cookies) {</div>
<div class="line">  /* ... */</div>
<div class="line">});</div>
</div><!-- fragment --><p>Why the name? NPM modules <span class="tt">cookie</span>, <span class="tt">cookies</span> and <span class="tt">cookiejar</span> were already taken.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8627"></a>
Installation</h1>
<p>It's <em>so</em> easy! Install with <span class="tt">npm</span> or your preferred package manager.</p>
<div class="fragment"><div class="line">npm install tough-cookie</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md8628"></a>
Node.js Version Support</h1>
<p>We follow the <a href="https://github.com/nodejs/Release#release-schedule">node.js release schedule</a> and support all versions that are in Active LTS or Maintenance. We will always do a major release when dropping support for older versions of node, and we will do so in consultation with our community.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8629"></a>
API</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8630"></a>
tough</h2>
<p>The top-level exports from &lsquo;require('tough-cookie&rsquo;)` can all be used as pure functions and don't need to be bound.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8631"></a>
<span class="tt">parseDate(string)</span></h3>
<p>Parse a cookie date string into a <span class="tt">Date</span>. Parses according to <a href="https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.1">RFC 6265 Section 5.1.1</a>, not <span class="tt">Date.parse()</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8632"></a>
<span class="tt">formatDate(date)</span></h3>
<p>Format a <span class="tt">Date</span> into an <a href="https://datatracker.ietf.org/doc/html/rfc822#section-5">RFC 822</a> string (the RFC 6265 recommended format).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8633"></a>
<span class="tt">canonicalDomain(str)</span></h3>
<p>Transforms a domain name into a canonical domain name. The canonical domain name is a domain name that has been trimmed, lowercased, stripped of leading dot, and optionally punycode-encoded (<a href="https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.2">Section 5.1.2 of RFC 6265</a>). For the most part, this function is idempotent (calling the function with the output from a previous call returns the same output).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8634"></a>
<span class="tt">domainMatch(str, domStr[, canonicalize=true])</span></h3>
<p>Answers "does this real domain match the domain in a cookie?". The <span class="tt">str</span> is the "current" domain name and the <span class="tt">domStr</span> is the "cookie" domain name. Matches according to <a href="https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.3">RFC 6265 Section 5.1.3</a>, but it helps to think of it as a "suffix match".</p>
<p>The <span class="tt">canonicalize</span> parameter toggles whether the domain parameters get normalized with <span class="tt">canonicalDomain</span> or not.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8635"></a>
<span class="tt">defaultPath(path)</span></h3>
<p>Given a current request/response path, gives the path appropriate for storing in a cookie. This is basically the "directory" of a "file" in the path, but is specified by <a href="https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.4">Section 5.1.4 of the RFC</a>.</p>
<p>The <span class="tt">path</span> parameter MUST be <em>only</em> the pathname part of a URI (excluding the hostname, query, fragment, and so on). This is the <span class="tt">.pathname</span> property of node's <span class="tt">uri.parse()</span> output.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8636"></a>
<span class="tt">pathMatch(reqPath, cookiePath)</span></h3>
<p>Answers "does the request-path path-match a given cookie-path?" as per <a href="https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.4">RFC 6265 Section 5.1.4</a>. Returns a boolean.</p>
<p>This is essentially a prefix-match where <span class="tt">cookiePath</span> is a prefix of <span class="tt">reqPath</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8637"></a>
<span class="tt">parse(cookieString[, options])</span></h3>
<p>Alias for `Cookie.parse(cookieString[, options])`.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8638"></a>
<span class="tt">fromJSON(string)</span></h3>
<p>Alias for `Cookie.fromJSON(string)`.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8639"></a>
<span class="tt">getPublicSuffix(hostname)</span></h3>
<p>Returns the public suffix of this hostname. The public suffix is the shortest domain name upon which a cookie can be set. Returns <span class="tt">null</span> if the hostname cannot have cookies set for it.</p>
<p>For example: <span class="tt">www.example.com</span> and <span class="tt">www.subdomain.example.com</span> both have public suffix <span class="tt">example.com</span>.</p>
<p>For further information, see the <a href="http://publicsuffix.org/">Public Suffix List</a>. This module derives its list from that site. This call is a wrapper around <a href="https://www.npmjs.com/package/psl"><span class="tt">psl</span></a>'s <a href="https://www.npmjs.com/package/psl##pslgetdomain"><span class="tt">get</span> method</a>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8640"></a>
<span class="tt">cookieCompare(a, b)</span></h3>
<p>For use with <span class="tt">.sort()</span>, sorts a list of cookies into the recommended order given in step 2 of (<a href="https://datatracker.ietf.org/doc/html/rfc6265#section-5.4">RFC 6265 Section 5.4</a>). The sort algorithm is, in order of precedence:</p>
<ul>
<li>Longest <span class="tt">.path</span></li>
<li>oldest <span class="tt">.creation</span> (which has a 1-ms precision, same as <span class="tt">Date</span>)</li>
<li>lowest <span class="tt">.creationIndex</span> (to get beyond the 1-ms precision)</li>
</ul>
<div class="fragment"><div class="line">var cookies = [</div>
<div class="line">  /* unsorted array of Cookie objects */</div>
<div class="line">];</div>
<div class="line">cookies = cookies.sort(cookieCompare);</div>
</div><!-- fragment --><blockquote class="doxtable">
<p><b>Note</b>: Since the JavaScript <span class="tt">Date</span> is limited to a 1-ms precision, cookies within the same millisecond are entirely possible. This is especially true when using the <span class="tt">now</span> option to <span class="tt">.setCookie()</span>. The <span class="tt">.creationIndex</span> property is a per-process global counter, assigned during construction with <span class="tt">new Cookie()</span>, which preserves the spirit of the RFC sorting: older cookies go first. This works great for <span class="tt">MemoryCookieStore</span> since <span class="tt">Set-Cookie</span> headers are parsed in order, but is not so great for distributed systems. Sophisticated <span class="tt">Store</span>s may wish to set this to some other <em>logical clock</em> so that if cookies A and B are created in the same millisecond, but cookie A is created before cookie B, then <span class="tt">A.creationIndex &lt; B.creationIndex</span>. If you want to alter the global counter, which you probably <em>shouldn't</em> do, it's stored in <span class="tt">Cookie.cookiesCreated</span>. </p>
</blockquote>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8641"></a>
<span class="tt">permuteDomain(domain)</span></h3>
<p>Generates a list of all possible domains that <span class="tt">domainMatch()</span> the parameter. Can be handy for implementing cookie stores.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8642"></a>
<span class="tt">permutePath(path)</span></h3>
<p>Generates a list of all possible paths that <span class="tt">pathMatch()</span> the parameter. Can be handy for implementing cookie stores.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8643"></a>
Cookie</h2>
<p>Exported via <span class="tt">tough.Cookie</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8644"></a>
<span class="tt">Cookie.parse(cookieString[, options])</span></h3>
<p>Parses a single Cookie or Set-Cookie HTTP header into a <span class="tt">Cookie</span> object. Returns <span class="tt">undefined</span> if the string can't be parsed.</p>
<p>The options parameter is not required and currently has only one property:</p>
<ul>
<li><em>loose</em> - boolean - if <span class="tt">true</span> enable parsing of keyless cookies like <span class="tt">=abc</span> and <span class="tt">=</span>, which are not RFC-compliant.</li>
</ul>
<p>If options is not an object it is ignored, which means it can be used with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><span class="tt">Array#map</span></a>.</p>
<p>To process the Set-Cookie header(s) on a node HTTP/HTTPS response:</p>
<div class="fragment"><div class="line">if (Array.isArray(res.headers[&quot;set-cookie&quot;]))</div>
<div class="line">  cookies = res.headers[&quot;set-cookie&quot;].map(Cookie.parse);</div>
<div class="line">else cookies = [Cookie.parse(res.headers[&quot;set-cookie&quot;])];</div>
</div><!-- fragment --><p><em>Note:</em> In version 2.3.3, tough-cookie limited the number of spaces before the <span class="tt">=</span> to 256 characters. This limitation was removed in version 2.3.4. For more details, see <a href="https://github.com/salesforce/tough-cookie/issues/92">issue #92</a>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8645"></a>
Properties</h3>
<p>Cookie object properties:</p>
<ul>
<li><em>key</em> - string - the name or key of the cookie (default <span class="tt">""</span>)</li>
<li><em>value</em> - string - the value of the cookie (default <span class="tt">""</span>)</li>
<li><em>expires</em> - <span class="tt">Date</span> - if set, the <span class="tt">Expires=</span> attribute of the cookie (defaults to the string <span class="tt">"Infinity"</span>). See <span class="tt">setExpires()</span></li>
<li><em>maxAge</em> - seconds - if set, the <span class="tt">Max-Age=</span> attribute <em>in seconds</em> of the cookie. Can also be set to strings <span class="tt">"Infinity"</span> and <span class="tt">"-Infinity"</span> for non-expiry and immediate-expiry, respectively. See <span class="tt">setMaxAge()</span></li>
<li><em>domain</em> - string - the <span class="tt">Domain=</span> attribute of the cookie</li>
<li><em>path</em> - string - the <span class="tt">Path=</span> of the cookie</li>
<li><em>secure</em> - boolean - the <span class="tt">Secure</span> cookie flag</li>
<li><em>httpOnly</em> - boolean - the <span class="tt">HttpOnly</span> cookie flag</li>
<li><em>sameSite</em> - string - the <span class="tt">SameSite</span> cookie attribute (from RFC 6265bis); must be one of <span class="tt">none</span>, <span class="tt">lax</span>, or <span class="tt">strict</span></li>
<li><em>extensions</em> - <span class="tt">Array</span> - any unrecognized cookie attributes as strings (even if equal-signs inside)</li>
<li><em>creation</em> - <span class="tt">Date</span> - when this cookie was constructed</li>
<li><em>creationIndex</em> - number - set at construction, used to provide greater sort precision (see <span class="tt">cookieCompare(a,b)</span> for a full explanation)</li>
</ul>
<p>After a cookie has been passed through <span class="tt">CookieJar.setCookie()</span> it has the following additional attributes:</p>
<ul>
<li><em>hostOnly</em> - boolean - is this a host-only cookie (that is, no Domain field was set, but was instead implied).</li>
<li><em>pathIsDefault</em> - boolean - if true, there was no Path field on the cookie and <span class="tt">defaultPath()</span> was used to derive one.</li>
<li><em>creation</em> - <span class="tt">Date</span> - <b>modified</b> from construction to when the cookie was added to the jar.</li>
<li><em>lastAccessed</em> - <span class="tt">Date</span> - last time the cookie got accessed. Affects cookie cleaning after it is implemented. Using <span class="tt">cookiejar.getCookies(...)</span> updates this attribute.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8646"></a>
<span class="tt">new Cookie([properties])</span></h3>
<p>Receives an options object that can contain any of the above Cookie properties. Uses the default for unspecified properties.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8647"></a>
<span class="tt">.toString()</span></h3>
<p>Encodes to a Set-Cookie header value. The Expires cookie field is set using <span class="tt">formatDate()</span>, but is omitted entirely if <span class="tt">.expires</span> is <span class="tt">Infinity</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8648"></a>
<span class="tt">.cookieString()</span></h3>
<p>Encodes to a Cookie header value (specifically, the <span class="tt">.key</span> and <span class="tt">.value</span> properties joined with <span class="tt">"="</span>).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8649"></a>
<span class="tt">.setExpires(string)</span></h3>
<p>Sets the expiry based on a date-string passed through <span class="tt">parseDate()</span>. If parseDate returns <span class="tt">null</span> (that is, can't parse this date string), <span class="tt">.expires</span> is set to <span class="tt">"Infinity"</span> (a string).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8650"></a>
<span class="tt">.setMaxAge(number)</span></h3>
<p>Sets the maxAge in seconds. Coerces <span class="tt">-Infinity</span> to <span class="tt">"-Infinity"</span> and <span class="tt">Infinity</span> to <span class="tt">"Infinity"</span> so it correctly serializes to JSON.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8651"></a>
<span class="tt">.expiryDate([now=Date.now()])</span></h3>
<p><span class="tt">expiryTime()</span> computes the absolute unix-epoch milliseconds that this cookie expires. <span class="tt">expiryDate()</span> works similarly, except it returns a <span class="tt">Date</span> object. Note that in both cases the <span class="tt">now</span> parameter should be milliseconds.</p>
<p>Max-Age takes precedence over Expires (as per the RFC). The <span class="tt">.creation</span> attribute &ndash; or, by default, the <span class="tt">now</span> parameter &ndash; is used to offset the <span class="tt">.maxAge</span> attribute.</p>
<p>If Expires (<span class="tt">.expires</span>) is set, that's returned.</p>
<p>Otherwise, <span class="tt">expiryTime()</span> returns <span class="tt">Infinity</span> and <span class="tt">expiryDate()</span> returns a <span class="tt">Date</span> object for "Tue, 19 Jan 2038 03:14:07 GMT" (latest date that can be expressed by a 32-bit <span class="tt">time_t</span>; the common limit for most user-agents).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8652"></a>
<span class="tt">.TTL([now=Date.now()])</span></h3>
<p>Computes the TTL relative to <span class="tt">now</span> (milliseconds). The same precedence rules as for <span class="tt">expiryTime</span>/<span class="tt">expiryDate</span> apply.</p>
<p><span class="tt">Infinity</span> is returned for cookies without an explicit expiry and <span class="tt">0</span> is returned if the cookie is expired. Otherwise a time-to-live in milliseconds is returned.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8653"></a>
<span class="tt">.canonicalizedDomain()</span></h3>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8654"></a>
<span class="tt">.cdomain()</span></h3>
<p>Returns the canonicalized <span class="tt">.domain</span> field. This is lower-cased and punycode (<a href="https://datatracker.ietf.org/doc/html/rfc3490">RFC 3490</a>) encoded if the domain has any non-ASCII characters.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8655"></a>
<span class="tt">.toJSON()</span></h3>
<p>For convenience in using <span class="tt">JSON.serialize(cookie)</span>. Returns a plain-old <span class="tt">Object</span> that can be JSON-serialized.</p>
<p>Any <span class="tt">Date</span> properties (such as <span class="tt">.expires</span>, <span class="tt">.creation</span>, and <span class="tt">.lastAccessed</span>) are exported in ISO format (<span class="tt">.toISOString()</span>).</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: Custom <span class="tt">Cookie</span> properties are discarded. In tough-cookie 1.x, since there was no <span class="tt">.toJSON</span> method explicitly defined, all enumerable properties were captured. If you want a property to be serialized, add the property name to the <span class="tt">Cookie.serializableProperties</span> Array. </p>
</blockquote>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8656"></a>
<span class="tt">Cookie.fromJSON(strOrObj)</span></h3>
<p>Does the reverse of <span class="tt">cookie.toJSON()</span>. If passed a string, will <span class="tt">JSON.parse()</span> that first.</p>
<p>Any <span class="tt">Date</span> properties (such as <span class="tt">.expires</span>, <span class="tt">.creation</span>, and <span class="tt">.lastAccessed</span>) are parsed via <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse"><span class="tt">Date.parse</span></a>, not tough-cookie's <span class="tt">parseDate</span>, since ISO timestamps are being handled at this layer.</p>
<p>Returns <span class="tt">null</span> upon a JSON parsing error.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8657"></a>
<span class="tt">.clone()</span></h3>
<p>Does a deep clone of this cookie, implemented exactly as <span class="tt">Cookie.fromJSON(cookie.toJSON())</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8658"></a>
<span class="tt">.validate()</span></h3>
<p>Status: <em>IN PROGRESS</em>. Works for a few things, but is by no means comprehensive.</p>
<p>Validates cookie attributes for semantic correctness. Useful for "lint" checking any Set-Cookie headers you generate. For now, it returns a boolean, but eventually could return a reason string. Future-proof with this construct:</p>
<div class="fragment"><div class="line">if (cookie.validate() === true) {</div>
<div class="line">  // it&#39;s tasty</div>
<div class="line">} else {</div>
<div class="line">  // yuck!</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md8659"></a>
CookieJar</h2>
<p>Exported via <span class="tt">tough.CookieJar</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8660"></a>
<span class="tt">CookieJar([store][, options])</span></h3>
<p>Simply use <span class="tt">new CookieJar()</span>. If a custom store is not passed to the constructor, a `MemoryCookieStore` is created and used.</p>
<p>The <span class="tt">options</span> object can be omitted and can have the following properties:</p>
<ul>
<li><em>rejectPublicSuffixes</em> - boolean - default <span class="tt">true</span> - reject cookies with domains like "com" and "co.uk"</li>
<li><em>looseMode</em> - boolean - default <span class="tt">false</span> - accept malformed cookies like <span class="tt">bar</span> and <span class="tt">=bar</span>, which have an implied empty name.</li>
<li><em>prefixSecurity</em> - string - default <span class="tt">silent</span> - set to &lsquo;'unsafe-disabled&rsquo;<span class="tt">, </span>'silent'<span class="tt">, or </span>'strict'<span class="tt">. See [Cookie Prefixes](#cookie-prefixes) below.</span></li>
<li><span class="tt">_allowSpecialUseDomain_ - boolean - default </span>true<span class="tt"> - accepts special-use domain suffixes, such as </span>local`. Useful for testing purposes. This is not in the standard, but is used sometimes on the web and is accepted by most browsers.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8661"></a>
<span class="tt">.setCookie(cookieOrString, currentUrl[, options][, callback(err, cookie)])</span></h3>
<p>Attempt to set the cookie in the cookie jar. The cookie has updated <span class="tt">.creation</span>, <span class="tt">.lastAccessed</span> and <span class="tt">.hostOnly</span> properties. And returns a promise if a callback is not provided.</p>
<p>The <span class="tt">options</span> object can be omitted and can have the following properties:</p>
<ul>
<li><em>http</em> - boolean - default <span class="tt">true</span> - indicates if this is an HTTP or non-HTTP API. Affects <span class="tt">HttpOnly</span> cookies.</li>
<li><em>secure</em> - boolean - autodetect from URL - indicates if this is a "Secure" API. If the currentUrl starts with <span class="tt">https:</span> or <span class="tt">wss:</span> this defaults to <span class="tt">true</span>, otherwise <span class="tt">false</span>.</li>
<li><em>now</em> - Date - default <span class="tt">new Date()</span> - what to use for the creation or access time of cookies.</li>
<li><em>ignoreError</em> - boolean - default <span class="tt">false</span> - silently ignore things like parse errors and invalid domains. <span class="tt">Store</span> errors aren't ignored by this option.</li>
<li><em>sameSiteContext</em> - string - default unset - set to &lsquo;'none&rsquo;<span class="tt">, </span>'lax'<span class="tt">, or </span>'strict'` See SameSite Cookies below.</li>
</ul>
<p>As per the RFC, the <span class="tt">.hostOnly</span> property is set if there was no "Domain=" parameter in the cookie string (or <span class="tt">.domain</span> was null on the Cookie object). The <span class="tt">.domain</span> property is set to the fully-qualified hostname of <span class="tt">currentUrl</span> in this case. Matching this cookie requires an exact hostname match (not a <span class="tt">domainMatch</span> as per usual).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8662"></a>
<span class="tt">.setCookieSync(cookieOrString, currentUrl[, options])</span></h3>
<p>Synchronous version of `setCookie`; only works with synchronous stores (that is, the default <span class="tt">MemoryCookieStore</span>).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8663"></a>
<span class="tt">.getCookies(currentUrl[, options][, callback(err, cookies)])</span></h3>
<p>Retrieve the list of cookies that can be sent in a Cookie header for the current URL. Returns a promise if a callback is not provided.</p>
<p>Returns an array of <span class="tt">Cookie</span> objects, sorted by default using `cookieCompare`.</p>
<p>If an error is encountered it's passed as <span class="tt">err</span> to the callback, otherwise an array of <span class="tt">Cookie</span> objects is passed. The array is sorted with <span class="tt">cookieCompare()</span> unless the <span class="tt">{sort:false}</span> option is given.</p>
<p>The <span class="tt">options</span> object can be omitted and can have the following properties:</p>
<ul>
<li><em>http</em> - boolean - default <span class="tt">true</span> - indicates if this is an HTTP or non-HTTP API. Affects <span class="tt">HttpOnly</span> cookies.</li>
<li><em>secure</em> - boolean - autodetect from URL - indicates if this is a "Secure" API. If the currentUrl starts with <span class="tt">https:</span> or <span class="tt">wss:</span> then this is defaulted to <span class="tt">true</span>, otherwise <span class="tt">false</span>.</li>
<li><em>now</em> - Date - default <span class="tt">new Date()</span> - what to use for the creation or access time of cookies</li>
<li><em>expire</em> - boolean - default <span class="tt">true</span> - perform expiry-time checking of cookies and asynchronously remove expired cookies from the store. Using <span class="tt">false</span> returns expired cookies and does <b>not</b> remove them from the store (which is potentially useful for replaying Set-Cookie headers).</li>
<li><em>allPaths</em> - boolean - default <span class="tt">false</span> - if <span class="tt">true</span>, do not scope cookies by path. The default uses RFC-compliant path scoping. <b>Note</b>: may not be supported by the underlying store (the default <span class="tt">MemoryCookieStore</span> supports it).</li>
<li><em>sameSiteContext</em> - string - default unset - Set this to &lsquo;'none&rsquo;<span class="tt">, </span>'lax'<span class="tt">, or </span>'strict'` to enforce SameSite cookies upon retrieval. See SameSite Cookies below.</li>
<li><em>sort</em> - boolean - whether to sort the list of cookies.</li>
</ul>
<p>The <span class="tt">.lastAccessed</span> property of the returned cookies will have been updated.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8664"></a>
<span class="tt">.getCookiesSync(currentUrl, [{options}])</span></h3>
<p>Synchronous version of `getCookies`; only works with synchronous stores (for example, the default <span class="tt">MemoryCookieStore</span>).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8665"></a>
<span class="tt">.getCookieString(...)</span></h3>
<p>Accepts the same options as `.getCookies()` but returns a string suitable for a Cookie header rather than an Array.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8666"></a>
<span class="tt">.getCookieStringSync(...)</span></h3>
<p>Synchronous version of `getCookieString`; only works with synchronous stores (for example, the default <span class="tt">MemoryCookieStore</span>).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8667"></a>
<span class="tt">.getSetCookieStrings(...)</span></h3>
<p>Returns an array of strings suitable for <b>Set-Cookie</b> headers. Accepts the same options as `.getCookies()`. Simply maps the cookie array via <span class="tt">.toString()</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8668"></a>
<span class="tt">.getSetCookieStringsSync(...)</span></h3>
<p>Synchronous version of `getSetCookieStrings`; only works with synchronous stores (for example, the default <span class="tt">MemoryCookieStore</span>).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8669"></a>
<span class="tt">.serialize([callback(err, serializedObject)])</span></h3>
<p>Returns a promise if a callback is not provided.</p>
<p>Serialize the Jar if the underlying store supports <span class="tt">.getAllCookies</span>.</p>
<blockquote class="doxtable">
<p><b>NOTE</b>: Custom <span class="tt">Cookie</span> properties are discarded. If you want a property to be serialized, add the property name to the <span class="tt">Cookie.serializableProperties</span> Array. </p>
</blockquote>
<p>See Serialization Format.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8670"></a>
<span class="tt">.serializeSync()</span></h3>
<p>Synchronous version of `serialize`; only works with synchronous stores (for example, the default <span class="tt">MemoryCookieStore</span>).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8671"></a>
<span class="tt">.toJSON()</span></h3>
<p>Alias of `.serializeSync()` for the convenience of <span class="tt">JSON.stringify(cookiejar)</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8672"></a>
<span class="tt">CookieJar.deserialize(serialized[, store][, callback(err, object)])</span></h3>
<p>A new Jar is created and the serialized Cookies are added to the underlying store. Each <span class="tt">Cookie</span> is added via <span class="tt">store.putCookie</span> in the order in which they appear in the serialization. A promise is returned if a callback is not provided.</p>
<p>The <span class="tt">store</span> argument is optional, but should be an instance of <span class="tt">Store</span>. By default, a new instance of <span class="tt">MemoryCookieStore</span> is created.</p>
<p>As a convenience, if <span class="tt">serialized</span> is a string, it is passed through <span class="tt">JSON.parse</span> first.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8673"></a>
<span class="tt">CookieJar.deserializeSync(serialized[, store])</span></h3>
<p>Sync version of `.deserialize`; only works with synchronous stores (for example, the default <span class="tt">MemoryCookieStore</span>).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8674"></a>
<span class="tt">CookieJar.fromJSON(string)</span></h3>
<p>Alias of `.deserializeSync` to provide consistency with `Cookie.fromJSON()`.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8675"></a>
<span class="tt">.clone([store][, callback(err, cloned))</span></h3>
<p>Produces a deep clone of this jar. Modifications to the original do not affect the clone, and vice versa. Returns a promise if a callback is not provided.</p>
<p>The <span class="tt">store</span> argument is optional, but should be an instance of <span class="tt">Store</span>. By default, a new instance of <span class="tt">MemoryCookieStore</span> is created. Transferring between store types is supported so long as the source implements <span class="tt">.getAllCookies()</span> and the destination implements <span class="tt">.putCookie()</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8676"></a>
<span class="tt">.cloneSync([store])</span></h3>
<p>Synchronous version of `.clone`, returning a new <span class="tt">CookieJar</span> instance.</p>
<p>The <span class="tt">store</span> argument is optional, but must be a <em>synchronous</em> <span class="tt">Store</span> instance if specified. If not passed, a new instance of <span class="tt">MemoryCookieStore</span> is used.</p>
<p>The <em>source</em> and <em>destination</em> must both be synchronous <span class="tt">Store</span>s. If one or both stores are asynchronous, use <span class="tt">.clone</span> instead. Recall that <span class="tt">MemoryCookieStore</span> supports both synchronous and asynchronous API calls.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8677"></a>
<span class="tt">.removeAllCookies([callback(err)])</span></h3>
<p>Removes all cookies from the jar. Returns a promise if a callback is not provided.</p>
<p>This is a new backwards-compatible feature of <span class="tt">tough-cookie</span> version 2.5, so not all Stores will implement it efficiently. For Stores that do not implement <span class="tt">removeAllCookies</span>, the fallback is to call <span class="tt">removeCookie</span> after <span class="tt">getAllCookies</span>. If <span class="tt">getAllCookies</span> fails or isn't implemented in the Store, that error is returned. If one or more of the <span class="tt">removeCookie</span> calls fail, only the first error is returned.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8678"></a>
<span class="tt">.removeAllCookiesSync()</span></h3>
<p>Sync version of `.removeAllCookies()`; only works with synchronous stores (for example, the default <span class="tt">MemoryCookieStore</span>).</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8679"></a>
Store</h2>
<p>Base class for CookieJar stores. Available as <span class="tt">tough.Store</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8680"></a>
Store API</h2>
<p>The storage model for each <span class="tt">CookieJar</span> instance can be replaced with a custom implementation. The default is <span class="tt">MemoryCookieStore</span> which can be found in <a href="https://github.com/salesforce/tough-cookie/blob/master/lib/memstore.js"><span class="tt">lib/memstore.js</span></a>. The API uses continuation-passing-style to allow for asynchronous stores.</p>
<p>Stores should inherit from the base <span class="tt">Store</span> class, which is available as a top-level export.</p>
<p>Stores are asynchronous by default, but if <span class="tt">store.synchronous</span> is set to <span class="tt">true</span>, then the <span class="tt">*Sync</span> methods of the containing <span class="tt">CookieJar</span> can be used.</p>
<p>All <span class="tt">domain</span> parameters are normalized before calling.</p>
<p>The Cookie store must have all of the following methods. Note that asynchronous implementations <b>must</b> support callback parameters.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8681"></a>
<span class="tt">store.findCookie(domain, path, key, callback(err, cookie))</span></h3>
<p>Retrieve a cookie with the given domain, path, and key (name). The RFC maintains that exactly one of these cookies should exist in a store. If the store is using versioning, this means that the latest or newest such cookie should be returned.</p>
<p>Callback takes an error and the resulting <span class="tt">Cookie</span> object. If no cookie is found then <span class="tt">null</span> MUST be passed instead (that is, not an error).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8682"></a>
<span class="tt">store.findCookies(domain, path, allowSpecialUseDomain, callback(err, cookies))</span></h3>
<p>Locates cookies matching the given domain and path. This is most often called in the context of `cookiejar.getCookies()`.</p>
<p>If no cookies are found, the callback MUST be passed an empty array.</p>
<p>The resulting list is checked for applicability to the current request according to the RFC (domain-match, path-match, http-only-flag, secure-flag, expiry, and so on), so it's OK to use an optimistic search algorithm when implementing this method. However, the search algorithm used SHOULD try to find cookies that <span class="tt">domainMatch()</span> the domain and <span class="tt">pathMatch()</span> the path in order to limit the amount of checking that needs to be done.</p>
<p>As of version 0.9.12, the <span class="tt">allPaths</span> option to <span class="tt">cookiejar.getCookies()</span> above causes the path here to be <span class="tt">null</span>. If the path is <span class="tt">null</span>, path-matching MUST NOT be performed (that is, domain-matching only).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8683"></a>
<span class="tt">store.putCookie(cookie, callback(err))</span></h3>
<p>Adds a new cookie to the store. The implementation SHOULD replace any existing cookie with the same <span class="tt">.domain</span>, <span class="tt">.path</span>, and <span class="tt">.key</span> properties. Depending on the nature of the implementation, it's possible that between the call to <span class="tt">fetchCookie</span> and <span class="tt">putCookie</span> that a duplicate <span class="tt">putCookie</span> can occur.</p>
<p>The <span class="tt">cookie</span> object MUST NOT be modified; as the caller has already updated the <span class="tt">.creation</span> and <span class="tt">.lastAccessed</span> properties.</p>
<p>Pass an error if the cookie cannot be stored.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8684"></a>
<span class="tt">store.updateCookie(oldCookie, newCookie, callback(err))</span></h3>
<p>Update an existing cookie. The implementation MUST update the <span class="tt">.value</span> for a cookie with the same <span class="tt">domain</span>, <span class="tt">.path</span>, and <span class="tt">.key</span>. The implementation SHOULD check that the old value in the store is equivalent to <span class="tt">oldCookie</span> - how the conflict is resolved is up to the store.</p>
<p>The <span class="tt">.lastAccessed</span> property is always different between the two objects (to the precision possible via JavaScript's clock). Both <span class="tt">.creation</span> and <span class="tt">.creationIndex</span> are guaranteed to be the same. Stores MAY ignore or defer the <span class="tt">.lastAccessed</span> change at the cost of affecting how cookies are selected for automatic deletion (for example, least-recently-used, which is up to the store to implement).</p>
<p>Stores may wish to optimize changing the <span class="tt">.value</span> of the cookie in the store versus storing a new cookie. If the implementation doesn't define this method, a stub that calls `putCookie` is added to the store object.</p>
<p>The <span class="tt">newCookie</span> and <span class="tt">oldCookie</span> objects MUST NOT be modified.</p>
<p>Pass an error if the newCookie cannot be stored.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8685"></a>
<span class="tt">store.removeCookie(domain, path, key, callback(err))</span></h3>
<p>Remove a cookie from the store (see notes on `findCookie` about the uniqueness constraint).</p>
<p>The implementation MUST NOT pass an error if the cookie doesn't exist, and only pass an error due to the failure to remove an existing cookie.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8686"></a>
<span class="tt">store.removeCookies(domain, path, callback(err))</span></h3>
<p>Removes matching cookies from the store. The <span class="tt">path</span> parameter is optional and if missing, means all paths in a domain should be removed.</p>
<p>Pass an error ONLY if removing any existing cookies failed.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8687"></a>
<span class="tt">store.removeAllCookies(callback(err))</span></h3>
<p><em>Optional</em>. Removes all cookies from the store.</p>
<p>Pass an error if one or more cookies can't be removed.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8688"></a>
<span class="tt">store.getAllCookies(callback(err, cookies))</span></h3>
<p><em>Optional</em>. Produces an <span class="tt">Array</span> of all cookies during `jar.serialize()`. The items in the array can be true <span class="tt">Cookie</span> objects or generic <span class="tt">Object</span>s with the Serialization Format data structure.</p>
<p>Cookies SHOULD be returned in creation order to preserve sorting via `compareCookie()`. For reference, <span class="tt">MemoryCookieStore</span> sorts by <span class="tt">.creationIndex</span> since it uses true <span class="tt">Cookie</span> objects internally. If you don't return the cookies in creation order, they'll still be sorted by creation time, but this only has a precision of 1-ms. See <span class="tt">cookieCompare</span> for more detail.</p>
<p>Pass an error if retrieval fails.</p>
<p><b>Note</b>: Not all Stores can implement this due to technical limitations, so it is optional.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8689"></a>
MemoryCookieStore</h2>
<p>Inherits from <span class="tt">Store</span>.</p>
<p>A just-in-memory CookieJar synchronous store implementation, used by default. Despite being a synchronous implementation, it's usable with both the synchronous and asynchronous forms of the <span class="tt">CookieJar</span> API. Supports serialization, <span class="tt">getAllCookies</span>, and <span class="tt">removeAllCookies</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8690"></a>
Community Cookie Stores</h2>
<p>These are some Store implementations authored and maintained by the community. They aren't official and we don't vouch for them but you may be interested to have a look:</p>
<ul>
<li><a href="https://github.com/JSBizon/db-cookie-store"><span class="tt">db-cookie-store</span></a>: SQL including SQLite-based databases</li>
<li><a href="https://github.com/JSBizon/file-cookie-store"><span class="tt">file-cookie-store</span></a>: Netscape cookie file format on disk</li>
<li><a href="https://github.com/benkroeger/redis-cookie-store"><span class="tt">redis-cookie-store</span></a>: Redis</li>
<li><a href="https://github.com/mitsuru/tough-cookie-filestore"><span class="tt">tough-cookie-filestore</span></a>: JSON on disk</li>
<li><a href="https://github.com/exponentjs/tough-cookie-web-storage-store"><span class="tt">tough-cookie-web-storage-store</span></a>: DOM localStorage and sessionStorage</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8691"></a>
Serialization Format</h1>
<p><b>NOTE</b>: If you want to have custom <span class="tt">Cookie</span> properties serialized, add the property name to <span class="tt">Cookie.serializableProperties</span>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  // The version of tough-cookie that serialized this jar.</div>
<div class="line">  version: &#39;tough-cookie@1.x.y&#39;,</div>
<div class="line"> </div>
<div class="line">  // add the store type, to make humans happy:</div>
<div class="line">  storeType: &#39;MemoryCookieStore&#39;,</div>
<div class="line"> </div>
<div class="line">  // CookieJar configuration:</div>
<div class="line">  rejectPublicSuffixes: true,</div>
<div class="line">  // ... future items go here</div>
<div class="line"> </div>
<div class="line">  // Gets filled from jar.store.getAllCookies():</div>
<div class="line">  cookies: [</div>
<div class="line">    {</div>
<div class="line">      key: &#39;string&#39;,</div>
<div class="line">      value: &#39;string&#39;,</div>
<div class="line">      // ...</div>
<div class="line">      /* other Cookie.serializableProperties go here */</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md8692"></a>
RFC 6265bis</h1>
<p>Support for RFC 6265bis revision 02 is being developed. Since this is a bit of an omnibus revision to the RFC 6252, support is broken up into the functional areas.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8693"></a>
Leave Secure Cookies Alone</h2>
<p>Not yet supported.</p>
<p>This change makes it so that if a cookie is sent from the server to the client with a <span class="tt">Secure</span> attribute, the channel must also be secure or the cookie is ignored.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8694"></a>
SameSite Cookies</h2>
<p>Supported.</p>
<p>This change makes it possible for servers, and supporting clients, to mitigate certain types of CSRF attacks by disallowing <span class="tt">SameSite</span> cookies from being sent cross-origin.</p>
<p>On the Cookie object itself, you can get or set the <span class="tt">.sameSite</span> attribute, which is serialized into the <span class="tt">SameSite=</span> cookie attribute. When unset or <span class="tt">undefined</span>, no <span class="tt">SameSite=</span> attribute is serialized. The valid values of this attribute are &lsquo;'none&rsquo;<span class="tt">, </span>'lax'<span class="tt">, or </span>'strict'`. Other values are serialized as-is.</p>
<p>When parsing cookies with a <span class="tt">SameSite</span> cookie attribute, values other than &lsquo;'lax&rsquo;<span class="tt"> or </span>'strict'<span class="tt"> are parsed as </span>'none'<span class="tt">. For example, </span>SomeCookie=SomeValue; SameSite=garbage<span class="tt"> parses so that </span>cookie.sameSite === 'none'`.</p>
<p>In order to support SameSite cookies, you must provide a <span class="tt">sameSiteContext</span> option to <em>both</em> <span class="tt">setCookie</span> and <span class="tt">getCookies</span>. Valid values for this option are just like for the Cookie object, but have particular meanings:</p>
<ol type="1">
<li>&lsquo;'strict&rsquo;<span class="tt"> mode - If the request is on the same "site for cookies" (see the RFC draft for more information), pass this option to add a layer of defense against CSRF.</span></li>
<li><span class="tt"></span>'lax'<span class="tt"> mode - If the request is from another site, _but_ is directly because of navigation by the user, such as, </span>&lt;link type=prefetch&gt;&gt;<span class="tt"> or </span><a href="..."><span class="tt">, pass </span>sameSiteContext: 'lax'<span class="tt">..</span>'none'<span class="tt"> - Otherwise, pass </span>sameSiteContext: 'none'<span class="tt"> (this indicates a cross-origin request)..unset/</span>undefined` - SameSite <b>is not</b> be enforced! This can be a valid use-case for when CSRF isn't in the threat model of the system being built. It is highly recommended that you read RFC 6265bis for fine details on SameSite cookies. In particular Section 8.8</a> discusses security considerations and defense in depth.</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8695"></a>
Cookie Prefixes</h2>
<p>Supported.</p>
<p>Cookie prefixes are a way to indicate that a given cookie was set with a set of attributes simply by inspecting the first few characters of the cookie's name.</p>
<p>Cookie prefixes are defined in <a href="https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03##section-4.1.3">Section 4.1.3 of 6265bis</a>.</p>
<p>Two prefixes are defined:</p>
<ol type="1">
<li><span class="tt">"__Secure-" Prefix</span>: If a cookie's name begins with a case-sensitive match for the string "\_\_Secure-", then the cookie was set with a "Secure" attribute.</li>
<li><span class="tt">"__Host-" Prefix</span>: If a cookie's name begins with a case-sensitive match for the string "\_\_Host-", then the cookie was set with a "Secure" attribute, a "Path" attribute with a value of "/", and no "Domain" attribute.</li>
</ol>
<p>If <span class="tt">prefixSecurity</span> is enabled for <span class="tt">CookieJar</span>, then cookies that match the prefixes defined above but do not obey the attribute restrictions are not added.</p>
<p>You can define this functionality by passing in the <span class="tt">prefixSecurity</span> option to <span class="tt">CookieJar</span>. It can be one of 3 values:</p>
<ol type="1">
<li><span class="tt">silent</span>: Enable cookie prefix checking but silently fail to add the cookie if conditions are not met. Default.</li>
<li><span class="tt">strict</span>: Enable cookie prefix checking and error out if conditions are not met.</li>
<li><span class="tt">unsafe-disabled</span>: Disable cookie prefix checking.</li>
</ol>
<p>Note that if <span class="tt">ignoreError</span> is passed in as <span class="tt">true</span> then the error is silent regardless of the <span class="tt">prefixSecurity</span> option (assuming it's enabled).</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8696"></a>
Copyright and License</h1>
<p>BSD-3-Clause:</p>
<div class="fragment"><div class="line">Copyright (c) 2015, Salesforce.com, Inc.</div>
<div class="line">All rights reserved.</div>
<div class="line"> </div>
<div class="line">Redistribution and use in source and binary forms, with or without</div>
<div class="line">modification, are permitted provided that the following conditions are met:</div>
<div class="line"> </div>
<div class="line">1. Redistributions of source code must retain the above copyright notice,</div>
<div class="line">this list of conditions and the following disclaimer.</div>
<div class="line"> </div>
<div class="line">2. Redistributions in binary form must reproduce the above copyright notice,</div>
<div class="line">this list of conditions and the following disclaimer in the documentation</div>
<div class="line">and/or other materials provided with the distribution.</div>
<div class="line"> </div>
<div class="line">3. Neither the name of Salesforce.com nor the names of its contributors may</div>
<div class="line">be used to endorse or promote products derived from this software without</div>
<div class="line">specific prior written permission.</div>
<div class="line"> </div>
<div class="line">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</div>
<div class="line">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</div>
<div class="line">IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</div>
<div class="line">ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</div>
<div class="line">LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</div>
<div class="line">CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</div>
<div class="line">SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</div>
<div class="line">INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</div>
<div class="line">CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</div>
<div class="line">ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</div>
<div class="line">POSSIBILITY OF SUCH DAMAGE.</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_8983b1862dce8a71846356b6209105f4.html">EcoEats-Project</a></li><li class="navelem"><a href="dir_5091f2b68170d33f954320199e2fed0a.html">node_modules</a></li><li class="navelem"><a href="dir_d3d17922e220ba426c64bfc6dcd347aa.html">jsdom</a></li><li class="navelem"><a href="dir_e5bbdab01088393293831d1605420cf8.html">node_modules</a></li><li class="navelem"><a href="dir_5fec8bbb2e4c729e345c42d2148c58bb.html">tough-cookie</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
