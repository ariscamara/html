<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/emittery Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_8f6399b61bcd9e6592570d9241a7c681.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">emittery Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for emittery:</div>
<div class="dyncontent">
<div class="center"><img src="dir_8f6399b61bcd9e6592570d9241a7c681_dep.png" border="0" usemap="#adir__8f6399b61bcd9e6592570d9241a7c681__dep" loading="lazy" alt="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/emittery"/></div>
</div>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md5416"></a>
<img src="media/header.png" alt="" width="1000" class="inline"/></h1>
<blockquote class="doxtable">
<p>Simple and modern async event emitter </p>
</blockquote>
<p><a href="https://codecov.io/gh/sindresorhus/emittery"><img src="https://codecov.io/gh/sindresorhus/emittery/branch/main/graph/badge.svg" alt="Coverage Status" style="pointer-events: none;" class="inline"/></a> <a href="https://bundlephobia.com/result?p=emittery"><img src="https://badgen.net/bundlephobia/minzip/emittery" alt="" class="inline"/></a></p>
<p>It works in Node.js and the browser (using a bundler).</p>
<p>Emitting events asynchronously is important for production code where you want the least amount of synchronous operations. Since JavaScript is single-threaded, no other code can run while doing synchronous operations. For Node.js, that means it will block other requests, defeating the strength of the platform, which is scalability through async. In the browser, a synchronous operation could potentially cause lags and block user interaction.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md5417"></a>
Install</h1>
<div class="fragment"><div class="line">$ npm install emittery</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md5418"></a>
Usage</h1>
<div class="fragment"><div class="line">const Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">const emitter = new Emittery();</div>
<div class="line"> </div>
<div class="line">emitter.on(&#39;🦄&#39;, data =&gt; {</div>
<div class="line">    console.log(data);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const myUnicorn = Symbol(&#39;🦄&#39;);</div>
<div class="line"> </div>
<div class="line">emitter.on(myUnicorn, data =&gt; {</div>
<div class="line">    console.log(`Unicorns love ${data}`);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter.emit(&#39;🦄&#39;, &#39;🌈&#39;); // Will trigger printing &#39;🌈&#39;</div>
<div class="line">emitter.emit(myUnicorn, &#39;🦋&#39;);  // Will trigger printing &#39;Unicorns love 🦋&#39;</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md5419"></a>
API</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md5420"></a>
eventName</h2>
<p>Emittery accepts strings, symbols, and numbers as event names.</p>
<p>Symbol event names are preferred given that they can be used to avoid name collisions when your classes are extended, especially for internal events.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md5421"></a>
isDebugEnabled</h2>
<p>Toggle debug mode for all instances.</p>
<p>Default: <span class="tt">true</span> if the <span class="tt">DEBUG</span> environment variable is set to <span class="tt">emittery</span> or <span class="tt">*</span>, otherwise <span class="tt">false</span>.</p>
<p>Example:</p>
<div class="fragment"><div class="line">const Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">Emittery.isDebugEnabled = true;</div>
<div class="line"> </div>
<div class="line">const emitter1 = new Emittery({debug: {name: &#39;myEmitter1&#39;}});</div>
<div class="line">const emitter2 = new Emittery({debug: {name: &#39;myEmitter2&#39;}});</div>
<div class="line"> </div>
<div class="line">emitter1.on(&#39;test&#39;, data =&gt; {</div>
<div class="line">    // …</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter2.on(&#39;otherTest&#39;, data =&gt; {</div>
<div class="line">    // …</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter1.emit(&#39;test&#39;);</div>
<div class="line">//=&gt; [16:43:20.417][emittery:subscribe][myEmitter1] Event Name: test</div>
<div class="line">//  data: undefined</div>
<div class="line"> </div>
<div class="line">emitter2.emit(&#39;otherTest&#39;);</div>
<div class="line">//=&gt; [16:43:20.417][emittery:subscribe][myEmitter2] Event Name: otherTest</div>
<div class="line">//  data: undefined</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md5422"></a>
emitter = new Emittery(options?)</h2>
<p>Create a new instance of Emittery.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5423"></a>
options?</h3>
<p>Type: <span class="tt">object</span></p>
<p>Configure the new instance of Emittery.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md5424"></a>
debug?</h4>
<p>Type: <span class="tt">object</span></p>
<p>Configure the debugging options for this instance.</p>
<h5 class="doxsection"><a class="anchor" id="autotoc_md5425"></a>
name</h5>
<p>Type: <span class="tt">string</span>\ Default: <span class="tt">undefined</span></p>
<p>Define a name for the instance of Emittery to use when outputting debug data.</p>
<p>Example:</p>
<div class="fragment"><div class="line">const Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">Emittery.isDebugEnabled = true;</div>
<div class="line"> </div>
<div class="line">const emitter = new Emittery({debug: {name: &#39;myEmitter&#39;}});</div>
<div class="line"> </div>
<div class="line">emitter.on(&#39;test&#39;, data =&gt; {</div>
<div class="line">    // …</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter.emit(&#39;test&#39;);</div>
<div class="line">//=&gt; [16:43:20.417][emittery:subscribe][myEmitter] Event Name: test</div>
<div class="line">//  data: undefined</div>
</div><!-- fragment --><h5 class="doxsection"><a class="anchor" id="autotoc_md5426"></a>
enabled?</h5>
<p>Type: <span class="tt">boolean</span>\ Default: <span class="tt">false</span></p>
<p>Toggle debug logging just for this instance.</p>
<p>Example:</p>
<div class="fragment"><div class="line">const Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">const emitter1 = new Emittery({debug: {name: &#39;emitter1&#39;, enabled: true}});</div>
<div class="line">const emitter2 = new Emittery({debug: {name: &#39;emitter2&#39;}});</div>
<div class="line"> </div>
<div class="line">emitter1.on(&#39;test&#39;, data =&gt; {</div>
<div class="line">    // …</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter2.on(&#39;test&#39;, data =&gt; {</div>
<div class="line">    // …</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter1.emit(&#39;test&#39;);</div>
<div class="line">//=&gt; [16:43:20.417][emittery:subscribe][emitter1] Event Name: test</div>
<div class="line">//  data: undefined</div>
<div class="line"> </div>
<div class="line">emitter2.emit(&#39;test&#39;);</div>
</div><!-- fragment --><h5 class="doxsection"><a class="anchor" id="autotoc_md5427"></a>
logger?</h5>
<p>Type: <span class="tt">Function(string, string, EventName?, Record&lt;string, any&gt;?) =&gt; void</span></p>
<p>Default:</p>
<div class="fragment"><div class="line">(type, debugName, eventName, eventData) =&gt; {</div>
<div class="line">    if (typeof eventData === &#39;object&#39;) {</div>
<div class="line">        eventData = JSON.stringify(eventData);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    if (typeof eventName === &#39;symbol&#39; || typeof eventName === &#39;number&#39;) {</div>
<div class="line">        eventName = eventName.toString();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    const currentTime = new Date();</div>
<div class="line">    const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;</div>
<div class="line">    console.log(`[${logTime}][emittery:${type}][${debugName}] Event Name: ${eventName}\n\tdata: ${eventData}`);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Function that handles debug data.</p>
<p>Example:</p>
<div class="fragment"><div class="line">const Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">const myLogger = (type, debugName, eventName, eventData) =&gt; console.log(`[${type}]: ${eventName}`);</div>
<div class="line"> </div>
<div class="line">const emitter = new Emittery({</div>
<div class="line">    debug: {</div>
<div class="line">        name: &#39;myEmitter&#39;,</div>
<div class="line">        enabled: true,</div>
<div class="line">        logger: myLogger</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter.on(&#39;test&#39;, data =&gt; {</div>
<div class="line">    // …</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter.emit(&#39;test&#39;);</div>
<div class="line">//=&gt; [subscribe]: test</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md5428"></a>
on(eventName | eventName[], listener)</h3>
<p>Subscribe to one or more events.</p>
<p>Returns an unsubscribe method.</p>
<p>Using the same listener multiple times for the same event will result in only one method call per emitted event.</p>
<div class="fragment"><div class="line">const Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">const emitter = new Emittery();</div>
<div class="line"> </div>
<div class="line">emitter.on(&#39;🦄&#39;, data =&gt; {</div>
<div class="line">    console.log(data);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter.on([&#39;🦄&#39;, &#39;🐶&#39;], data =&gt; {</div>
<div class="line">    console.log(data);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter.emit(&#39;🦄&#39;, &#39;🌈&#39;); // log =&gt; &#39;🌈&#39; x2</div>
<div class="line">emitter.emit(&#39;🐶&#39;, &#39;🍖&#39;); // log =&gt; &#39;🍖&#39;</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md5429"></a>
Custom subscribable events</h4>
<p>Emittery exports some symbols which represent "meta" events that can be passed to <span class="tt">Emitter.on</span> and similar methods.</p>
<ul>
<li><span class="tt">Emittery.listenerAdded</span> - Fires when an event listener was added.</li>
<li><span class="tt">Emittery.listenerRemoved</span> - Fires when an event listener was removed.</li>
</ul>
<div class="fragment"><div class="line">const Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">const emitter = new Emittery();</div>
<div class="line"> </div>
<div class="line">emitter.on(Emittery.listenerAdded, ({listener, eventName}) =&gt; {</div>
<div class="line">    console.log(listener);</div>
<div class="line">    //=&gt; data =&gt; {}</div>
<div class="line"> </div>
<div class="line">    console.log(eventName);</div>
<div class="line">    //=&gt; &#39;🦄&#39;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter.on(&#39;🦄&#39;, data =&gt; {</div>
<div class="line">    // Handle data</div>
<div class="line">});</div>
</div><!-- fragment --><h5 class="doxsection"><a class="anchor" id="autotoc_md5430"></a>
Listener data</h5>
<ul>
<li><span class="tt">listener</span> - The listener that was added.</li>
<li><span class="tt">eventName</span> - The name of the event that was added or removed if <span class="tt">.on()</span> or <span class="tt">.off()</span> was used, or <span class="tt">undefined</span> if <span class="tt">.onAny()</span> or <span class="tt">.offAny()</span> was used.</li>
</ul>
<p>Only events that are not of this type are able to trigger these events.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md5431"></a>
listener(data)</h4>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5432"></a>
off(eventName | eventName[], listener)</h3>
<p>Remove one or more event subscriptions.</p>
<div class="fragment"><div class="line">const Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">const emitter = new Emittery();</div>
<div class="line"> </div>
<div class="line">const listener = data =&gt; console.log(data);</div>
<div class="line"> </div>
<div class="line">(async () =&gt; {</div>
<div class="line">    emitter.on([&#39;🦄&#39;, &#39;🐶&#39;, &#39;🦊&#39;], listener);</div>
<div class="line">    await emitter.emit(&#39;🦄&#39;, &#39;a&#39;);</div>
<div class="line">    await emitter.emit(&#39;🐶&#39;, &#39;b&#39;);</div>
<div class="line">    await emitter.emit(&#39;🦊&#39;, &#39;c&#39;);</div>
<div class="line">    emitter.off(&#39;🦄&#39;, listener);</div>
<div class="line">    emitter.off([&#39;🐶&#39;, &#39;🦊&#39;], listener);</div>
<div class="line">    await emitter.emit(&#39;🦄&#39;, &#39;a&#39;); // Nothing happens</div>
<div class="line">    await emitter.emit(&#39;🐶&#39;, &#39;b&#39;); // Nothing happens</div>
<div class="line">    await emitter.emit(&#39;🦊&#39;, &#39;c&#39;); // Nothing happens</div>
<div class="line">})();</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md5433"></a>
listener(data)</h4>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5434"></a>
once(eventName | eventName[])</h3>
<p>Subscribe to one or more events only once. It will be unsubscribed after the first event.</p>
<p>Returns a promise for the event data when <span class="tt">eventName</span> is emitted. This promise is extended with an <span class="tt">off</span> method.</p>
<div class="fragment"><div class="line">const Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">const emitter = new Emittery();</div>
<div class="line"> </div>
<div class="line">emitter.once(&#39;🦄&#39;).then(data =&gt; {</div>
<div class="line">    console.log(data);</div>
<div class="line">    //=&gt; &#39;🌈&#39;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter.once([&#39;🦄&#39;, &#39;🐶&#39;]).then(data =&gt; {</div>
<div class="line">    console.log(data);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter.emit(&#39;🦄&#39;, &#39;🌈&#39;); // Log =&gt; &#39;🌈&#39; x2</div>
<div class="line">emitter.emit(&#39;🐶&#39;, &#39;🍖&#39;); // Nothing happens</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md5435"></a>
events(eventName)</h3>
<p>Get an async iterator which buffers data each time an event is emitted.</p>
<p>Call <span class="tt">return()</span> on the iterator to remove the subscription.</p>
<div class="fragment"><div class="line">const Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">const emitter = new Emittery();</div>
<div class="line">const iterator = emitter.events(&#39;🦄&#39;);</div>
<div class="line"> </div>
<div class="line">emitter.emit(&#39;🦄&#39;, &#39;🌈1&#39;); // Buffered</div>
<div class="line">emitter.emit(&#39;🦄&#39;, &#39;🌈2&#39;); // Buffered</div>
<div class="line"> </div>
<div class="line">iterator</div>
<div class="line">    .next()</div>
<div class="line">    .then(({value, done}) =&gt; {</div>
<div class="line">        // done === false</div>
<div class="line">        // value === &#39;🌈1&#39;</div>
<div class="line">        return iterator.next();</div>
<div class="line">    })</div>
<div class="line">    .then(({value, done}) =&gt; {</div>
<div class="line">        // done === false</div>
<div class="line">        // value === &#39;🌈2&#39;</div>
<div class="line">        // Revoke subscription</div>
<div class="line">        return iterator.return();</div>
<div class="line">    })</div>
<div class="line">    .then(({done}) =&gt; {</div>
<div class="line">        // done === true</div>
<div class="line">    });</div>
</div><!-- fragment --><p>In practice, you would usually consume the events using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of">for await</a> statement. In that case, to revoke the subscription simply break the loop.</p>
<div class="fragment"><div class="line">const Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">const emitter = new Emittery();</div>
<div class="line">const iterator = emitter.events(&#39;🦄&#39;);</div>
<div class="line"> </div>
<div class="line">emitter.emit(&#39;🦄&#39;, &#39;🌈1&#39;); // Buffered</div>
<div class="line">emitter.emit(&#39;🦄&#39;, &#39;🌈2&#39;); // Buffered</div>
<div class="line"> </div>
<div class="line">// In an async context.</div>
<div class="line">for await (const data of iterator) {</div>
<div class="line">    if (data === &#39;🌈2&#39;) {</div>
<div class="line">        break; // Revoke the subscription when we see the value &#39;🌈2&#39;.</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>It accepts multiple event names.</p>
<div class="fragment"><div class="line">const Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">const emitter = new Emittery();</div>
<div class="line">const iterator = emitter.events([&#39;🦄&#39;, &#39;🦊&#39;]);</div>
<div class="line"> </div>
<div class="line">emitter.emit(&#39;🦄&#39;, &#39;🌈1&#39;); // Buffered</div>
<div class="line">emitter.emit(&#39;🦊&#39;, &#39;🌈2&#39;); // Buffered</div>
<div class="line"> </div>
<div class="line">iterator</div>
<div class="line">    .next()</div>
<div class="line">    .then(({value, done}) =&gt; {</div>
<div class="line">        // done === false</div>
<div class="line">        // value === &#39;🌈1&#39;</div>
<div class="line">        return iterator.next();</div>
<div class="line">    })</div>
<div class="line">    .then(({value, done}) =&gt; {</div>
<div class="line">        // done === false</div>
<div class="line">        // value === &#39;🌈2&#39;</div>
<div class="line">        // Revoke subscription</div>
<div class="line">        return iterator.return();</div>
<div class="line">    })</div>
<div class="line">    .then(({done}) =&gt; {</div>
<div class="line">        // done === true</div>
<div class="line">    });</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md5436"></a>
emit(eventName, data?)</h3>
<p>Trigger an event asynchronously, optionally with some data. Listeners are called in the order they were added, but executed concurrently.</p>
<p>Returns a promise that resolves when all the event listeners are done. <em>Done</em> meaning executed if synchronous or resolved when an async/promise-returning function. You usually wouldn't want to wait for this, but you could for example catch possible errors. If any of the listeners throw/reject, the returned promise will be rejected with the error, but the other listeners will not be affected.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5437"></a>
emitSerial(eventName, data?)</h3>
<p>Same as above, but it waits for each listener to resolve before triggering the next one. This can be useful if your events depend on each other. Although ideally they should not. Prefer <span class="tt">emit()</span> whenever possible.</p>
<p>If any of the listeners throw/reject, the returned promise will be rejected with the error and the remaining listeners will <em>not</em> be called.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5438"></a>
onAny(listener)</h3>
<p>Subscribe to be notified about any event.</p>
<p>Returns a method to unsubscribe.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md5439"></a>
listener(eventName, data)</h4>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5440"></a>
offAny(listener)</h3>
<p>Remove an <span class="tt">onAny</span> subscription.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5441"></a>
anyEvent()</h3>
<p>Get an async iterator which buffers a tuple of an event name and data each time an event is emitted.</p>
<p>Call <span class="tt">return()</span> on the iterator to remove the subscription.</p>
<div class="fragment"><div class="line">const Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">const emitter = new Emittery();</div>
<div class="line">const iterator = emitter.anyEvent();</div>
<div class="line"> </div>
<div class="line">emitter.emit(&#39;🦄&#39;, &#39;🌈1&#39;); // Buffered</div>
<div class="line">emitter.emit(&#39;🌟&#39;, &#39;🌈2&#39;); // Buffered</div>
<div class="line"> </div>
<div class="line">iterator.next()</div>
<div class="line">    .then(({value, done}) =&gt; {</div>
<div class="line">        // done === false</div>
<div class="line">        // value is [&#39;🦄&#39;, &#39;🌈1&#39;]</div>
<div class="line">        return iterator.next();</div>
<div class="line">    })</div>
<div class="line">    .then(({value, done}) =&gt; {</div>
<div class="line">        // done === false</div>
<div class="line">        // value is [&#39;🌟&#39;, &#39;🌈2&#39;]</div>
<div class="line">        // Revoke subscription</div>
<div class="line">        return iterator.return();</div>
<div class="line">    })</div>
<div class="line">    .then(({done}) =&gt; {</div>
<div class="line">        // done === true</div>
<div class="line">    });</div>
</div><!-- fragment --><p>In the same way as for <span class="tt">events</span>, you can subscribe by using the <span class="tt">for await</span> statement</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5442"></a>
clearListeners(eventNames?)</h3>
<p>Clear all event listeners on the instance.</p>
<p>If <span class="tt">eventNames</span> is given, only the listeners for that events are cleared.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5443"></a>
listenerCount(eventNames?)</h3>
<p>The number of listeners for the <span class="tt">eventNames</span> or all events if not specified.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5444"></a>
bindMethods(target, methodNames?)</h3>
<p>Bind the given <span class="tt">methodNames</span>, or all <span class="tt">Emittery</span> methods if <span class="tt">methodNames</span> is not defined, into the <span class="tt">target</span> object.</p>
<div class="fragment"><div class="line">import Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">const object = {};</div>
<div class="line"> </div>
<div class="line">new Emittery().bindMethods(object);</div>
<div class="line"> </div>
<div class="line">object.emit(&#39;event&#39;);</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md5445"></a>
TypeScript</h1>
<p>The default <span class="tt">Emittery</span> class has generic types that can be provided by TypeScript users to strongly type the list of events and the data passed to their event listeners.</p>
<div class="fragment"><div class="line">import Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">const emitter = new Emittery&lt;</div>
<div class="line">    // Pass `{[eventName]: undefined | &lt;eventArg&gt;}` as the first type argument for events that pass data to their listeners.</div>
<div class="line">    // A value of `undefined` in this map means the event listeners should expect no data, and a type other than `undefined` means the listeners will receive one argument of that type.</div>
<div class="line">    {</div>
<div class="line">        open: string,</div>
<div class="line">        close: undefined</div>
<div class="line">    }</div>
<div class="line">&gt;();</div>
<div class="line"> </div>
<div class="line">// Typechecks just fine because the data type for the `open` event is `string`.</div>
<div class="line">emitter.emit(&#39;open&#39;, &#39;foo\n&#39;);</div>
<div class="line"> </div>
<div class="line">// Typechecks just fine because `close` is present but points to undefined in the event data type map.</div>
<div class="line">emitter.emit(&#39;close&#39;);</div>
<div class="line"> </div>
<div class="line">// TS compilation error because `1` isn&#39;t assignable to `string`.</div>
<div class="line">emitter.emit(&#39;open&#39;, 1);</div>
<div class="line"> </div>
<div class="line">// TS compilation error because `other` isn&#39;t defined in the event data type map.</div>
<div class="line">emitter.emit(&#39;other&#39;);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md5446"></a>
Emittery.mixin(emitteryPropertyName, methodNames?)</h2>
<p>A decorator which mixins <span class="tt">Emittery</span> as property <span class="tt">emitteryPropertyName</span> and <span class="tt">methodNames</span>, or all <span class="tt">Emittery</span> methods if <span class="tt">methodNames</span> is not defined, into the target class.</p>
<div class="fragment"><div class="line">import Emittery = require(&#39;emittery&#39;);</div>
<div class="line"> </div>
<div class="line">@Emittery.mixin(&#39;emittery&#39;)</div>
<div class="line">class MyClass {}</div>
<div class="line"> </div>
<div class="line">const instance = new MyClass();</div>
<div class="line"> </div>
<div class="line">instance.emit(&#39;event&#39;);</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md5447"></a>
Scheduling details</h1>
<p>Listeners are not invoked for events emitted <em>before</em> the listener was added. Removing a listener will prevent that listener from being invoked, even if events are in the process of being (asynchronously!) emitted. This also applies to <span class="tt">.clearListeners()</span>, which removes all listeners. Listeners will be called in the order they were added. So-called <em>any</em> listeners are called <em>after</em> event-specific listeners.</p>
<p>Note that when using <span class="tt">.emitSerial()</span>, a slow listener will delay invocation of subsequent listeners. It's possible for newer events to overtake older ones.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md5448"></a>
Debugging</h1>
<p>Emittery can collect and log debug information.</p>
<p>To enable this feature set the DEBUG environment variable to 'emittery' or '*'. Additionally you can set the static <span class="tt">isDebugEnabled</span> variable to true on the Emittery class, or <span class="tt">myEmitter.debug.enabled</span> on an instance of it for debugging a single instance.</p>
<p>See API for more details on how debugging works.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md5449"></a>
FAQ</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md5450"></a>
How is this different than the built-in <span class="tt">EventEmitter</span> in Node.js?</h2>
<p>There are many things to not like about <span class="tt">EventEmitter</span>: its huge API surface, synchronous event emitting, magic error event, flawed memory leak detection. Emittery has none of that.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md5451"></a>
Isn't <span class="tt">EventEmitter</span> synchronous for a reason?</h2>
<p>Mostly backwards compatibility reasons. The Node.js team can't break the whole ecosystem.</p>
<p>It also allows silly code like this:</p>
<div class="fragment"><div class="line">let unicorn = false;</div>
<div class="line"> </div>
<div class="line">emitter.on(&#39;🦄&#39;, () =&gt; {</div>
<div class="line">    unicorn = true;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter.emit(&#39;🦄&#39;);</div>
<div class="line"> </div>
<div class="line">console.log(unicorn);</div>
<div class="line">//=&gt; true</div>
</div><!-- fragment --><p>But I would argue doing that shows a deeper lack of Node.js and async comprehension and is not something we should optimize for. The benefit of async emitting is much greater.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md5452"></a>
Can you support multiple arguments for <span class="tt">emit()</span>?</h2>
<p>No, just use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">destructuring</a>:</p>
<div class="fragment"><div class="line">emitter.on(&#39;🦄&#39;, ([foo, bar]) =&gt; {</div>
<div class="line">    console.log(foo, bar);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">emitter.emit(&#39;🦄&#39;, [foo, bar]);</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md5453"></a>
Related</h1>
<ul>
<li><a href="https://github.com/sindresorhus/p-event">p-event</a> - Promisify an event by waiting for it to be emitted </li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_8983b1862dce8a71846356b6209105f4.html">EcoEats-Project</a></li><li class="navelem"><a href="dir_5091f2b68170d33f954320199e2fed0a.html">node_modules</a></li><li class="navelem"><a href="dir_8f6399b61bcd9e6592570d9241a7c681.html">emittery</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
