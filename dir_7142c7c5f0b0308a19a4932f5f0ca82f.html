<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_7142c7c5f0b0308a19a4932f5f0ca82f.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">typebox Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for typebox:</div>
<div class="dyncontent">
<div class="center"><img src="dir_7142c7c5f0b0308a19a4932f5f0ca82f_dep.png" border="0" usemap="#adir__7142c7c5f0b0308a19a4932f5f0ca82f__dep" loading="lazy" alt="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox"/></div>
</div>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div align="center"></div><div align="center"><h1>TypeBox</h1>
</div><div align="center"></div><div align="center"></div><div align="center">Json Schema Type Builder with Static Type Resolution for TypeScript</div><div align="center"></div><div align="center"><img src="https://raw.githubusercontent.com/sinclairzx81/typebox/refs/heads/master/typebox.png" alt="" class="inline"/></div><div align="center"><br  />
 <br  />
</div><div align="center"><a href="https://badge.fury.io/js/%40sinclair%2Ftypebox"><img src="https://badge.fury.io/js/%40sinclair%2Ftypebox.svg" alt="npm version" style="pointer-events: none;" class="inline"/></a> <a href="https://www.npmjs.com/package/%40sinclair%2Ftypebox"><img src="https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg" alt="Downloads" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/sinclairzx81/typebox/actions/workflows/build.yml"><img src="https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg" alt="Build" style="pointer-events: none;" class="inline"/></a> <a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/License-MIT-yellow.svg" alt="License" style="pointer-events: none;" class="inline"/></a></div><div align="center"></div><p><a class="anchor" id="Install"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2013"></a>
Install</h2>
<div class="fragment"><div class="line">$ npm install @sinclair/typebox --save</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md2014"></a>
Example</h2>
<div class="fragment"><div class="line">import { Type, type Static } from &#39;@sinclair/typebox&#39;</div>
<div class="line"> </div>
<div class="line">const T = Type.Object({                              // const T = {</div>
<div class="line">  x: Type.Number(),                                  //   type: &#39;object&#39;,</div>
<div class="line">  y: Type.Number(),                                  //   required: [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;],</div>
<div class="line">  z: Type.Number()                                   //   properties: {</div>
<div class="line">})                                                   //     x: { type: &#39;number&#39; },</div>
<div class="line">                                                     //     y: { type: &#39;number&#39; },</div>
<div class="line">                                                     //     z: { type: &#39;number&#39; }</div>
<div class="line">                                                     //   }</div>
<div class="line">                                                     // }</div>
<div class="line"> </div>
<div class="line">type T = Static&lt;typeof T&gt;                            // type T = {</div>
<div class="line">                                                     //   x: number,</div>
<div class="line">                                                     //   y: number,</div>
<div class="line">                                                     //   z: number</div>
<div class="line">                                                     // }</div>
</div><!-- fragment --><p><a class="anchor" id="Overview"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2015"></a>
Overview</h2>
<p>TypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The schematics produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox offers a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.</p>
<p>This library is designed to allow Json Schema to compose similar to how types compose within TypeScript's type system. It can be used as a simple tool to build up complex schematics or integrated into REST and RPC services to help validate data received over the wire.</p>
<p>License MIT</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2016"></a>
Contents</h2>
<ul>
<li>Install</li>
<li><a class="el" href="md__c_1_2_users_2arisc_2_one_drive_2_documents_2_git_hub_2_f_i_n_a_l_2_eco_eats-_project_2node__5f6b1f2a276b4f6e3416fbe61567da5a.html#overview">Overview</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#usage">Usage</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#types">Types</a><ul>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#types-json">Json</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#types-javascript">JavaScript</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#types-options">Options</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#types-properties">Properties</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#types-generics">Generics</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#types-recursive">Recursive</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#types-modules">Modules</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#types-template-literal">Template Literal</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#types-indexed">Indexed</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#types-mapped">Mapped</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#types-conditional">Conditional</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#types-transform">Transform</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#types-guard">Guard</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#types-unsafe">Unsafe</a></li>
</ul>
</li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#values">Values</a><ul>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#values-assert">Assert</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#values-create">Create</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#values-clone">Clone</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#values-check">Check</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#values-convert">Convert</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#values-default">Default</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#values-clean">Clean</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#values-cast">Cast</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#values-decode">Decode</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#values-decode">Encode</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#values-parse">Parse</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#values-equal">Equal</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#values-hash">Hash</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#values-diff">Diff</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#values-patch">Patch</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#values-errors">Errors</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#values-mutate">Mutate</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#values-pointer">Pointer</a></li>
</ul>
</li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#syntax">Syntax</a><ul>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#syntax-create">Create</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#syntax-parameters">Parameters</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#syntax-generics">Generics</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#syntax-options">Options</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#syntax-no-infer">NoInfer</a></li>
</ul>
</li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#typeregistry">TypeRegistry</a><ul>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#typeregistry-type">Type</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#typeregistry-format">Format</a></li>
</ul>
</li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#typecheck">TypeCheck</a><ul>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#typecheck-ajv">Ajv</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#typecheck-typecompiler">TypeCompiler</a></li>
</ul>
</li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#typemap">TypeMap</a><ul>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#typemap-usage">Usage</a></li>
</ul>
</li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#typesystem">TypeSystem</a><ul>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#typesystem-policies">Policies</a></li>
</ul>
</li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#error-function">Error Function</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#workbench">Workbench</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#codegen">Codegen</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@types/jest/node_modules/@sinclair/typebox/readme.md#ecosystem">Ecosystem</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#benchmark">Benchmark</a><ul>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#benchmark-compile">Compile</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#benchmark-validate">Validate</a></li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#benchmark-compression">Compression</a></li>
</ul>
</li>
<li><a class="el" href="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@sinclair/typebox/readme.md#contribute">Contribute</a></li>
</ul>
<p><a class="anchor" id="usage"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2017"></a>
Usage</h2>
<p>The following shows general usage.</p>
<div class="fragment"><div class="line">import { Type, type Static } from &#39;@sinclair/typebox&#39;</div>
<div class="line"> </div>
<div class="line">//--------------------------------------------------------------------------------------------</div>
<div class="line">//</div>
<div class="line">// Let&#39;s say you have the following type ...</div>
<div class="line">//</div>
<div class="line">//--------------------------------------------------------------------------------------------</div>
<div class="line"> </div>
<div class="line">type T = {</div>
<div class="line">  id: string,</div>
<div class="line">  name: string,</div>
<div class="line">  timestamp: number</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//--------------------------------------------------------------------------------------------</div>
<div class="line">//</div>
<div class="line">// ... you can express this type in the following way.</div>
<div class="line">//</div>
<div class="line">//--------------------------------------------------------------------------------------------</div>
<div class="line"> </div>
<div class="line">const T = Type.Object({                              // const T = {</div>
<div class="line">  id: Type.String(),                                 //   type: &#39;object&#39;,</div>
<div class="line">  name: Type.String(),                               //   properties: {</div>
<div class="line">  timestamp: Type.Integer()                          //     id: {</div>
<div class="line">})                                                   //       type: &#39;string&#39;</div>
<div class="line">                                                     //     },</div>
<div class="line">                                                     //     name: {</div>
<div class="line">                                                     //       type: &#39;string&#39;</div>
<div class="line">                                                     //     },</div>
<div class="line">                                                     //     timestamp: {</div>
<div class="line">                                                     //       type: &#39;integer&#39;</div>
<div class="line">                                                     //     }</div>
<div class="line">                                                     //   },</div>
<div class="line">                                                     //   required: [</div>
<div class="line">                                                     //     &#39;id&#39;,</div>
<div class="line">                                                     //     &#39;name&#39;,</div>
<div class="line">                                                     //     &#39;timestamp&#39;</div>
<div class="line">                                                     //   ]</div>
<div class="line">                                                     // }</div>
<div class="line"> </div>
<div class="line">//--------------------------------------------------------------------------------------------</div>
<div class="line">//</div>
<div class="line">// ... then infer back to the original static type this way.</div>
<div class="line">//</div>
<div class="line">//--------------------------------------------------------------------------------------------</div>
<div class="line"> </div>
<div class="line">type T = Static&lt;typeof T&gt;                            // type T = {</div>
<div class="line">                                                     //   id: string,</div>
<div class="line">                                                     //   name: string,</div>
<div class="line">                                                     //   timestamp: number</div>
<div class="line">                                                     // }</div>
<div class="line"> </div>
<div class="line">//--------------------------------------------------------------------------------------------</div>
<div class="line">//</div>
<div class="line">// ... or use the type to parse JavaScript values.</div>
<div class="line">//</div>
<div class="line">//--------------------------------------------------------------------------------------------</div>
<div class="line"> </div>
<div class="line">import { Value } from &#39;@sinclair/typebox/value&#39;</div>
<div class="line"> </div>
<div class="line">const R = Value.Parse(T, value)                      // const R: {</div>
<div class="line">                                                     //   id: string,</div>
<div class="line">                                                     //   name: string,</div>
<div class="line">                                                     //   timestamp: number</div>
<div class="line">                                                     // }</div>
</div><!-- fragment --><p><a class="anchor" id="types"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2018"></a>
Types</h2>
<p>TypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.</p>
<p><a class="anchor" id="types-json"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2019"></a>
Json Types</h3>
<p>The following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.</p>
<div class="fragment"><div class="line">┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐</div>
<div class="line">│ TypeBox                        │ TypeScript                  │ Json Schema                    │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Any()           │ type T = any                │ const T = { }                  │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.String()        │ type T = string             │ const T = {                    │</div>
<div class="line">│                                │                             │   type: &#39;string&#39;               │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Number()        │ type T = number             │ const T = {                    │</div>
<div class="line">│                                │                             │   type: &#39;number&#39;               │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Integer()       │ type T = number             │ const T = {                    │</div>
<div class="line">│                                │                             │   type: &#39;integer&#39;              │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │</div>
<div class="line">│                                │                             │   type: &#39;boolean&#39;              │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Null()          │ type T = null               │ const T = {                    │</div>
<div class="line">│                                │                             │   type: &#39;null&#39;                 │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │</div>
<div class="line">│                                │                             │   const: 42,                   │</div>
<div class="line">│                                │                             │   type: &#39;number&#39;               │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │</div>
<div class="line">│   Type.Number()                │                             │   type: &#39;array&#39;,               │</div>
<div class="line">│ )                              │                             │   items: {                     │</div>
<div class="line">│                                │                             │     type: &#39;number&#39;             │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Object({        │ type T = {                  │ const T = {                    │</div>
<div class="line">│   x: Type.Number(),            │   x: number,                │   type: &#39;object&#39;,              │</div>
<div class="line">│   y: Type.Number()             │   y: number                 │   required: [&#39;x&#39;, &#39;y&#39;],        │</div>
<div class="line">│ })                             │ }                           │   properties: {                │</div>
<div class="line">│                                │                             │     x: {                       │</div>
<div class="line">│                                │                             │       type: &#39;number&#39;           │</div>
<div class="line">│                                │                             │     },                         │</div>
<div class="line">│                                │                             │     y: {                       │</div>
<div class="line">│                                │                             │       type: &#39;number&#39;           │</div>
<div class="line">│                                │                             │     }                          │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │</div>
<div class="line">│   Type.Number(),               │                             │   type: &#39;array&#39;,               │</div>
<div class="line">│   Type.Number()                │                             │   items: [{                    │</div>
<div class="line">│ ])                             │                             │     type: &#39;number&#39;             │</div>
<div class="line">│                                │                             │   }, {                         │</div>
<div class="line">│                                │                             │     type: &#39;number&#39;             │</div>
<div class="line">│                                │                             │   }],                          │</div>
<div class="line">│                                │                             │   additionalItems: false,      │</div>
<div class="line">│                                │                             │   minItems: 2,                 │</div>
<div class="line">│                                │                             │   maxItems: 2                  │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ enum Foo {                     │ enum Foo {                  │ const T = {                    │</div>
<div class="line">│   A,                           │   A,                        │   anyOf: [{                    │</div>
<div class="line">│   B                            │   B                         │     type: &#39;number&#39;,            │</div>
<div class="line">│ }                              │ }                           │     const: 0                   │</div>
<div class="line">│                                │                             │   }, {                         │</div>
<div class="line">│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: &#39;number&#39;,            │</div>
<div class="line">│                                │                             │     const: 1                   │</div>
<div class="line">│                                │                             │   }]                           │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Const({         │ type T = {                  │ const T = {                    │</div>
<div class="line">│   x: 1,                        │   readonly x: 1,            │   type: &#39;object&#39;,              │</div>
<div class="line">│   y: 2,                        │   readonly y: 2             │   required: [&#39;x&#39;, &#39;y&#39;],        │</div>
<div class="line">│ } as const)                    │ }                           │   properties: {                │</div>
<div class="line">│                                │                             │     x: {                       │</div>
<div class="line">│                                │                             │       type: &#39;number&#39;,          │</div>
<div class="line">│                                │                             │       const: 1                 │</div>
<div class="line">│                                │                             │     },                         │</div>
<div class="line">│                                │                             │     y: {                       │</div>
<div class="line">│                                │                             │       type: &#39;number&#39;,          │</div>
<div class="line">│                                │                             │       const: 2                 │</div>
<div class="line">│                                │                             │     }                          │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │</div>
<div class="line">│   Type.Object({                │   x: number,                │   anyOf: [{                    │</div>
<div class="line">│     x: Type.Number(),          │   y: number                 │     type: &#39;string&#39;,            │</div>
<div class="line">│     y: Type.Number()           │ }                           │     const: &#39;x&#39;                 │</div>
<div class="line">│   })                           │                             │   }, {                         │</div>
<div class="line">│ )                              │                             │     type: &#39;string&#39;,            │</div>
<div class="line">│                                │                             │     const: &#39;y&#39;                 │</div>
<div class="line">│                                │                             │   }]                           │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │</div>
<div class="line">│   Type.String(),               │                             │   anyOf: [{                    │</div>
<div class="line">│   Type.Number()                │                             │     type: &#39;string&#39;             │</div>
<div class="line">│ ])                             │                             │   }, {                         │</div>
<div class="line">│                                │                             │     type: &#39;number&#39;             │</div>
<div class="line">│                                │                             │   }]                           │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │</div>
<div class="line">│   Type.Object({                │   x: number                 │   allOf: [{                    │</div>
<div class="line">│     x: Type.Number()           │ } &amp; {                       │     type: &#39;object&#39;,            │</div>
<div class="line">│   }),                          │   y: number                 │     required: [&#39;x&#39;],           │</div>
<div class="line">│   Type.Object({                │ }                           │     properties: {              │</div>
<div class="line">│     y: Type.Number()           │                             │       x: {                     │</div>
<div class="line">│   })                           │                             │         type: &#39;number&#39;         │</div>
<div class="line">│ ])                             │                             │       }                        │</div>
<div class="line">│                                │                             │     }                          │</div>
<div class="line">│                                │                             │   }, {                         │</div>
<div class="line">│                                │                             │     type: &#39;object&#39;,            |</div>
<div class="line">│                                │                             │     required: [&#39;y&#39;],           │</div>
<div class="line">│                                │                             │     properties: {              │</div>
<div class="line">│                                │                             │       y: {                     │</div>
<div class="line">│                                │                             │         type: &#39;number&#39;         │</div>
<div class="line">│                                │                             │       }                        │</div>
<div class="line">│                                │                             │     }                          │</div>
<div class="line">│                                │                             │   }]                           │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │</div>
<div class="line">│   Type.Object({                │   x: number,                │   type: &#39;object&#39;,              │</div>
<div class="line">│     x: Type.Number()           │   y: number                 │   required: [&#39;x&#39;, &#39;y&#39;],        │</div>
<div class="line">│   }),                          │ }                           │   properties: {                │</div>
<div class="line">│   Type.Object({                │                             │     x: {                       │</div>
<div class="line">│     y: Type.Number()           │                             │       type: &#39;number&#39;           │</div>
<div class="line">│   })                           │                             │     },                         │</div>
<div class="line">│ ])                             │                             │     y: {                       │</div>
<div class="line">│                                │                             │       type: &#39;number&#39;           │</div>
<div class="line">│                                │                             │     }                          │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Never()         │ type T = never              │ const T = {                    │</div>
<div class="line">│                                │                             │   not: {}                      │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Not(            | type T = unknown            │ const T = {                    │</div>
<div class="line">│   Type.String()                │                             │   not: {                       │</div>
<div class="line">│ )                              │                             │     type: &#39;string&#39;             │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Extends(        │ type T =                    │ const T = {                    │</div>
<div class="line">│   Type.String(),               │  string extends number      │   const: false,                │</div>
<div class="line">│   Type.Number(),               │    ? true                   │   type: &#39;boolean&#39;              │</div>
<div class="line">│   Type.Literal(true),          │    : false                  │ }                              │</div>
<div class="line">│   Type.Literal(false)          │                             │                                │</div>
<div class="line">│ )                              │                             │                                │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Extract(        │ type T = Extract&lt;           │ const T = {                    │</div>
<div class="line">│   Type.Union([                 │   string | number,          │   type: &#39;string&#39;               │</div>
<div class="line">│     Type.String(),             │   string                    │ }                              │</div>
<div class="line">│     Type.Number(),             │ &gt;                           │                                │</div>
<div class="line">│   ]),                          │                             │                                │</div>
<div class="line">│   Type.String()                │                             │                                │</div>
<div class="line">│ )                              │                             │                                │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Exclude(        │ type T = Exclude&lt;           │ const T = {                    │</div>
<div class="line">│   Type.Union([                 │   string | number,          │   type: &#39;number&#39;               │</div>
<div class="line">│     Type.String(),             │   string                    │ }                              │</div>
<div class="line">│     Type.Number(),             │ &gt;                           │                                │</div>
<div class="line">│   ]),                          │                             │                                │</div>
<div class="line">│   Type.String()                │                             │                                │</div>
<div class="line">│ )                              │                             │                                │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │</div>
<div class="line">│   Type.Union([                 │   [_ in &#39;x&#39; | &#39;y&#39;] : number │   type: &#39;object&#39;,              │</div>
<div class="line">│     Type.Literal(&#39;x&#39;),         │ }                           │   required: [&#39;x&#39;, &#39;y&#39;],        │</div>
<div class="line">│     Type.Literal(&#39;y&#39;)          │                             │   properties: {                │</div>
<div class="line">│   ]),                          │                             │     x: {                       │</div>
<div class="line">│   () =&gt; Type.Number()          │                             │       type: &#39;number&#39;           │</div>
<div class="line">│ )                              │                             │     },                         │</div>
<div class="line">│                                │                             │     y: {                       │</div>
<div class="line">│                                │                             │       type: &#39;number&#39;           │</div>
<div class="line">│                                │                             │     }                          │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const U = Type.Union([         │ type U = &#39;open&#39; | &#39;close&#39;   │ const T = {                    │</div>
<div class="line">│   Type.Literal(&#39;open&#39;),        │                             │   type: &#39;string&#39;,              │</div>
<div class="line">│   Type.Literal(&#39;close&#39;)        │ type T = `on${U}`           │   pattern: &#39;^on(open|close)$&#39;  │</div>
<div class="line">│ ])                             │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">│ const T = Type                 │                             │                                │</div>
<div class="line">│   .TemplateLiteral([           │                             │                                │</div>
<div class="line">│      Type.Literal(&#39;on&#39;),       │                             │                                │</div>
<div class="line">│      U                         │                             │                                │</div>
<div class="line">│   ])                           │                             │                                │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Record(         │ type T = Record&lt;            │ const T = {                    │</div>
<div class="line">│   Type.String(),               │   string,                   │   type: &#39;object&#39;,              │</div>
<div class="line">│   Type.Number()                │   number                    │   patternProperties: {         │</div>
<div class="line">│ )                              │ &gt;                           │     &#39;^.*$&#39;: {                  │</div>
<div class="line">│                                │                             │       type: &#39;number&#39;           │</div>
<div class="line">│                                │                             │     }                          │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Partial(        │ type T = Partial&lt;{          │ const T = {                    │</div>
<div class="line">│   Type.Object({                │   x: number,                │   type: &#39;object&#39;,              │</div>
<div class="line">│     x: Type.Number(),          │   y: number                 │   properties: {                │</div>
<div class="line">│     y: Type.Number()           | }&gt;                          │     x: {                       │</div>
<div class="line">│   })                           │                             │       type: &#39;number&#39;           │</div>
<div class="line">│ )                              │                             │     },                         │</div>
<div class="line">│                                │                             │     y: {                       │</div>
<div class="line">│                                │                             │       type: &#39;number&#39;           │</div>
<div class="line">│                                │                             │     }                          │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Required(       │ type T = Required&lt;{         │ const T = {                    │</div>
<div class="line">│   Type.Object({                │   x?: number,               │   type: &#39;object&#39;,              │</div>
<div class="line">│     x: Type.Optional(          │   y?: number                │   required: [&#39;x&#39;, &#39;y&#39;],        │</div>
<div class="line">│       Type.Number()            | }&gt;                          │   properties: {                │</div>
<div class="line">│     ),                         │                             │     x: {                       │</div>
<div class="line">│     y: Type.Optional(          │                             │       type: &#39;number&#39;           │</div>
<div class="line">│       Type.Number()            │                             │     },                         │</div>
<div class="line">│     )                          │                             │     y: {                       │</div>
<div class="line">│   })                           │                             │       type: &#39;number&#39;           │</div>
<div class="line">│ )                              │                             │     }                          │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Pick(           │ type T = Pick&lt;{             │ const T = {                    │</div>
<div class="line">│   Type.Object({                │   x: number,                │   type: &#39;object&#39;,              │</div>
<div class="line">│     x: Type.Number(),          │   y: number                 │   required: [&#39;x&#39;],             │</div>
<div class="line">│     y: Type.Number()           │ }, &#39;x&#39;&gt;                     │   properties: {                │</div>
<div class="line">│   }), [&#39;x&#39;]                    |                             │     x: {                       │</div>
<div class="line">│ )                              │                             │       type: &#39;number&#39;           │</div>
<div class="line">│                                │                             │     }                          │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Omit(           │ type T = Omit&lt;{             │ const T = {                    │</div>
<div class="line">│   Type.Object({                │   x: number,                │   type: &#39;object&#39;,              │</div>
<div class="line">│     x: Type.Number(),          │   y: number                 │   required: [&#39;y&#39;],             │</div>
<div class="line">│     y: Type.Number()           │ }, &#39;x&#39;&gt;                     │   properties: {                │</div>
<div class="line">│   }), [&#39;x&#39;]                    |                             │     y: {                       │</div>
<div class="line">│ )                              │                             │       type: &#39;number&#39;           │</div>
<div class="line">│                                │                             │     }                          │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Index(          │ type T = {                  │ const T = {                    │</div>
<div class="line">│   Type.Object({                │   x: number,                │   type: &#39;number&#39;               │</div>
<div class="line">│     x: Type.Number(),          │   y: string                 │ }                              │</div>
<div class="line">│     y: Type.String()           │ }[&#39;x&#39;]                      │                                │</div>
<div class="line">│   }), [&#39;x&#39;]                    │                             │                                │</div>
<div class="line">│ )                              │                             │                                │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │</div>
<div class="line">│   Type.Literal(0),             │ type B = [2, 3]             │   type: &#39;array&#39;,               │</div>
<div class="line">│   Type.Literal(1)              │ type T = [                  │   items: [                     │</div>
<div class="line">│ ])                             │   ...A,                     │     { const: 0 },              │</div>
<div class="line">│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │</div>
<div class="line">|   Type.Literal(2),             │ ]                           │     { const: 2 },              │</div>
<div class="line">|   Type.Literal(3)              │                             │     { const: 3 }               │</div>
<div class="line">│ ])                             │                             │   ],                           │</div>
<div class="line">│ const T = Type.Tuple([         │                             │   additionalItems: false,      │</div>
<div class="line">|   ...Type.Rest(A),             │                             │   minItems: 4,                 │</div>
<div class="line">|   ...Type.Rest(B)              │                             │   maxItems: 4                  │</div>
<div class="line">│ ])                             │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Uncapitalize(   │ type T = Uncapitalize&lt;      │ const T = {                    │</div>
<div class="line">│   Type.Literal(&#39;Hello&#39;)        │   &#39;Hello&#39;                   │   type: &#39;string&#39;,              │</div>
<div class="line">│ )                              │ &gt;                           │   const: &#39;hello&#39;               │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Capitalize(     │ type T = Capitalize&lt;        │ const T = {                    │</div>
<div class="line">│   Type.Literal(&#39;hello&#39;)        │   &#39;hello&#39;                   │   type: &#39;string&#39;,              │</div>
<div class="line">│ )                              │ &gt;                           │   const: &#39;Hello&#39;               │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Uppercase(      │ type T = Uppercase&lt;         │ const T = {                    │</div>
<div class="line">│   Type.Literal(&#39;hello&#39;)        │   &#39;hello&#39;                   │   type: &#39;string&#39;,              │</div>
<div class="line">│ )                              │ &gt;                           │   const: &#39;HELLO&#39;               │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Lowercase(      │ type T = Lowercase&lt;         │ const T = {                    │</div>
<div class="line">│   Type.Literal(&#39;HELLO&#39;)        │   &#39;HELLO&#39;                   │   type: &#39;string&#39;,              │</div>
<div class="line">│ )                              │ &gt;                           │   const: &#39;hello&#39;               │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const R = Type.Ref(&#39;T&#39;)        │ type R = unknown            │ const R = { $ref: &#39;T&#39; }        │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘</div>
</div><!-- fragment --><p><a class="anchor" id="types-javascript"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2020"></a>
JavaScript Types</h3>
<p>TypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the <span class="tt">[JavaScript]</span> JSDoc comment for convenience. The following table lists the supported types.</p>
<div class="fragment"><div class="line">┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐</div>
<div class="line">│ TypeBox                        │ TypeScript                  │ Extended Schema                │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │</div>
<div class="line">│   Type.String(),               │  arg0: string,              │   type: &#39;Constructor&#39;,         │</div>
<div class="line">│   Type.Number()                │  arg0: number               │   parameters: [{               │</div>
<div class="line">│ ], Type.Boolean())             │ ) =&gt; boolean                │     type: &#39;string&#39;             │</div>
<div class="line">│                                │                             │   }, {                         │</div>
<div class="line">│                                │                             │     type: &#39;number&#39;             │</div>
<div class="line">│                                │                             │   }],                          │</div>
<div class="line">│                                │                             │   returns: {                   │</div>
<div class="line">│                                │                             │     type: &#39;boolean&#39;            │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Function([      │ type T = (                  │ const T = {                    │</div>
<div class="line">|   Type.String(),               │  arg0: string,              │   type: &#39;Function&#39;,            │</div>
<div class="line">│   Type.Number()                │  arg1: number               │   parameters: [{               │</div>
<div class="line">│ ], Type.Boolean())             │ ) =&gt; boolean                │     type: &#39;string&#39;             │</div>
<div class="line">│                                │                             │   }, {                         │</div>
<div class="line">│                                │                             │     type: &#39;number&#39;             │</div>
<div class="line">│                                │                             │   }],                          │</div>
<div class="line">│                                │                             │   returns: {                   │</div>
<div class="line">│                                │                             │     type: &#39;boolean&#39;            │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Promise(        │ type T = Promise&lt;string&gt;    │ const T = {                    │</div>
<div class="line">│   Type.String()                │                             │   type: &#39;Promise&#39;,             │</div>
<div class="line">│ )                              │                             │   item: {                      │</div>
<div class="line">│                                │                             │     type: &#39;string&#39;             │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T =                      │ type T =                    │ const T = {                    │</div>
<div class="line">│   Type.AsyncIterator(          │   AsyncIterableIterator&lt;    │   type: &#39;AsyncIterator&#39;,       │</div>
<div class="line">│     Type.String()              │    string                   │   items: {                     │</div>
<div class="line">│   )                            │   &gt;                         │     type: &#39;string&#39;             │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │</div>
<div class="line">│   Type.String()                │   IterableIterator&lt;string&gt;  │   type: &#39;Iterator&#39;,            │</div>
<div class="line">│ )                              │                             │   items: {                     │</div>
<div class="line">│                                │                             │     type: &#39;string&#39;             │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.RegExp(/abc/i)  │ type T = string             │ const T = {                    │</div>
<div class="line">│                                │                             │   type: &#39;RegExp&#39;               │</div>
<div class="line">│                                │                             │   source: &#39;abc&#39;                │</div>
<div class="line">│                                │                             │   flags: &#39;i&#39;                   │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │</div>
<div class="line">│                                │                             │   type: &#39;Uint8Array&#39;           │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Date()          │ type T = Date               │ const T = {                    │</div>
<div class="line">│                                │                             │   type: &#39;Date&#39;                 │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │</div>
<div class="line">│                                │                             │   type: &#39;undefined&#39;            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │</div>
<div class="line">│                                │                             │   type: &#39;symbol&#39;               │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │</div>
<div class="line">│                                │                             │   type: &#39;bigint&#39;               │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Void()          │ type T = void               │ const T = {                    │</div>
<div class="line">│                                │                             │   type: &#39;void&#39;                 │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘</div>
</div><!-- fragment --><p><a class="anchor" id="types-options"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2021"></a>
Options</h3>
<p>You can pass Json Schema options on the last argument of any given type. Option hints specific to each type are provided for convenience.</p>
<div class="fragment"><div class="line">// String must be an email</div>
<div class="line">const T = Type.String({                              // const T = {</div>
<div class="line">  format: &#39;email&#39;                                    //   type: &#39;string&#39;,</div>
<div class="line">})                                                   //   format: &#39;email&#39;</div>
<div class="line">                                                     // }</div>
<div class="line"> </div>
<div class="line">// Number must be a multiple of 2</div>
<div class="line">const T = Type.Number({                              // const T = {</div>
<div class="line">  multipleOf: 2                                      //  type: &#39;number&#39;,</div>
<div class="line">})                                                   //  multipleOf: 2</div>
<div class="line">                                                     // }</div>
<div class="line"> </div>
<div class="line">// Array must have at least 5 integer values</div>
<div class="line">const T = Type.Array(Type.Integer(), {               // const T = {</div>
<div class="line">  minItems: 5                                        //   type: &#39;array&#39;,</div>
<div class="line">})                                                   //   minItems: 5,</div>
<div class="line">                                                     //   items: {</div>
<div class="line">                                                     //     type: &#39;integer&#39;</div>
<div class="line">                                                     //   }</div>
<div class="line">                                                     // }</div>
</div><!-- fragment --><p><a class="anchor" id="types-properties"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2022"></a>
Properties</h3>
<p>Object properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.</p>
<div class="fragment"><div class="line">┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐</div>
<div class="line">│ TypeBox                        │ TypeScript                  │ Json Schema                    │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Object({        │ type T = {                  │ const T = {                    │</div>
<div class="line">│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: &#39;object&#39;,              │</div>
<div class="line">│     Type.String()              │ }                           │   properties: {                │</div>
<div class="line">│   )                            │                             │     name: {                    │</div>
<div class="line">│ })                             │                             │       type: &#39;string&#39;           │</div>
<div class="line">│                                │                             │     }                          │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Object({        │ type T = {                  │ const T = {                    │</div>
<div class="line">│   name: Type.Readonly(         │   readonly name: string     │   type: &#39;object&#39;,              │</div>
<div class="line">│     Type.String()              │ }                           │   properties: {                │</div>
<div class="line">│   )                            │                             │     name: {                    │</div>
<div class="line">│ })                             │                             │       type: &#39;string&#39;           │</div>
<div class="line">│                                │                             │     }                          │</div>
<div class="line">│                                │                             │   },                           │</div>
<div class="line">│                                │                             │   required: [&#39;name&#39;]           │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤</div>
<div class="line">│ const T = Type.Object({        │ type T = {                  │ const T = {                    │</div>
<div class="line">│   name: Type.Optional(         │   name?: string             │   type: &#39;object&#39;,              │</div>
<div class="line">│     Type.String()              │ }                           │   properties: {                │</div>
<div class="line">│   )                            │                             │     name: {                    │</div>
<div class="line">│ })                             │                             │       type: &#39;string&#39;           │</div>
<div class="line">│                                │                             │     }                          │</div>
<div class="line">│                                │                             │   }                            │</div>
<div class="line">│                                │                             │ }                              │</div>
<div class="line">│                                │                             │                                │</div>
<div class="line">└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘</div>
</div><!-- fragment --><p><a class="anchor" id="types-generics"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2023"></a>
Generic Types</h3>
<p>Generic types can be created with generic functions.</p>
<div class="fragment"><div class="line">const Nullable = &lt;T extends TSchema&gt;(T: T) =&gt; {     // type Nullable&lt;T&gt; = T | null</div>
<div class="line">  return Type.Union([T, Type.Null()])</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const T = Nullable(Type.String())                  // type T = Nullable&lt;string&gt;</div>
</div><!-- fragment --><p><a class="anchor" id="types-recursive"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2024"></a>
Recursive Types</h3>
<p>Use the Recursive function to create recursive types.</p>
<div class="fragment"><div class="line">const Node = Type.Recursive(This =&gt; Type.Object({    // const Node = {</div>
<div class="line">  id: Type.String(),                                 //   $id: &#39;Node&#39;,</div>
<div class="line">  nodes: Type.Array(This)                            //   type: &#39;object&#39;,</div>
<div class="line">}), { $id: &#39;Node&#39; })                                 //   properties: {</div>
<div class="line">                                                     //     id: {</div>
<div class="line">                                                     //       type: &#39;string&#39;</div>
<div class="line">                                                     //     },</div>
<div class="line">                                                     //     nodes: {</div>
<div class="line">                                                     //       type: &#39;array&#39;,</div>
<div class="line">                                                     //       items: {</div>
<div class="line">                                                     //         $ref: &#39;Node&#39;</div>
<div class="line">                                                     //       }</div>
<div class="line">                                                     //     }</div>
<div class="line">                                                     //   },</div>
<div class="line">                                                     //   required: [</div>
<div class="line">                                                     //     &#39;id&#39;,</div>
<div class="line">                                                     //     &#39;nodes&#39;</div>
<div class="line">                                                     //   ]</div>
<div class="line">                                                     // }</div>
<div class="line"> </div>
<div class="line">type Node = Static&lt;typeof Node&gt;                      // type Node = {</div>
<div class="line">                                                     //   id: string</div>
<div class="line">                                                     //   nodes: Node[]</div>
<div class="line">                                                     // }</div>
<div class="line"> </div>
<div class="line">function test(node: Node) {</div>
<div class="line">  const id = node.nodes[0].nodes[0].id               // id is string</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="types-modules"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2025"></a>
Module Types</h3>
<p>Module types are containers for a set of referential types. Modules act as namespaces, enabling types to reference one another via string identifiers. Modules support both singular and mutually recursive references, as well as deferred dereferencing for computed types such as Partial. Types imported from a module are expressed using the Json Schema <span class="tt">$defs</span> keyword.</p>
<div class="fragment"><div class="line">const Module = Type.Module({</div>
<div class="line">  PartialUser: Type.Partial(Type.Ref(&#39;User&#39;)),  // TComputed&lt;&#39;Partial&#39;, [TRef&lt;&#39;User&#39;&gt;]&gt;</div>
<div class="line"> </div>
<div class="line">  User: Type.Object({                           // TObject&lt;{</div>
<div class="line">    id: Type.String(),                          //   user: TString,</div>
<div class="line">    name: Type.String(),                        //   name: TString,</div>
<div class="line">    email: Type.String()                        //   email: TString</div>
<div class="line">  }),                                           // }&gt;</div>
<div class="line">})</div>
<div class="line">const User = Module.Import(&#39;User&#39;)               // const User: TImport&lt;{...}, &#39;User&#39;&gt;</div>
<div class="line"> </div>
<div class="line">type User = Static&lt;typeof User&gt;                  // type User = { </div>
<div class="line">                                                 //   id: string,</div>
<div class="line">                                                 //   name: string,</div>
<div class="line">                                                 //   email: string</div>
<div class="line">                                                 // }</div>
<div class="line"> </div>
<div class="line">const PartialUser = Module.Import(&#39;PartialUser&#39;) // const PartialUser: TImport&lt;{...}, &#39;PartialUser&#39;&gt;</div>
<div class="line"> </div>
<div class="line">type PartialUser = Static&lt;typeof PartialUser&gt;    // type PartialUser = { </div>
<div class="line">                                                 //   id?: string,</div>
<div class="line">                                                 //   name?: string,</div>
<div class="line">                                                 //   email?: string</div>
<div class="line">                                                 // }</div>
</div><!-- fragment --><p><a class="anchor" id="types-template-literal"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2026"></a>
Template Literal Types</h3>
<p>TypeBox supports template literal types with the TemplateLiteral function. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expressions which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing that enables template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.</p>
<div class="fragment"><div class="line">// TypeScript</div>
<div class="line"> </div>
<div class="line">type K = `prop${&#39;A&#39;|&#39;B&#39;|&#39;C&#39;}`                        // type T = &#39;propA&#39; | &#39;propB&#39; | &#39;propC&#39;</div>
<div class="line"> </div>
<div class="line">type R = Record&lt;K, string&gt;                           // type R = {</div>
<div class="line">                                                     //   propA: string</div>
<div class="line">                                                     //   propB: string</div>
<div class="line">                                                     //   propC: string</div>
<div class="line">                                                     // }</div>
<div class="line"> </div>
<div class="line">// TypeBox</div>
<div class="line"> </div>
<div class="line">const K = Type.TemplateLiteral(&#39;prop${A|B|C}&#39;)       // const K: TTemplateLiteral&lt;[</div>
<div class="line">                                                     //   TLiteral&lt;&#39;prop&#39;&gt;,</div>
<div class="line">                                                     //   TUnion&lt;[</div>
<div class="line">                                                     //      TLiteral&lt;&#39;A&#39;&gt;,</div>
<div class="line">                                                     //      TLiteral&lt;&#39;B&#39;&gt;,</div>
<div class="line">                                                     //      TLiteral&lt;&#39;C&#39;&gt;,</div>
<div class="line">                                                     //   ]&gt;</div>
<div class="line">                                                     // ]&gt;</div>
<div class="line"> </div>
<div class="line">const R = Type.Record(K, Type.String())              // const R: TObject&lt;{</div>
<div class="line">                                                     //   propA: TString,</div>
<div class="line">                                                     //   propB: TString,</div>
<div class="line">                                                     //   propC: TString,</div>
<div class="line">                                                     // }&gt;</div>
</div><!-- fragment --><p><a class="anchor" id="types-indexed"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2027"></a>
Indexed Access Types</h3>
<p>TypeBox supports indexed access types with the Index function. This function enables uniform access to interior property and element types without having to extract them from the underlying schema representation. Index types are supported for Object, Array, Tuple, Union and Intersect types.</p>
<div class="fragment"><div class="line">const T = Type.Object({                              // type T = {</div>
<div class="line">  x: Type.Number(),                                  //   x: number,</div>
<div class="line">  y: Type.String(),                                  //   y: string,</div>
<div class="line">  z: Type.Boolean()                                  //   z: boolean</div>
<div class="line">})                                                   // }</div>
<div class="line"> </div>
<div class="line">const A = Type.Index(T, [&#39;x&#39;])                       // type A = T[&#39;x&#39;]</div>
<div class="line">                                                     //</div>
<div class="line">                                                     // ... evaluated as</div>
<div class="line">                                                     //</div>
<div class="line">                                                     // const A: TNumber</div>
<div class="line"> </div>
<div class="line">const B = Type.Index(T, [&#39;x&#39;, &#39;y&#39;])                  // type B = T[&#39;x&#39; | &#39;y&#39;]</div>
<div class="line">                                                     //</div>
<div class="line">                                                     // ... evaluated as</div>
<div class="line">                                                     //</div>
<div class="line">                                                     // const B: TUnion&lt;[</div>
<div class="line">                                                     //   TNumber,</div>
<div class="line">                                                     //   TString,</div>
<div class="line">                                                     // ]&gt;</div>
<div class="line"> </div>
<div class="line">const C = Type.Index(T, Type.KeyOf(T))               // type C = T[keyof T]</div>
<div class="line">                                                     //</div>
<div class="line">                                                     // ... evaluated as</div>
<div class="line">                                                     // </div>
<div class="line">                                                     // const C: TUnion&lt;[</div>
<div class="line">                                                     //   TNumber,</div>
<div class="line">                                                     //   TString,</div>
<div class="line">                                                     //   TBoolean</div>
<div class="line">                                                     // ]&gt;</div>
</div><!-- fragment --><p><a class="anchor" id="types-mapped"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2028"></a>
Mapped Types</h3>
<p>TypeBox supports mapped types with the Mapped function. This function accepts two arguments, the first is a union type typically derived from KeyOf, the second is a mapping function that receives a mapping key <span class="tt">K</span> that can be used to index properties of a type. The following implements a mapped type that remaps each property to be <span class="tt">T | null</span>.</p>
<div class="fragment"><div class="line">const T = Type.Object({                              // type T = {</div>
<div class="line">  x: Type.Number(),                                  //   x: number,</div>
<div class="line">  y: Type.String(),                                  //   y: string,</div>
<div class="line">  z: Type.Boolean()                                  //   z: boolean</div>
<div class="line">})                                                   // }</div>
<div class="line"> </div>
<div class="line">const M = Type.Mapped(Type.KeyOf(T), K =&gt; {          // type M = { [K in keyof T]: T[K] | null }</div>
<div class="line">  return Type.Union([Type.Index(T, K), Type.Null()]) //</div>
<div class="line">})                                                   // ... evaluated as</div>
<div class="line">                                                     // </div>
<div class="line">                                                     // const M: TObject&lt;{</div>
<div class="line">                                                     //   x: TUnion&lt;[TNumber, TNull]&gt;,</div>
<div class="line">                                                     //   y: TUnion&lt;[TString, TNull]&gt;,</div>
<div class="line">                                                     //   z: TUnion&lt;[TBoolean, TNull]&gt;</div>
<div class="line">                                                     // }&gt;</div>
</div><!-- fragment --><p><a class="anchor" id="types-conditional"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2029"></a>
Conditional Types</h3>
<p>TypeBox supports runtime conditional types with the Extends function. This function performs a structural assignability check against the first (<span class="tt">left</span>) and second (<span class="tt">right</span>) arguments and will return either the third (<span class="tt">true</span>) or fourth (<span class="tt">false</span>) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.</p>
<div class="fragment"><div class="line">// Extends</div>
<div class="line">const A = Type.Extends(                              // type A = string extends number ? 1 : 2</div>
<div class="line">  Type.String(),                                     //   </div>
<div class="line">  Type.Number(),                                     // ... evaluated as</div>
<div class="line">  Type.Literal(1),                                   //</div>
<div class="line">  Type.Literal(2)                                    // const A: TLiteral&lt;2&gt;</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">// Extract</div>
<div class="line">const B = Type.Extract(                              // type B = Extract&lt;1 | 2 | 3, 1&gt;</div>
<div class="line">  Type.Union([                                       //</div>
<div class="line">    Type.Literal(1),                                 // ... evaluated as</div>
<div class="line">    Type.Literal(2),                                 //</div>
<div class="line">    Type.Literal(3)                                  // const B: TLiteral&lt;1&gt;</div>
<div class="line">  ]), </div>
<div class="line">  Type.Literal(1)</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">// Exclude</div>
<div class="line">const C = Type.Exclude(                              // type C = Exclude&lt;1 | 2 | 3, 1&gt;</div>
<div class="line">  Type.Union([                                       // </div>
<div class="line">    Type.Literal(1),                                 // ... evaluated as</div>
<div class="line">    Type.Literal(2),                                 //</div>
<div class="line">    Type.Literal(3)                                  // const C: TUnion&lt;[</div>
<div class="line">  ]),                                                //   TLiteral&lt;2&gt;,</div>
<div class="line">  Type.Literal(1)                                    //   TLiteral&lt;3&gt;,</div>
<div class="line">)                                                    // ]&gt;</div>
</div><!-- fragment --><p><a class="anchor" id="types-transform"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2030"></a>
Transform Types</h3>
<p>TypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler submodules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value submodule.</p>
<div class="fragment"><div class="line">import { Value } from &#39;@sinclair/typebox/value&#39;</div>
<div class="line"> </div>
<div class="line">const T = Type.Transform(Type.Number())</div>
<div class="line">  .Decode(value =&gt; new Date(value))                  // decode: number to Date</div>
<div class="line">  .Encode(value =&gt; value.getTime())                  // encode: Date to number</div>
<div class="line"> </div>
<div class="line">const D = Value.Decode(T, 0)                         // const D = Date(1970-01-01T00:00:00.000Z)</div>
<div class="line">const E = Value.Encode(T, D)                         // const E = 0</div>
</div><!-- fragment --><p> Use the StaticEncode or StaticDecode types to infer a Transform type. </p><div class="fragment"><div class="line">import { Static, StaticDecode, StaticEncode } from &#39;@sinclair/typebox&#39;</div>
<div class="line"> </div>
<div class="line">const T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         </div>
<div class="line">  .Decode(value =&gt; new Set(value))</div>
<div class="line">  .Encode(value =&gt; [...value])</div>
<div class="line"> </div>
<div class="line">type D = StaticDecode&lt;typeof T&gt;                      // type D = Set&lt;number&gt;      </div>
<div class="line">type E = StaticEncode&lt;typeof T&gt;                      // type E = Array&lt;number&gt;</div>
<div class="line">type T = Static&lt;typeof T&gt;                            // type T = Array&lt;number&gt;</div>
</div><!-- fragment --><p><a class="anchor" id="types-unsafe"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2031"></a>
Unsafe Types</h3>
<p>TypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.</p>
<div class="fragment"><div class="line">const T = Type.Unsafe&lt;string&gt;({ type: &#39;number&#39; })    // const T = { type: &#39;number&#39; }</div>
<div class="line"> </div>
<div class="line">type T = Static&lt;typeof T&gt;                            // type T = string - ?</div>
</div><!-- fragment --><p> The Unsafe type is often used to create schematics for extended specifications like OpenAPI. </p><div class="fragment"><div class="line">const Nullable = &lt;T extends TSchema&gt;(schema: T) =&gt; Type.Unsafe&lt;Static&lt;T&gt; | null&gt;({ </div>
<div class="line">  ...schema, nullable: true </div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">const T = Nullable(Type.String())                    // const T = {</div>
<div class="line">                                                     //   type: &#39;string&#39;,</div>
<div class="line">                                                     //   nullable: true</div>
<div class="line">                                                     // }</div>
<div class="line"> </div>
<div class="line">type T = Static&lt;typeof T&gt;                            // type T = string | null</div>
<div class="line"> </div>
<div class="line">const StringEnum = &lt;T extends string[]&gt;(values: [...T]) =&gt; Type.Unsafe&lt;T[number]&gt;({ </div>
<div class="line">  type: &#39;string&#39;, enum: values </div>
<div class="line">})</div>
<div class="line">const S = StringEnum([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])                // const S = {</div>
<div class="line">                                                     //   enum: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</div>
<div class="line">                                                     // }</div>
<div class="line"> </div>
<div class="line">type S = Static&lt;typeof T&gt;                            // type S = &#39;A&#39; | &#39;B&#39; | &#39;C&#39;</div>
</div><!-- fragment --><p> <a class="anchor" id="types-guard"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2032"></a>
TypeGuard</h3>
<p>TypeBox can check its own types with the TypeGuard module. This module is written for type introspection and provides structural tests for every built-in TypeBox type. Functions of this module return <span class="tt">is</span> guards which can be used with control flow assertions to obtain schema inference for unknown values. The following guards that the value <span class="tt">T</span> is TString.</p>
<div class="fragment"><div class="line">import { TypeGuard, Kind } from &#39;@sinclair/typebox&#39;</div>
<div class="line"> </div>
<div class="line">const T = { [Kind]: &#39;String&#39;, type: &#39;string&#39; }</div>
<div class="line"> </div>
<div class="line">if(TypeGuard.IsString(T)) {</div>
<div class="line"> </div>
<div class="line">  // T is TString</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="values"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2033"></a>
Values</h2>
<p>TypeBox provides an optional Value submodule that can be used to perform structural operations on JavaScript values. This submodule includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This submodule is provided via optional import.</p>
<div class="fragment"><div class="line">import { Value } from &#39;@sinclair/typebox/value&#39;</div>
</div><!-- fragment --><p><a class="anchor" id="values-assert"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2034"></a>
Assert</h3>
<p>Use the Assert function to assert a value is valid.</p>
<div class="fragment"><div class="line">let value: unknown = 1</div>
<div class="line"> </div>
<div class="line">Value.Assert(Type.Number(), value)                   // throws AssertError if invalid</div>
</div><!-- fragment --><p><a class="anchor" id="values-create"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2035"></a>
Create</h3>
<p>Use the Create function to create a value from a type. TypeBox will use default values if specified.</p>
<div class="fragment"><div class="line">const T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })</div>
<div class="line"> </div>
<div class="line">const A = Value.Create(T)                            // const A = { x: 0, y: 42 }</div>
</div><!-- fragment --><p><a class="anchor" id="values-clone"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2036"></a>
Clone</h3>
<p>Use the Clone function to deeply clone a value.</p>
<div class="fragment"><div class="line">const A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }</div>
</div><!-- fragment --><p><a class="anchor" id="values-check"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2037"></a>
Check</h3>
<p>Use the Check function to type check a value.</p>
<div class="fragment"><div class="line">const T = Type.Object({ x: Type.Number() })</div>
<div class="line"> </div>
<div class="line">const R = Value.Check(T, { x: 1 })                   // const R = true</div>
</div><!-- fragment --><p><a class="anchor" id="values-convert"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2038"></a>
Convert</h3>
<p>Use the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is <span class="tt">unknown</span>.</p>
<div class="fragment"><div class="line">const T = Type.Object({ x: Type.Number() })</div>
<div class="line"> </div>
<div class="line">const R1 = Value.Convert(T, { x: &#39;3.14&#39; })           // const R1 = { x: 3.14 }</div>
<div class="line"> </div>
<div class="line">const R2 = Value.Convert(T, { x: &#39;not a number&#39; })   // const R2 = { x: &#39;not a number&#39; }</div>
</div><!-- fragment --><p><a class="anchor" id="values-clean"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2039"></a>
Clean</h3>
<p>Use Clean to remove excess properties from a value. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.</p>
<div class="fragment"><div class="line">const T = Type.Object({ </div>
<div class="line">  x: Type.Number(), </div>
<div class="line">  y: Type.Number() </div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">const X = Value.Clean(T, null)                        // const &#39;X = null</div>
<div class="line"> </div>
<div class="line">const Y = Value.Clean(T, { x: 1 })                    // const &#39;Y = { x: 1 }</div>
<div class="line"> </div>
<div class="line">const Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const &#39;Z = { x: 1, y: 2 }</div>
</div><!-- fragment --><p><a class="anchor" id="values-default"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2040"></a>
Default</h3>
<p>Use Default to generate missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.</p>
<div class="fragment"><div class="line">const T = Type.Object({ </div>
<div class="line">  x: Type.Number({ default: 0 }), </div>
<div class="line">  y: Type.Number({ default: 0 })</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">const X = Value.Default(T, null)                        // const &#39;X = null - non-enumerable</div>
<div class="line"> </div>
<div class="line">const Y = Value.Default(T, { })                         // const &#39;Y = { x: 0, y: 0 }</div>
<div class="line"> </div>
<div class="line">const Z = Value.Default(T, { x: 1 })                    // const &#39;Z = { x: 1, y: 0 }</div>
</div><!-- fragment --><p><a class="anchor" id="values-cast"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2041"></a>
Cast</h3>
<p>Use the Cast function to upcast a value into a target type. This function will retain as much information as possible from the original value. The Cast function is intended to be used in data migration scenarios where existing values need to be upgraded to match a modified type.</p>
<div class="fragment"><div class="line">const T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })</div>
<div class="line"> </div>
<div class="line">const X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }</div>
<div class="line"> </div>
<div class="line">const Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }</div>
<div class="line"> </div>
<div class="line">const Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }</div>
</div><!-- fragment --><p><a class="anchor" id="values-decode"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2042"></a>
Decode</h3>
<p>Use the Decode function to decode a value from a type or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.</p>
<div class="fragment"><div class="line">const A = Value.Decode(Type.String(), &#39;hello&#39;)        // const A = &#39;hello&#39;</div>
<div class="line"> </div>
<div class="line">const B = Value.Decode(Type.String(), 42)             // throw</div>
</div><!-- fragment --><p> <a class="anchor" id="values-decode"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2043"></a>
Encode</h3>
<p>Use the Encode function to encode a value to a type or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.</p>
<div class="fragment"><div class="line">const A = Value.Encode(Type.String(), &#39;hello&#39;)        // const A = &#39;hello&#39;</div>
<div class="line"> </div>
<div class="line">const B = Value.Encode(Type.String(), 42)             // throw</div>
</div><!-- fragment --><p><a class="anchor" id="values-parse"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2044"></a>
Parse</h3>
<p>Use the Parse function to parse a value. This function calls the <span class="tt">Clone</span> <span class="tt">Clean</span>, <span class="tt">Default</span>, <span class="tt">Convert</span>, <span class="tt">Assert</span> and <span class="tt">Decode</span> Value functions in this exact order to process a value.</p>
<div class="fragment"><div class="line">const R = Value.Parse(Type.String(), &#39;hello&#39;)      // const R: string = &quot;hello&quot;</div>
<div class="line"> </div>
<div class="line">const E = Value.Parse(Type.String(), undefined)    // throws AssertError </div>
</div><!-- fragment --><p>You can override the order in which functions are run, or omit functions entirely using the following.</p>
<div class="fragment"><div class="line">// Runs no functions.</div>
<div class="line"> </div>
<div class="line">const R = Value.Parse([], Type.String(), 12345)</div>
<div class="line"> </div>
<div class="line">// Runs the Assert() function.</div>
<div class="line"> </div>
<div class="line">const E = Value.Parse([&#39;Assert&#39;], Type.String(), 12345)</div>
<div class="line"> </div>
<div class="line">// Runs the Convert() function followed by the Assert() function.</div>
<div class="line"> </div>
<div class="line">const S = Value.Parse([&#39;Convert&#39;, &#39;Assert&#39;], Type.String(), 12345)</div>
</div><!-- fragment --><p><a class="anchor" id="values-equal"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2045"></a>
Equal</h3>
<p>Use the Equal function to deeply check for value equality.</p>
<div class="fragment"><div class="line">const R = Value.Equal(                               // const R = true</div>
<div class="line">  { x: 1, y: 2, z: 3 },</div>
<div class="line">  { x: 1, y: 2, z: 3 }</div>
<div class="line">)</div>
</div><!-- fragment --><p><a class="anchor" id="values-hash"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2046"></a>
Hash</h3>
<p>Use the Hash function to create a <a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV1A-64</a> non-cryptographic hash of a value.</p>
<div class="fragment"><div class="line">const A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n</div>
<div class="line"> </div>
<div class="line">const B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n</div>
</div><!-- fragment --><p><a class="anchor" id="values-diff"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2047"></a>
Diff</h3>
<p>Use the Diff function to generate a sequence of edits that will transform one value into another.</p>
<div class="fragment"><div class="line">const E = Value.Diff(                                // const E = [</div>
<div class="line">  { x: 1, y: 2, z: 3 },                              //   { type: &#39;update&#39;, path: &#39;/y&#39;, value: 4 },</div>
<div class="line">  { y: 4, z: 5, w: 6 }                               //   { type: &#39;update&#39;, path: &#39;/z&#39;, value: 5 },</div>
<div class="line">)                                                    //   { type: &#39;insert&#39;, path: &#39;/w&#39;, value: 6 },</div>
<div class="line">                                                     //   { type: &#39;delete&#39;, path: &#39;/x&#39; }</div>
<div class="line">                                                     // ]</div>
</div><!-- fragment --><p><a class="anchor" id="values-patch"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2048"></a>
Patch</h3>
<p>Use the Patch function to apply a sequence of edits.</p>
<div class="fragment"><div class="line">const A = { x: 1, y: 2 }</div>
<div class="line"> </div>
<div class="line">const B = { x: 3 }</div>
<div class="line"> </div>
<div class="line">const E = Value.Diff(A, B)                           // const E = [</div>
<div class="line">                                                     //   { type: &#39;update&#39;, path: &#39;/x&#39;, value: 3 },</div>
<div class="line">                                                     //   { type: &#39;delete&#39;, path: &#39;/y&#39; }</div>
<div class="line">                                                     // ]</div>
<div class="line"> </div>
<div class="line">const C = Value.Patch&lt;typeof B&gt;(A, E)                // const C = { x: 3 }</div>
</div><!-- fragment --><p><a class="anchor" id="values-errors"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2049"></a>
Errors</h3>
<p>Use the Errors function to enumerate validation errors.</p>
<div class="fragment"><div class="line">const T = Type.Object({ x: Type.Number(), y: Type.Number() })</div>
<div class="line"> </div>
<div class="line">const R = [...Value.Errors(T, { x: &#39;42&#39; })]          // const R = [{</div>
<div class="line">                                                     //   schema: { type: &#39;number&#39; },</div>
<div class="line">                                                     //   path: &#39;/x&#39;,</div>
<div class="line">                                                     //   value: &#39;42&#39;,</div>
<div class="line">                                                     //   message: &#39;Expected number&#39;</div>
<div class="line">                                                     // }, {</div>
<div class="line">                                                     //   schema: { type: &#39;number&#39; },</div>
<div class="line">                                                     //   path: &#39;/y&#39;,</div>
<div class="line">                                                     //   value: undefined,</div>
<div class="line">                                                     //   message: &#39;Expected number&#39;</div>
<div class="line">                                                     // }]</div>
</div><!-- fragment --><p><a class="anchor" id="values-mutate"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2050"></a>
Mutate</h3>
<p>Use the Mutate function to perform a deep mutable value assignment while retaining internal references.</p>
<div class="fragment"><div class="line">const Y = { z: 1 }                                   // const Y = { z: 1 }</div>
<div class="line">const X = { y: Y }                                   // const X = { y: { z: 1 } }</div>
<div class="line">const A = { x: X }                                   // const A = { x: { y: { z: 1 } } }</div>
<div class="line"> </div>
<div class="line">Value.Mutate(A, { x: { y: { z: 2 } } })              // A&#39; = { x: { y: { z: 2 } } }</div>
<div class="line"> </div>
<div class="line">const R0 = A.x.y.z === 2                             // const R0 = true</div>
<div class="line">const R1 = A.x.y === Y                               // const R1 = true</div>
<div class="line">const R2 = A.x === X                                 // const R2 = true</div>
</div><!-- fragment --><p><a class="anchor" id="values-pointer"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2051"></a>
Pointer</h3>
<p>Use ValuePointer to perform mutable updates on existing values using <a href="https://www.rfc-editor.org/rfc/rfc6901">RFC6901</a> Json Pointers.</p>
<div class="fragment"><div class="line">import { ValuePointer } from &#39;@sinclair/typebox/value&#39;</div>
<div class="line"> </div>
<div class="line">const A = { x: 0, y: 0, z: 0 }</div>
<div class="line"> </div>
<div class="line">ValuePointer.Set(A, &#39;/x&#39;, 1)                         // A&#39; = { x: 1, y: 0, z: 0 }</div>
<div class="line">ValuePointer.Set(A, &#39;/y&#39;, 1)                         // A&#39; = { x: 1, y: 1, z: 0 }</div>
<div class="line">ValuePointer.Set(A, &#39;/z&#39;, 1)                         // A&#39; = { x: 1, y: 1, z: 1 }</div>
</div><!-- fragment --><p><a class="anchor" id="syntax"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2052"></a>
Syntax Types</h2>
<p>TypeBox provides experimental support for parsing TypeScript annotation syntax into TypeBox types.</p>
<p>This feature is provided via optional import.</p>
<div class="fragment"><div class="line">import { Syntax } from &#39;@sinclair/typebox/syntax&#39;</div>
</div><!-- fragment --><p><a class="anchor" id="syntax-create"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2053"></a>
Create</h3>
<p>Use the Syntax function to create TypeBox types from TypeScript syntax (<a href="https://www.typescriptlang.org/play/?moduleResolution=99&amp;module=199&amp;ts=5.8.0-beta#code/JYWwDg9gTgLgBAbzgZQJ4DsYEMAecC+cAZlBCHAOQACAzsOgMYA2WwUA9DKmAKYBGEHOxoZsOCgChQkWIhTYYwBgWKly1OoxZtO3foMkSGEdDXgAVOAF4Uo3AAoABkhwAuOOgCuIPjygAaOFR3Lx8-AkcASjgY2Jj2djhjUwt3cwB5PgArHgYYAB4ECTiS0rLyisrYhNi3OHMAOW9fAOKq9o7OuBqY4PqmsKg2rpHR+MT8AD4JCS5eeut5LEUGfLmeCCJ6ybHKmvWFmyLdk86euDrQlv9h07uy876rv1v7t-GCIA">Example</a>)</p>
<div class="fragment"><div class="line">const T = Syntax(`{ x: number, y: number }`)        // const T: TObject&lt;{</div>
<div class="line">                                                    //   x: TNumber,</div>
<div class="line">                                                    //   y: TNumber</div>
<div class="line">                                                    // }&gt;</div>
<div class="line"> </div>
<div class="line">type T = Static&lt;typeof T&gt;                            // type T = {</div>
<div class="line">                                                     //   x: number,</div>
<div class="line">                                                     //   y: number</div>
<div class="line">                                                     // }</div>
</div><!-- fragment --><p><a class="anchor" id="syntax-parameters"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2054"></a>
Parameters</h3>
<p>Syntax types can be parameterized to receive exterior types (<a href="https://www.typescriptlang.org/play/?moduleResolution=99&amp;module=199&amp;ts=5.8.0-beta#code/JYWwDg9gTgLgBAbzgZQJ4DsYEMAecC+cAZlBCHAOQACAzsOgMYA2WwUA9DKmAKYBGEHOxoZsOCgCgJDCOhrwAKnAC8KUbgAUAAyQ4AXHHQBXEHx5QANHFQHjp8wS0BKOK7ev27ODLmKDCgHk+ACseBhgAHgQJd1i4+ITEpLdPN304BQA5EzNLGOSCwqK4VNcbDOz7KHzi2rqPL3wAPikfeRQVNUxNJCV8Ky0ABSxYYCwmCIUm52LUtvhkfyDQ8Kia+o2C0rh0wLAYYFlxycrcpot1zav47fK9g6OJrJzzFuv3m8amoA">Example</a>)</p>
<div class="fragment"><div class="line">const T = Syntax(`{ x: number, y: number }`)        // const T: TObject&lt;{</div>
<div class="line">                                                    //   x: TNumber,</div>
<div class="line">                                                    //   y: TNumber</div>
<div class="line">                                                    // }&gt;</div>
<div class="line"> </div>
<div class="line">const S = Syntax({ T }, `Partial&lt;T&gt;`)               // const S: TObject&lt;{</div>
<div class="line">                                                    //   x: TOptional&lt;TNumber&gt;,</div>
<div class="line">                                                    //   y: TOptional&lt;TNumber&gt;</div>
<div class="line">                                                    // }&gt;</div>
</div><!-- fragment --><p><a class="anchor" id="syntax-generics"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2055"></a>
Generics</h3>
<p>Syntax types support generic parameters in the following way (<a href="https://www.typescriptlang.org/play/?moduleResolution=99&amp;module=199&amp;ts=5.8.0-beta#code/JYWwDg9gTgLgBAbzgZQJ4DsYEMAecC+cAZlBCHAOQACAzsOgMYA2WwUA9DKmAKYBGEHOxoZsOCgChQkWIhTYYwBgWKly1OoxZtO3foMkSGEdDXgA1HgxjQ4AXhSjcACgAGAHgAaAGjgBNXwAtAD45CTg4HAAuOB84cLhUGID4iIAvGMD4-FcASgkjEzM4ACEsOhpLa2gae0dMFyQqmygCX1cEBOi4Zuh3AEZfAAZh4O8EpJ6rFvcRuEG4IbGEjKnqqFnh337lnPyJLl5S8uBK6Zq65AUld0OeCCJjit6oGlCIiPZ2ODun05fag5Oh8QaCweCIZCoV8Pt0kN0FpM5qshm0ElCMZisSCYRFJvCYnNJgsUWjseSKeDcXBVgTFr4kb5Vv0COjKezsTD8EA">Example</a>)</p>
<div class="fragment"><div class="line">const Vector = Syntax(`&lt;X, Y, Z&gt; { </div>
<div class="line">  x: X, </div>
<div class="line">  y: Y, </div>
<div class="line">  z: Z </div>
<div class="line">}`)</div>
<div class="line"> </div>
<div class="line">const BasisVectors = Syntax({ Vector }, `{</div>
<div class="line">  x: Vector&lt;1, 0, 0&gt;,</div>
<div class="line">  y: Vector&lt;0, 1, 0&gt;,</div>
<div class="line">  z: Vector&lt;0, 0, 1&gt;,</div>
<div class="line">}`)</div>
<div class="line"> </div>
<div class="line">type BasisVectors = Static&lt;typeof BasisVectors&gt;     // type BasisVectors = {</div>
<div class="line">                                                    //   x: { x: 1, y: 0, z: 0 },</div>
<div class="line">                                                    //   y: { x: 0, y: 1, z: 0 },</div>
<div class="line">                                                    //   z: { x: 0, y: 0, z: 1 }</div>
<div class="line">                                                    // }</div>
</div><!-- fragment --><p><a class="anchor" id="syntax-options"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2056"></a>
Options</h3>
<p>Options can be passed via the last parameter.</p>
<div class="fragment"><div class="line">const T = Syntax(`number`, { minimum: 42 })       // const T = {</div>
<div class="line">                                                  //   type: &#39;number&#39;,</div>
<div class="line">                                                  //   minimum: 42</div>
<div class="line">                                                  // }</div>
</div><!-- fragment --><p><a class="anchor" id="syntax-no-infer"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2057"></a>
NoInfer</h3>
<p>Syntax parsing is an expensive type level operation and can impact on language service performance. Use the NoInfer function parse syntax at runtime only.</p>
<div class="fragment"><div class="line">import { NoInfer } from &#39;@sinclair/typebox/syntax&#39;</div>
<div class="line"> </div>
<div class="line">const T = NoInfer(`number | string`)                // const T: TSchema = {</div>
<div class="line">                                                    //   anyOf: [</div>
<div class="line">                                                    //     { type: &#39;number&#39; },</div>
<div class="line">                                                    //     { type: &#39;string&#39; }</div>
<div class="line">                                                    //   ]</div>
<div class="line">                                                    // }</div>
</div><!-- fragment --><p><a class="anchor" id="typeregistry"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2058"></a>
TypeRegistry</h2>
<p>The TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.</p>
<p><a class="anchor" id="typeregistry-type"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2059"></a>
TypeRegistry</h3>
<p>Use the TypeRegistry to register a type. The Kind must match the registered type name.</p>
<div class="fragment"><div class="line">import { TSchema, Kind, TypeRegistry } from &#39;@sinclair/typebox&#39;</div>
<div class="line"> </div>
<div class="line">TypeRegistry.Set(&#39;Foo&#39;, (schema, value) =&gt; value === &#39;foo&#39;)</div>
<div class="line"> </div>
<div class="line">const Foo = { [Kind]: &#39;Foo&#39; } as TSchema </div>
<div class="line"> </div>
<div class="line">const A = Value.Check(Foo, &#39;foo&#39;)                    // const A = true</div>
<div class="line"> </div>
<div class="line">const B = Value.Check(Foo, &#39;bar&#39;)                    // const B = false</div>
</div><!-- fragment --><p><a class="anchor" id="typeregistry-format"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2060"></a>
FormatRegistry</h3>
<p>Use the FormatRegistry to register a string format.</p>
<div class="fragment"><div class="line">import { FormatRegistry } from &#39;@sinclair/typebox&#39;</div>
<div class="line"> </div>
<div class="line">FormatRegistry.Set(&#39;foo&#39;, (value) =&gt; value === &#39;foo&#39;)</div>
<div class="line"> </div>
<div class="line">const T = Type.String({ format: &#39;foo&#39; })</div>
<div class="line"> </div>
<div class="line">const A = Value.Check(T, &#39;foo&#39;)                      // const A = true</div>
<div class="line"> </div>
<div class="line">const B = Value.Check(T, &#39;bar&#39;)                      // const B = false</div>
</div><!-- fragment --><p><a class="anchor" id="typecheck"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2061"></a>
TypeCheck</h2>
<p>TypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built-in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.</p>
<p>The following sections detail using Ajv and the TypeBox compiler infrastructure.</p>
<p><a class="anchor" id="typecheck-ajv"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2062"></a>
Ajv</h2>
<p>The following shows the recommended setup for Ajv.</p>
<div class="fragment"><div class="line">$ npm install ajv ajv-formats --save</div>
</div><!-- fragment --><div class="fragment"><div class="line">import { Type }   from &#39;@sinclair/typebox&#39;</div>
<div class="line">import addFormats from &#39;ajv-formats&#39;</div>
<div class="line">import Ajv        from &#39;ajv&#39;</div>
<div class="line"> </div>
<div class="line">const ajv = addFormats(new Ajv({}), [</div>
<div class="line">  &#39;date-time&#39;,</div>
<div class="line">  &#39;time&#39;,</div>
<div class="line">  &#39;date&#39;,</div>
<div class="line">  &#39;email&#39;,</div>
<div class="line">  &#39;hostname&#39;,</div>
<div class="line">  &#39;ipv4&#39;,</div>
<div class="line">  &#39;ipv6&#39;,</div>
<div class="line">  &#39;uri&#39;,</div>
<div class="line">  &#39;uri-reference&#39;,</div>
<div class="line">  &#39;uuid&#39;,</div>
<div class="line">  &#39;uri-template&#39;,</div>
<div class="line">  &#39;json-pointer&#39;,</div>
<div class="line">  &#39;relative-json-pointer&#39;,</div>
<div class="line">  &#39;regex&#39;</div>
<div class="line">])</div>
<div class="line"> </div>
<div class="line">const validate = ajv.compile(Type.Object({</div>
<div class="line">  x: Type.Number(),</div>
<div class="line">  y: Type.Number(),</div>
<div class="line">  z: Type.Number()</div>
<div class="line">}))</div>
<div class="line"> </div>
<div class="line">const R = validate({ x: 1, y: 2, z: 3 })             // const R = true</div>
</div><!-- fragment --><p><a class="anchor" id="typecheck-typecompiler"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2063"></a>
TypeCompiler</h3>
<p>The TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.</p>
<p>The TypeCompiler is provided as an optional import.</p>
<div class="fragment"><div class="line">import { TypeCompiler } from &#39;@sinclair/typebox/compiler&#39;</div>
</div><!-- fragment --><p>Use the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.</p>
<div class="fragment"><div class="line">const C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck&lt;TObject&lt;{</div>
<div class="line">  x: Type.Number(),                                  //     x: TNumber;</div>
<div class="line">  y: Type.Number(),                                  //     y: TNumber;</div>
<div class="line">  z: Type.Number()                                   //     z: TNumber;</div>
<div class="line">}))                                                  // }&gt;&gt;</div>
<div class="line"> </div>
<div class="line">const R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true</div>
</div><!-- fragment --><p>Use the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.</p>
<div class="fragment"><div class="line">const C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck&lt;TObject&lt;{</div>
<div class="line">  x: Type.Number(),                                  //     x: TNumber;</div>
<div class="line">  y: Type.Number(),                                  //     y: TNumber;</div>
<div class="line">  z: Type.Number()                                   //     z: TNumber;</div>
<div class="line">}))                                                  // }&gt;&gt;</div>
<div class="line"> </div>
<div class="line">const value = { }</div>
<div class="line"> </div>
<div class="line">const first = C.Errors(value).First()                // const first = {</div>
<div class="line">                                                     //   schema: { type: &#39;number&#39; },</div>
<div class="line">                                                     //   path: &#39;/x&#39;,</div>
<div class="line">                                                     //   value: undefined,</div>
<div class="line">                                                     //   message: &#39;Expected number&#39;</div>
<div class="line">                                                     // }</div>
<div class="line"> </div>
<div class="line">const all = [...C.Errors(value)]                     // const all = [{</div>
<div class="line">                                                     //   schema: { type: &#39;number&#39; },</div>
<div class="line">                                                     //   path: &#39;/x&#39;,</div>
<div class="line">                                                     //   value: undefined,</div>
<div class="line">                                                     //   message: &#39;Expected number&#39;</div>
<div class="line">                                                     // }, {</div>
<div class="line">                                                     //   schema: { type: &#39;number&#39; },</div>
<div class="line">                                                     //   path: &#39;/y&#39;,</div>
<div class="line">                                                     //   value: undefined,</div>
<div class="line">                                                     //   message: &#39;Expected number&#39;</div>
<div class="line">                                                     // }, {</div>
<div class="line">                                                     //   schema: { type: &#39;number&#39; },</div>
<div class="line">                                                     //   path: &#39;/z&#39;,</div>
<div class="line">                                                     //   value: undefined,</div>
<div class="line">                                                     //   message: &#39;Expected number&#39;</div>
<div class="line">                                                     // }]</div>
</div><!-- fragment --><p>Use the Code function to generate assertion functions as strings. This function can be used to generate code that can be written to disk as importable modules. This technique is sometimes referred to as Ahead of Time (AOT) compilation. The following generates code to check a string.</p>
<div class="fragment"><div class="line">const C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {</div>
<div class="line">                                                     //   return (</div>
<div class="line">                                                     //     (typeof value === &#39;string&#39;)</div>
<div class="line">                                                     //   )</div>
<div class="line">                                                     // }`</div>
</div><!-- fragment --><p><a class="anchor" id="typemap"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2064"></a>
TypeMap</h2>
<p>TypeBox offers an external package for bidirectional mapping between TypeBox, Valibot, and Zod type libraries. It also includes syntax parsing support for Valibot and Zod and supports the Standard Schema specification. For more details on TypeMap, refer to the project repository.</p>
<p><a href="https://github.com/sinclairzx81/typemap">TypeMap Repository</a></p>
<p><a class="anchor" id="typemap-usage"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2065"></a>
Usage</h3>
<p>TypeMap needs to be installed separately</p>
<div class="fragment"><div class="line">$ npm install @sinclair/typemap</div>
</div><!-- fragment --><p>Once installed it offers advanced structural remapping between various runtime type libraries (<a href="https://www.typescriptlang.org/play/?moduleResolution=99&amp;module=199&amp;ts=5.8.0-beta#code/JYWwDg9gTgLgBAbzgFQJ5gKYCEIA8A0cAyqgHYwCGBcAWhACZwC+cAZlBCHAOQACAzsFIBjADYVgUAPQx0GEBTDcAUMuERS-eMjgBeFHJy4AFAAMkuAFxxSAVxAAjDFEKprdx88IAvd-adQzKYAlHBwUlJw6pra1sgA8g4AVhjCMAA8CMphObl5+QWFRcW5ETlWKABy-s4A3NkljU3NBWVhblU1UPUtvX3FbXC+nZ7dDf0TE2VMAHyq0VrEesRklCbIoS1lC-BE1twWfqOuRwE+p87MKmoaiwBKy3T0xkTBAHRgFFD8GMZ2oqJNnltrd4HdrFlJltImEKh4Aj0oU1Bh14XVxkiBjChhcxpjGtMwkA">Example</a>)</p>
<div class="fragment"><div class="line">import { TypeBox, Syntax, Zod } from &#39;@sinclair/typemap&#39;</div>
<div class="line"> </div>
<div class="line">const T = TypeBox(`{ x: number, y: number, z: number }`)  // const T: TObject&lt;{</div>
<div class="line">                                                          //   x: TNumber;</div>
<div class="line">                                                          //   y: TNumber;</div>
<div class="line">                                                          //   z: TNumber;</div>
<div class="line">                                                          // }&gt;</div>
<div class="line"> </div>
<div class="line">const S = Syntax(T)                // const S: &#39;{ x: number, y: number, z: number }&#39;</div>
<div class="line"> </div>
<div class="line">const R = Zod(S).parse(null)       // const R: {</div>
<div class="line">                                   //   x: number;</div>
<div class="line">                                   //   y: number;</div>
<div class="line">                                   //   z: number;</div>
<div class="line">                                   // }                    </div>
</div><!-- fragment --><p><a class="anchor" id="typesystem"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2066"></a>
TypeSystem</h2>
<p>The TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.</p>
<p><a class="anchor" id="typesystem-policies"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2067"></a>
Policies</h3>
<p>TypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox assert values inline with TypeScript static checks. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be helpful in Json based protocols such as Json Rpc 2.0.</p>
<p>The following overrides are available.</p>
<div class="fragment"><div class="line">import { TypeSystemPolicy } from &#39;@sinclair/typebox/system&#39;</div>
<div class="line"> </div>
<div class="line">// Disallow undefined values for optional properties (default is false)</div>
<div class="line">//</div>
<div class="line">// const A: { x?: number } = { x: undefined } - disallowed when enabled</div>
<div class="line"> </div>
<div class="line">TypeSystemPolicy.ExactOptionalPropertyTypes = true</div>
<div class="line"> </div>
<div class="line">// Allow arrays to validate as object types (default is false)</div>
<div class="line">//</div>
<div class="line">// const A: {} = [] - allowed in TS</div>
<div class="line"> </div>
<div class="line">TypeSystemPolicy.AllowArrayObject = true</div>
<div class="line"> </div>
<div class="line">// Allow numeric values to be NaN or + or - Infinity (default is false)</div>
<div class="line">//</div>
<div class="line">// const A: number = NaN - allowed in TS</div>
<div class="line"> </div>
<div class="line">TypeSystemPolicy.AllowNaN = true</div>
<div class="line"> </div>
<div class="line">// Allow void types to check with undefined and null (default is false)</div>
<div class="line">//</div>
<div class="line">// Used to signal void return on Json-Rpc 2.0 protocol</div>
<div class="line"> </div>
<div class="line">TypeSystemPolicy.AllowNullVoid = true</div>
</div><!-- fragment --><p><a class="anchor" id="error-function"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2068"></a>
Error Function</h2>
<p>Error messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the <span class="tt">en-US</span> locale. To support additional locales, you can replicate the function found in <span class="tt">src/errors/function.ts</span> and create a locale specific translation. The function can then be set via SetErrorFunction.</p>
<p>The following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.</p>
<div class="fragment"><div class="line">import { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from &#39;@sinclair/typebox/errors&#39;</div>
<div class="line"> </div>
<div class="line">SetErrorFunction((error) =&gt; { // i18n override</div>
<div class="line">  switch(error.errorType) {</div>
<div class="line">    /* en-US */ case ValueErrorType.String: return &#39;Expected string&#39;</div>
<div class="line">    /* fr-FR */ case ValueErrorType.Number: return &#39;Nombre attendu&#39;  </div>
<div class="line">    /* ko-KR */ case ValueErrorType.Boolean: return &#39;예상 부울&#39;      </div>
<div class="line">    /* en-US */ default: return DefaultErrorFunction(error)          </div>
<div class="line">  }</div>
<div class="line">})</div>
<div class="line">const T = Type.Object({                              // const T: TObject&lt;{</div>
<div class="line">  x: Type.String(),                                  //  TString,</div>
<div class="line">  y: Type.Number(),                                  //  TNumber,</div>
<div class="line">  z: Type.Boolean()                                  //  TBoolean</div>
<div class="line">})                                                   // }&gt;</div>
<div class="line"> </div>
<div class="line">const E = [...Value.Errors(T, {                      // const E = [{</div>
<div class="line">  x: null,                                           //   type: 48,</div>
<div class="line">  y: null,                                           //   schema: { ... },</div>
<div class="line">  z: null                                            //   path: &#39;/x&#39;,</div>
<div class="line">})]                                                  //   value: null,</div>
<div class="line">                                                     //   message: &#39;Expected string&#39;</div>
<div class="line">                                                     // }, {</div>
<div class="line">                                                     //   type: 34,</div>
<div class="line">                                                     //   schema: { ... },</div>
<div class="line">                                                     //   path: &#39;/y&#39;,</div>
<div class="line">                                                     //   value: null,</div>
<div class="line">                                                     //   message: &#39;Nombre attendu&#39;</div>
<div class="line">                                                     // }, {</div>
<div class="line">                                                     //   type: 14,</div>
<div class="line">                                                     //   schema: { ... },</div>
<div class="line">                                                     //   path: &#39;/z&#39;,</div>
<div class="line">                                                     //   value: null,</div>
<div class="line">                                                     //   message: &#39;예상 부울&#39;</div>
<div class="line">                                                     // }]</div>
</div><!-- fragment --><p><a class="anchor" id="workbench"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2069"></a>
TypeBox Workbench</h2>
<p>TypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.</p>
<p><a href="https://sinclairzx81.github.io/typebox-workbench/">TypeBox Workbench Link Here</a></p>
<p><a class="anchor" id="codegen"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2070"></a>
TypeBox Codegen</h2>
<p>TypeBox provides a code generation library that can be integrated into toolchains to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.</p>
<p><a href="https://github.com/sinclairzx81/typebox-codegen">TypeBox Codegen Link Here</a></p>
<p><a class="anchor" id="ecosystem"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2071"></a>
Ecosystem</h2>
<p>The following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Package  </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://www.npmjs.com/package/drizzle-typebox">drizzle-typebox</a>  </td><td class="markdownTableBodyNone">Generates TypeBox types from Drizzle ORM schemas  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/elysiajs/elysia">elysia</a>  </td><td class="markdownTableBodyNone">Fast and friendly Bun web framework  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/fastify/fastify-type-provider-typebox">fastify-type-provider-typebox</a>  </td><td class="markdownTableBodyNone">Fastify TypeBox integration with the Fastify Type Provider  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/feathersjs/feathers">feathersjs</a>  </td><td class="markdownTableBodyNone">The API and real-time application framework  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/erfanium/fetch-typebox">fetch-typebox</a>  </td><td class="markdownTableBodyNone">Drop-in replacement for fetch that brings easy integration with TypeBox  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/Lonli-Lokli/fetcher-ts/tree/master/packages/fetcher-typebox">@lonli-lokli/fetcher-typebox</a>  </td><td class="markdownTableBodyNone">A strongly-typed fetch wrapper for TypeScript applications with optional runtime validation using TypeBox  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/kevinmarrec/h3-typebox">h3-typebox</a>  </td><td class="markdownTableBodyNone">Schema validation utilities for h3 using TypeBox &amp; Ajv  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/flodlc/http-wizard">http-wizard</a>  </td><td class="markdownTableBodyNone">Type safe http client library for Fastify  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/hacxy/json2typebox">json2typebox</a>  </td><td class="markdownTableBodyNone">Creating TypeBox code from Json Data  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/Coder-Spirit/nominal/tree/main/%40coderspirit/nominal-typebox">nominal-typebox</a>  </td><td class="markdownTableBodyNone">Allows devs to integrate nominal types into TypeBox schemas  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/geut/openapi-box">openapi-box</a>  </td><td class="markdownTableBodyNone">Generate TypeBox types from OpenApi IDL + Http client library  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/m1212e/prismabox">prismabox</a>  </td><td class="markdownTableBodyNone">Converts a prisma.schema to TypeBox schema matching the database models  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/xddq/schema2typebox">schema2typebox</a>  </td><td class="markdownTableBodyNone">Creating TypeBox code from Json Schemas  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/ciscoheat/sveltekit-superforms">sveltekit-superforms</a>  </td><td class="markdownTableBodyNone">A comprehensive SvelteKit form library for server and client validation  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/xddq/ts2typebox">ts2typebox</a>  </td><td class="markdownTableBodyNone">Creating TypeBox code from Typescript types  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/gsuess/typebox-cli">typebox-cli</a>  </td><td class="markdownTableBodyNone">Generate Schema with TypeBox from the CLI  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/jtlapp/typebox-form-parser">typebox-form-parser</a>  </td><td class="markdownTableBodyNone">Parses form and query data based on TypeBox schemas  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/iam-medvedev/typebox-schema-faker">typebox-schema-faker</a>  </td><td class="markdownTableBodyNone">Generate fake data from TypeBox schemas for testing, prototyping and development  </td></tr>
</table>
<p><a class="anchor" id="benchmark"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2072"></a>
Benchmark</h2>
<p>This project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running <span class="tt">npm run benchmark</span>. The results below show for Ajv version 8.12.0 running on Node 20.10.0.</p>
<p>For additional comparative benchmarks, please refer to <a href="https://moltar.github.io/typescript-runtime-type-benchmarks/">typescript-runtime-type-benchmarks</a>.</p>
<p><a class="anchor" id="benchmark-compile"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2073"></a>
Compile</h3>
<p>This benchmark measures compilation performance for varying types.</p>
<div class="fragment"><div class="line">┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐</div>
<div class="line">│ (index)                    │ Iterations │ Ajv          │ TypeCompiler │ Performance  │</div>
<div class="line">├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤</div>
<div class="line">│ Literal_String             │ 1000       │ &#39;    211 ms&#39; │ &#39;      8 ms&#39; │ &#39;   26.38 x&#39; │</div>
<div class="line">│ Literal_Number             │ 1000       │ &#39;    185 ms&#39; │ &#39;      5 ms&#39; │ &#39;   37.00 x&#39; │</div>
<div class="line">│ Literal_Boolean            │ 1000       │ &#39;    195 ms&#39; │ &#39;      4 ms&#39; │ &#39;   48.75 x&#39; │</div>
<div class="line">│ Primitive_Number           │ 1000       │ &#39;    149 ms&#39; │ &#39;      7 ms&#39; │ &#39;   21.29 x&#39; │</div>
<div class="line">│ Primitive_String           │ 1000       │ &#39;    135 ms&#39; │ &#39;      5 ms&#39; │ &#39;   27.00 x&#39; │</div>
<div class="line">│ Primitive_String_Pattern   │ 1000       │ &#39;    193 ms&#39; │ &#39;     10 ms&#39; │ &#39;   19.30 x&#39; │</div>
<div class="line">│ Primitive_Boolean          │ 1000       │ &#39;    152 ms&#39; │ &#39;      4 ms&#39; │ &#39;   38.00 x&#39; │</div>
<div class="line">│ Primitive_Null             │ 1000       │ &#39;    147 ms&#39; │ &#39;      4 ms&#39; │ &#39;   36.75 x&#39; │</div>
<div class="line">│ Object_Unconstrained       │ 1000       │ &#39;   1065 ms&#39; │ &#39;     26 ms&#39; │ &#39;   40.96 x&#39; │</div>
<div class="line">│ Object_Constrained         │ 1000       │ &#39;   1183 ms&#39; │ &#39;     26 ms&#39; │ &#39;   45.50 x&#39; │</div>
<div class="line">│ Object_Vector3             │ 1000       │ &#39;    407 ms&#39; │ &#39;      9 ms&#39; │ &#39;   45.22 x&#39; │</div>
<div class="line">│ Object_Box3D               │ 1000       │ &#39;   1777 ms&#39; │ &#39;     24 ms&#39; │ &#39;   74.04 x&#39; │</div>
<div class="line">│ Tuple_Primitive            │ 1000       │ &#39;    485 ms&#39; │ &#39;     11 ms&#39; │ &#39;   44.09 x&#39; │</div>
<div class="line">│ Tuple_Object               │ 1000       │ &#39;   1344 ms&#39; │ &#39;     17 ms&#39; │ &#39;   79.06 x&#39; │</div>
<div class="line">│ Composite_Intersect        │ 1000       │ &#39;    606 ms&#39; │ &#39;     14 ms&#39; │ &#39;   43.29 x&#39; │</div>
<div class="line">│ Composite_Union            │ 1000       │ &#39;    522 ms&#39; │ &#39;     17 ms&#39; │ &#39;   30.71 x&#39; │</div>
<div class="line">│ Math_Vector4               │ 1000       │ &#39;    851 ms&#39; │ &#39;      9 ms&#39; │ &#39;   94.56 x&#39; │</div>
<div class="line">│ Math_Matrix4               │ 1000       │ &#39;    406 ms&#39; │ &#39;     10 ms&#39; │ &#39;   40.60 x&#39; │</div>
<div class="line">│ Array_Primitive_Number     │ 1000       │ &#39;    367 ms&#39; │ &#39;      6 ms&#39; │ &#39;   61.17 x&#39; │</div>
<div class="line">│ Array_Primitive_String     │ 1000       │ &#39;    339 ms&#39; │ &#39;      7 ms&#39; │ &#39;   48.43 x&#39; │</div>
<div class="line">│ Array_Primitive_Boolean    │ 1000       │ &#39;    325 ms&#39; │ &#39;      5 ms&#39; │ &#39;   65.00 x&#39; │</div>
<div class="line">│ Array_Object_Unconstrained │ 1000       │ &#39;   1863 ms&#39; │ &#39;     21 ms&#39; │ &#39;   88.71 x&#39; │</div>
<div class="line">│ Array_Object_Constrained   │ 1000       │ &#39;   1535 ms&#39; │ &#39;     18 ms&#39; │ &#39;   85.28 x&#39; │</div>
<div class="line">│ Array_Tuple_Primitive      │ 1000       │ &#39;    829 ms&#39; │ &#39;     14 ms&#39; │ &#39;   59.21 x&#39; │</div>
<div class="line">│ Array_Tuple_Object         │ 1000       │ &#39;   1674 ms&#39; │ &#39;     14 ms&#39; │ &#39;  119.57 x&#39; │</div>
<div class="line">│ Array_Composite_Intersect  │ 1000       │ &#39;    789 ms&#39; │ &#39;     13 ms&#39; │ &#39;   60.69 x&#39; │</div>
<div class="line">│ Array_Composite_Union      │ 1000       │ &#39;    822 ms&#39; │ &#39;     15 ms&#39; │ &#39;   54.80 x&#39; │</div>
<div class="line">│ Array_Math_Vector4         │ 1000       │ &#39;   1129 ms&#39; │ &#39;     14 ms&#39; │ &#39;   80.64 x&#39; │</div>
<div class="line">│ Array_Math_Matrix4         │ 1000       │ &#39;    673 ms&#39; │ &#39;      9 ms&#39; │ &#39;   74.78 x&#39; │</div>
<div class="line">└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘</div>
</div><!-- fragment --><p><a class="anchor" id="benchmark-validate"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2074"></a>
Validate</h3>
<p>This benchmark measures validation performance for varying types.</p>
<div class="fragment"><div class="line">┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐</div>
<div class="line">│ (index)                    │ Iterations │ ValueCheck   │ Ajv          │ TypeCompiler │ Performance  │</div>
<div class="line">├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤</div>
<div class="line">│ Literal_String             │ 1000000    │ &#39;     17 ms&#39; │ &#39;      5 ms&#39; │ &#39;      5 ms&#39; │ &#39;    1.00 x&#39; │</div>
<div class="line">│ Literal_Number             │ 1000000    │ &#39;     14 ms&#39; │ &#39;     18 ms&#39; │ &#39;      9 ms&#39; │ &#39;    2.00 x&#39; │</div>
<div class="line">│ Literal_Boolean            │ 1000000    │ &#39;     14 ms&#39; │ &#39;     20 ms&#39; │ &#39;      9 ms&#39; │ &#39;    2.22 x&#39; │</div>
<div class="line">│ Primitive_Number           │ 1000000    │ &#39;     17 ms&#39; │ &#39;     19 ms&#39; │ &#39;      9 ms&#39; │ &#39;    2.11 x&#39; │</div>
<div class="line">│ Primitive_String           │ 1000000    │ &#39;     17 ms&#39; │ &#39;     18 ms&#39; │ &#39;     10 ms&#39; │ &#39;    1.80 x&#39; │</div>
<div class="line">│ Primitive_String_Pattern   │ 1000000    │ &#39;    172 ms&#39; │ &#39;     46 ms&#39; │ &#39;     41 ms&#39; │ &#39;    1.12 x&#39; │</div>
<div class="line">│ Primitive_Boolean          │ 1000000    │ &#39;     14 ms&#39; │ &#39;     19 ms&#39; │ &#39;     10 ms&#39; │ &#39;    1.90 x&#39; │</div>
<div class="line">│ Primitive_Null             │ 1000000    │ &#39;     16 ms&#39; │ &#39;     19 ms&#39; │ &#39;      9 ms&#39; │ &#39;    2.11 x&#39; │</div>
<div class="line">│ Object_Unconstrained       │ 1000000    │ &#39;    437 ms&#39; │ &#39;     28 ms&#39; │ &#39;     14 ms&#39; │ &#39;    2.00 x&#39; │</div>
<div class="line">│ Object_Constrained         │ 1000000    │ &#39;    653 ms&#39; │ &#39;     46 ms&#39; │ &#39;     37 ms&#39; │ &#39;    1.24 x&#39; │</div>
<div class="line">│ Object_Vector3             │ 1000000    │ &#39;    201 ms&#39; │ &#39;     22 ms&#39; │ &#39;     12 ms&#39; │ &#39;    1.83 x&#39; │</div>
<div class="line">│ Object_Box3D               │ 1000000    │ &#39;    961 ms&#39; │ &#39;     37 ms&#39; │ &#39;     19 ms&#39; │ &#39;    1.95 x&#39; │</div>
<div class="line">│ Object_Recursive           │ 1000000    │ &#39;   3715 ms&#39; │ &#39;    363 ms&#39; │ &#39;    174 ms&#39; │ &#39;    2.09 x&#39; │</div>
<div class="line">│ Tuple_Primitive            │ 1000000    │ &#39;    107 ms&#39; │ &#39;     23 ms&#39; │ &#39;     11 ms&#39; │ &#39;    2.09 x&#39; │</div>
<div class="line">│ Tuple_Object               │ 1000000    │ &#39;    375 ms&#39; │ &#39;     28 ms&#39; │ &#39;     15 ms&#39; │ &#39;    1.87 x&#39; │</div>
<div class="line">│ Composite_Intersect        │ 1000000    │ &#39;    377 ms&#39; │ &#39;     22 ms&#39; │ &#39;     12 ms&#39; │ &#39;    1.83 x&#39; │</div>
<div class="line">│ Composite_Union            │ 1000000    │ &#39;    337 ms&#39; │ &#39;     30 ms&#39; │ &#39;     17 ms&#39; │ &#39;    1.76 x&#39; │</div>
<div class="line">│ Math_Vector4               │ 1000000    │ &#39;    137 ms&#39; │ &#39;     23 ms&#39; │ &#39;     11 ms&#39; │ &#39;    2.09 x&#39; │</div>
<div class="line">│ Math_Matrix4               │ 1000000    │ &#39;    576 ms&#39; │ &#39;     37 ms&#39; │ &#39;     28 ms&#39; │ &#39;    1.32 x&#39; │</div>
<div class="line">│ Array_Primitive_Number     │ 1000000    │ &#39;    145 ms&#39; │ &#39;     23 ms&#39; │ &#39;     12 ms&#39; │ &#39;    1.92 x&#39; │</div>
<div class="line">│ Array_Primitive_String     │ 1000000    │ &#39;    152 ms&#39; │ &#39;     22 ms&#39; │ &#39;     13 ms&#39; │ &#39;    1.69 x&#39; │</div>
<div class="line">│ Array_Primitive_Boolean    │ 1000000    │ &#39;    131 ms&#39; │ &#39;     20 ms&#39; │ &#39;     13 ms&#39; │ &#39;    1.54 x&#39; │</div>
<div class="line">│ Array_Object_Unconstrained │ 1000000    │ &#39;   2821 ms&#39; │ &#39;     62 ms&#39; │ &#39;     45 ms&#39; │ &#39;    1.38 x&#39; │</div>
<div class="line">│ Array_Object_Constrained   │ 1000000    │ &#39;   2958 ms&#39; │ &#39;    119 ms&#39; │ &#39;    134 ms&#39; │ &#39;    0.89 x&#39; │</div>
<div class="line">│ Array_Object_Recursive     │ 1000000    │ &#39;  14695 ms&#39; │ &#39;   1621 ms&#39; │ &#39;    635 ms&#39; │ &#39;    2.55 x&#39; │</div>
<div class="line">│ Array_Tuple_Primitive      │ 1000000    │ &#39;    478 ms&#39; │ &#39;     35 ms&#39; │ &#39;     28 ms&#39; │ &#39;    1.25 x&#39; │</div>
<div class="line">│ Array_Tuple_Object         │ 1000000    │ &#39;   1623 ms&#39; │ &#39;     63 ms&#39; │ &#39;     48 ms&#39; │ &#39;    1.31 x&#39; │</div>
<div class="line">│ Array_Composite_Intersect  │ 1000000    │ &#39;   1582 ms&#39; │ &#39;     43 ms&#39; │ &#39;     30 ms&#39; │ &#39;    1.43 x&#39; │</div>
<div class="line">│ Array_Composite_Union      │ 1000000    │ &#39;   1331 ms&#39; │ &#39;     76 ms&#39; │ &#39;     40 ms&#39; │ &#39;    1.90 x&#39; │</div>
<div class="line">│ Array_Math_Vector4         │ 1000000    │ &#39;    564 ms&#39; │ &#39;     38 ms&#39; │ &#39;     24 ms&#39; │ &#39;    1.58 x&#39; │</div>
<div class="line">│ Array_Math_Matrix4         │ 1000000    │ &#39;   2382 ms&#39; │ &#39;    111 ms&#39; │ &#39;     83 ms&#39; │ &#39;    1.34 x&#39; │</div>
<div class="line">└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘</div>
</div><!-- fragment --><p><a class="anchor" id="benchmark-compression"></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2075"></a>
Compression</h3>
<p>The following table lists esbuild compiled and minified sizes for each TypeBox module.</p>
<div class="fragment"><div class="line">┌──────────────────────┬────────────┬────────────┬─────────────┐</div>
<div class="line">│ (index)              │ Compiled   │ Minified   │ Compression │</div>
<div class="line">├──────────────────────┼────────────┼────────────┼─────────────┤</div>
<div class="line">│ typebox/compiler     │ &#39;122.4 kb&#39; │ &#39; 53.4 kb&#39; │ &#39;2.29 x&#39;    │</div>
<div class="line">│ typebox/errors       │ &#39; 67.6 kb&#39; │ &#39; 29.6 kb&#39; │ &#39;2.28 x&#39;    │</div>
<div class="line">│ typebox/syntax       │ &#39;132.9 kb&#39; │ &#39; 54.2 kb&#39; │ &#39;2.45 x&#39;    │</div>
<div class="line">│ typebox/system       │ &#39;  7.4 kb&#39; │ &#39;  3.2 kb&#39; │ &#39;2.33 x&#39;    │</div>
<div class="line">│ typebox/value        │ &#39;150.1 kb&#39; │ &#39; 62.2 kb&#39; │ &#39;2.41 x&#39;    │</div>
<div class="line">│ typebox              │ &#39;106.8 kb&#39; │ &#39; 43.2 kb&#39; │ &#39;2.47 x&#39;    │</div>
<div class="line">└──────────────────────┴────────────┴────────────┴─────────────┘</div>
</div><!-- fragment --><p><a class="anchor" id="contribute"></a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2076"></a>
Contribute</h2>
<p>TypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project prefers open community discussion before accepting new features. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_8983b1862dce8a71846356b6209105f4.html">EcoEats-Project</a></li><li class="navelem"><a href="dir_5091f2b68170d33f954320199e2fed0a.html">node_modules</a></li><li class="navelem"><a href="dir_fcfbd2bcc1e777bae19fd8075af818f1.html">@types</a></li><li class="navelem"><a href="dir_4f06a325394480918f2b2d302d0c8138.html">jest</a></li><li class="navelem"><a href="dir_237c8dd130bfdad7ebfed44fbb83e2d7.html">node_modules</a></li><li class="navelem"><a href="dir_494ed2f798acc46e0706bec308f449ac.html">@sinclair</a></li><li class="navelem"><a href="dir_7142c7c5f0b0308a19a4932f5f0ca82f.html">typebox</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
