<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/sshpk Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_4da34288cfb7e0b9f48f6d52e222b497.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">sshpk Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for sshpk:</div>
<div class="dyncontent">
<div class="center"><img src="dir_4da34288cfb7e0b9f48f6d52e222b497_dep.png" border="0" usemap="#adir__4da34288cfb7e0b9f48f6d52e222b497__dep" loading="lazy" alt="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/sshpk"/></div>
</div>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>Parse, convert, fingerprint and use SSH keys (both public and private) in pure node &ndash; no <span class="tt">ssh-keygen</span> or other external dependencies.</p>
<p>Supports RSA, DSA, ECDSA (nistp-*) and ED25519 key types, in PEM (PKCS#1, PKCS#8) and OpenSSH formats.</p>
<p>This library has been extracted from <a href="https://github.com/joyent/node-http-signature"><span class="tt">node-http-signature</span></a> (work by <a href="https://github.com/mcavage">Mark Cavage</a> and <a href="https://github.com/bahamas10">Dave Eddy</a>) and <a href="https://github.com/bahamas10/node-ssh-fingerprint"><span class="tt">node-ssh-fingerprint</span></a> (work by Dave Eddy), with additions (including ECDSA support) by <a href="https://github.com/arekinath">Alex Wilson</a>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md13050"></a>
Install</h1>
<div class="fragment"><div class="line">npm install sshpk</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md13051"></a>
Examples</h1>
<div class="fragment"><div class="line">var sshpk = require(&#39;sshpk&#39;);</div>
<div class="line"> </div>
<div class="line">var fs = require(&#39;fs&#39;);</div>
<div class="line"> </div>
<div class="line">/* Read in an OpenSSH-format public key */</div>
<div class="line">var keyPub = fs.readFileSync(&#39;id_rsa.pub&#39;);</div>
<div class="line">var key = sshpk.parseKey(keyPub, &#39;ssh&#39;);</div>
<div class="line"> </div>
<div class="line">/* Get metadata about the key */</div>
<div class="line">console.log(&#39;type =&gt; %s&#39;, key.type);</div>
<div class="line">console.log(&#39;size =&gt; %d bits&#39;, key.size);</div>
<div class="line">console.log(&#39;comment =&gt; %s&#39;, key.comment);</div>
<div class="line"> </div>
<div class="line">/* Compute key fingerprints, in new OpenSSH (&gt;6.7) format, and old MD5 */</div>
<div class="line">console.log(&#39;fingerprint =&gt; %s&#39;, key.fingerprint().toString());</div>
<div class="line">console.log(&#39;old-style fingerprint =&gt; %s&#39;, key.fingerprint(&#39;md5&#39;).toString());</div>
</div><!-- fragment --><p>Example output:</p>
<div class="fragment"><div class="line">type =&gt; rsa</div>
<div class="line">size =&gt; 2048 bits</div>
<div class="line">comment =&gt; foo@foo.com</div>
<div class="line">fingerprint =&gt; SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w</div>
<div class="line">old-style fingerprint =&gt; a0:c8:ad:6c:32:9a:32:fa:59:cc:a9:8c:0a:0d:6e:bd</div>
</div><!-- fragment --><p>More examples: converting between formats:</p>
<div class="fragment"><div class="line">/* Read in a PEM public key */</div>
<div class="line">var keyPem = fs.readFileSync(&#39;id_rsa.pem&#39;);</div>
<div class="line">var key = sshpk.parseKey(keyPem, &#39;pem&#39;);</div>
<div class="line"> </div>
<div class="line">/* Convert to PEM PKCS#8 public key format */</div>
<div class="line">var pemBuf = key.toBuffer(&#39;pkcs8&#39;);</div>
<div class="line"> </div>
<div class="line">/* Convert to SSH public key format (and return as a string) */</div>
<div class="line">var sshKey = key.toString(&#39;ssh&#39;);</div>
</div><!-- fragment --><p>Signing and verifying:</p>
<div class="fragment"><div class="line">/* Read in an OpenSSH/PEM *private* key */</div>
<div class="line">var keyPriv = fs.readFileSync(&#39;id_ecdsa&#39;);</div>
<div class="line">var key = sshpk.parsePrivateKey(keyPriv, &#39;pem&#39;);</div>
<div class="line"> </div>
<div class="line">var data = &#39;some data&#39;;</div>
<div class="line"> </div>
<div class="line">/* Sign some data with the key */</div>
<div class="line">var s = key.createSign(&#39;sha1&#39;);</div>
<div class="line">s.update(data);</div>
<div class="line">var signature = s.sign();</div>
<div class="line"> </div>
<div class="line">/* Now load the public key (could also use just key.toPublic()) */</div>
<div class="line">var keyPub = fs.readFileSync(&#39;id_ecdsa.pub&#39;);</div>
<div class="line">key = sshpk.parseKey(keyPub, &#39;ssh&#39;);</div>
<div class="line"> </div>
<div class="line">/* Make a crypto.Verifier with this key */</div>
<div class="line">var v = key.createVerify(&#39;sha1&#39;);</div>
<div class="line">v.update(data);</div>
<div class="line">var valid = v.verify(signature);</div>
<div class="line">/* =&gt; true! */</div>
</div><!-- fragment --><p>Matching fingerprints with keys:</p>
<div class="fragment"><div class="line">var fp = sshpk.parseFingerprint(&#39;SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w&#39;);</div>
<div class="line"> </div>
<div class="line">var keys = [sshpk.parseKey(...), sshpk.parseKey(...), ...];</div>
<div class="line"> </div>
<div class="line">keys.forEach(function (key) {</div>
<div class="line">    if (fp.matches(key))</div>
<div class="line">        console.log(&#39;found it!&#39;);</div>
<div class="line">});</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md13052"></a>
Usage</h1>
<h1 class="doxsection"><a class="anchor" id="autotoc_md13053"></a>
Public keys</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13054"></a>
&lsquo;parseKey(data[, format = 'auto&rsquo;[, options]])`</h2>
<p>Parses a key from a given data format and returns a new <span class="tt">Key</span> object.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">data</span> &ndash; Either a Buffer or String, containing the key</li>
<li><span class="tt">format</span> &ndash; String name of format to use, valid options are:<ul>
<li><span class="tt">auto</span>: choose automatically from all below</li>
<li><span class="tt">pem</span>: supports both PKCS#1 and PKCS#8</li>
<li><span class="tt">ssh</span>: standard OpenSSH format,</li>
<li><span class="tt">pkcs1</span>, <span class="tt">pkcs8</span>: variants of <span class="tt">pem</span></li>
<li><span class="tt">rfc4253</span>: raw OpenSSH wire format</li>
<li><span class="tt">openssh</span>: new post-OpenSSH 6.5 internal format, produced by <span class="tt">ssh-keygen -o</span></li>
<li><span class="tt">dnssec</span>: <span class="tt">.key</span> file format output by <span class="tt">dnssec-keygen</span> etc</li>
<li><span class="tt">putty</span>: the PuTTY <span class="tt">.ppk</span> file format (supports truncated variant without all the lines from <span class="tt">Private-Lines:</span> onwards)</li>
</ul>
</li>
<li><span class="tt">options</span> &ndash; Optional Object, extra options, with keys:<ul>
<li><span class="tt">filename</span> &ndash; Optional String, name for the key being parsed (eg. the filename that was opened). Used to generate Error messages</li>
<li><span class="tt">passphrase</span> &ndash; Optional String, encryption passphrase used to decrypt an encrypted PEM file</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13055"></a>
<span class="tt">Key.isKey(obj)</span></h2>
<p>Returns <span class="tt">true</span> if the given object is a valid <span class="tt">Key</span> object created by a version of <span class="tt">sshpk</span> compatible with this one.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">obj</span> &ndash; Object to identify</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13056"></a>
<span class="tt">Key#type</span></h2>
<p>String, the type of key. Valid options are <span class="tt">rsa</span>, <span class="tt">dsa</span>, <span class="tt">ecdsa</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13057"></a>
<span class="tt">Key#size</span></h2>
<p>Integer, "size" of the key in bits. For RSA/DSA this is the size of the modulus; for ECDSA this is the bit size of the curve in use.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13058"></a>
<span class="tt">Key#comment</span></h2>
<p>Optional string, a key comment used by some formats (eg the <span class="tt">ssh</span> format).</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13059"></a>
<span class="tt">Key#curve</span></h2>
<p>Only present if &lsquo;this.type === 'ecdsa&rsquo;<span class="tt">, string containing the name of the
named curve used with this key. Possible values include </span>nistp256<span class="tt">, </span>nistp384<span class="tt">
and </span>nistp521`.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13060"></a>
&lsquo;Key#toBuffer([format = 'ssh&rsquo;])`</h2>
<p>Convert the key into a given data format and return the serialized key as a Buffer.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">format</span> &ndash; String name of format to use, for valid options see <span class="tt">parseKey()</span></li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13061"></a>
<span class="tt">Key#toString([format = 'ssh])</span></h2>
<p>Same as <span class="tt">this.toBuffer(format).toString()</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13062"></a>
&lsquo;Key#fingerprint([algorithm = 'sha256&rsquo;[, hashType = 'ssh']])`</h2>
<p>Creates a new <span class="tt">Fingerprint</span> object representing this Key's fingerprint.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">algorithm</span> &ndash; String name of hash algorithm to use, valid options are <span class="tt">md5</span>, <span class="tt">sha1</span>, <span class="tt">sha256</span>, <span class="tt">sha384</span>, <span class="tt">sha512</span></li>
<li><span class="tt">hashType</span> &ndash; String name of fingerprint hash type to use, valid options are <span class="tt">ssh</span> (the type of fingerprint used by OpenSSH, e.g. in <span class="tt">ssh-keygen</span>), <span class="tt">spki</span> (used by HPKP, some OpenSSL applications)</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13063"></a>
<span class="tt">Key#createVerify([hashAlgorithm])</span></h2>
<p>Creates a <span class="tt">crypto.Verifier</span> specialized to use this Key (and the correct public key algorithm to match it). The returned Verifier has the same API as a regular one, except that the <span class="tt">verify()</span> function takes only the target signature as an argument.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">hashAlgorithm</span> &ndash; optional String name of hash algorithm to use, any supported by OpenSSL are valid, usually including <span class="tt">sha1</span>, <span class="tt">sha256</span>.</li>
</ul>
<p><span class="tt">v.verify(signature[, format])</span> Parameters</p>
<ul>
<li><span class="tt">signature</span> &ndash; either a Signature object, or a Buffer or String</li>
<li><span class="tt">format</span> &ndash; optional String, name of format to interpret given String with. Not valid if <span class="tt">signature</span> is a Signature or Buffer.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13064"></a>
<span class="tt">Key#createDiffieHellman()</span></h2>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13065"></a>
<span class="tt">Key#createDH()</span></h2>
<p>Creates a Diffie-Hellman key exchange object initialized with this key and all necessary parameters. This has the same API as a <span class="tt">crypto.DiffieHellman</span> instance, except that functions take <span class="tt">Key</span> and <span class="tt">PrivateKey</span> objects as arguments, and return them where indicated for.</p>
<p>This is only valid for keys belonging to a cryptosystem that supports DHE or a close analogue (i.e. <span class="tt">dsa</span>, <span class="tt">ecdsa</span> and <span class="tt">curve25519</span> keys). An attempt to call this function on other keys will yield an <span class="tt">Error</span>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md13066"></a>
Private keys</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13067"></a>
&lsquo;parsePrivateKey(data[, format = 'auto&rsquo;[, options]])`</h2>
<p>Parses a private key from a given data format and returns a new <span class="tt">PrivateKey</span> object.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">data</span> &ndash; Either a Buffer or String, containing the key</li>
<li><span class="tt">format</span> &ndash; String name of format to use, valid options are:<ul>
<li><span class="tt">auto</span>: choose automatically from all below</li>
<li><span class="tt">pem</span>: supports both PKCS#1 and PKCS#8</li>
<li><span class="tt">ssh</span>, <span class="tt">openssh</span>: new post-OpenSSH 6.5 internal format, produced by <span class="tt">ssh-keygen -o</span></li>
<li><span class="tt">pkcs1</span>, <span class="tt">pkcs8</span>: variants of <span class="tt">pem</span></li>
<li><span class="tt">rfc4253</span>: raw OpenSSH wire format</li>
<li><span class="tt">dnssec</span>: <span class="tt">.private</span> format output by <span class="tt">dnssec-keygen</span> etc.</li>
</ul>
</li>
<li><span class="tt">options</span> &ndash; Optional Object, extra options, with keys:<ul>
<li><span class="tt">filename</span> &ndash; Optional String, name for the key being parsed (eg. the filename that was opened). Used to generate Error messages</li>
<li><span class="tt">passphrase</span> &ndash; Optional String, encryption passphrase used to decrypt an encrypted PEM file</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13068"></a>
<span class="tt">generatePrivateKey(type[, options])</span></h2>
<p>Generates a new private key of a certain key type, from random data.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">type</span> &ndash; String, type of key to generate. Currently supported are &lsquo;'ecdsa&rsquo;<span class="tt">
            and </span>'ed25519'<span class="tt"></span></li>
<li><span class="tt"></span>options<span class="tt"> -- optional Object, with keys:<ul>
<li></li>
</ul>
</span>curve<span class="tt"> -- optional String, for </span>'ecdsa'<span class="tt"> keys, specifies the curve to use.
               If ECDSA is specified and this option is not given, defaults to
               using </span>'nistp256'`.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13069"></a>
<span class="tt">PrivateKey.isPrivateKey(obj)</span></h2>
<p>Returns <span class="tt">true</span> if the given object is a valid <span class="tt">PrivateKey</span> object created by a version of <span class="tt">sshpk</span> compatible with this one.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">obj</span> &ndash; Object to identify</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13070"></a>
<span class="tt">PrivateKey#type</span></h2>
<p>String, the type of key. Valid options are <span class="tt">rsa</span>, <span class="tt">dsa</span>, <span class="tt">ecdsa</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13071"></a>
<span class="tt">PrivateKey#size</span></h2>
<p>Integer, "size" of the key in bits. For RSA/DSA this is the size of the modulus; for ECDSA this is the bit size of the curve in use.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13072"></a>
<span class="tt">PrivateKey#curve</span></h2>
<p>Only present if &lsquo;this.type === 'ecdsa&rsquo;<span class="tt">, string containing the name of the
named curve used with this key. Possible values include </span>nistp256<span class="tt">, </span>nistp384<span class="tt">
and </span>nistp521`.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13073"></a>
&lsquo;PrivateKey#toBuffer([format = 'pkcs1&rsquo;])`</h2>
<p>Convert the key into a given data format and return the serialized key as a Buffer.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">format</span> &ndash; String name of format to use, valid options are listed under <span class="tt">parsePrivateKey</span>. Note that ED25519 keys default to <span class="tt">openssh</span> format instead (as they have no <span class="tt">pkcs1</span> representation).</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13074"></a>
&lsquo;PrivateKey#toString([format = 'pkcs1&rsquo;])`</h2>
<p>Same as <span class="tt">this.toBuffer(format).toString()</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13075"></a>
<span class="tt">PrivateKey#toPublic()</span></h2>
<p>Extract just the public part of this private key, and return it as a <span class="tt">Key</span> object.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13076"></a>
&lsquo;PrivateKey#fingerprint([algorithm = 'sha256&rsquo;])`</h2>
<p>Same as <span class="tt">this.toPublic().fingerprint()</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13077"></a>
<span class="tt">PrivateKey#createVerify([hashAlgorithm])</span></h2>
<p>Same as <span class="tt">this.toPublic().createVerify()</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13078"></a>
<span class="tt">PrivateKey#createSign([hashAlgorithm])</span></h2>
<p>Creates a <span class="tt">crypto.Sign</span> specialized to use this PrivateKey (and the correct key algorithm to match it). The returned Signer has the same API as a regular one, except that the <span class="tt">sign()</span> function takes no arguments, and returns a <span class="tt">Signature</span> object.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">hashAlgorithm</span> &ndash; optional String name of hash algorithm to use, any supported by OpenSSL are valid, usually including <span class="tt">sha1</span>, <span class="tt">sha256</span>.</li>
</ul>
<p><span class="tt">v.sign()</span> Parameters</p>
<ul>
<li>none</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13079"></a>
<span class="tt">PrivateKey#derive(newType)</span></h2>
<p>Derives a related key of type <span class="tt">newType</span> from this key. Currently this is only supported to change between <span class="tt">ed25519</span> and <span class="tt">curve25519</span> keys which are stored with the same private key (but usually distinct public keys in order to avoid degenerate keys that lead to a weak Diffie-Hellman exchange).</p>
<p>Parameters</p>
<ul>
<li><span class="tt">newType</span> &ndash; String, type of key to derive, either <span class="tt">ed25519</span> or <span class="tt">curve25519</span></li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md13080"></a>
Fingerprints</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13081"></a>
<span class="tt">parseFingerprint(fingerprint[, options])</span></h2>
<p>Pre-parses a fingerprint, creating a <span class="tt">Fingerprint</span> object that can be used to quickly locate a key by using the <span class="tt">Fingerprint#matches</span> function.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">fingerprint</span> &ndash; String, the fingerprint value, in any supported format</li>
<li><span class="tt">options</span> &ndash; Optional Object, with properties:<ul>
<li><span class="tt">algorithms</span> &ndash; Array of strings, names of hash algorithms to limit support to. If <span class="tt">fingerprint</span> uses a hash algorithm not on this list, throws <span class="tt">InvalidAlgorithmError</span>.</li>
<li><span class="tt">hashType</span> &ndash; String, the type of hash the fingerprint uses, either <span class="tt">ssh</span> or <span class="tt">spki</span> (normally auto-detected based on the format, but can be overridden)</li>
<li><span class="tt">type</span> &ndash; String, the entity this fingerprint identifies, either <span class="tt">key</span> or <span class="tt">certificate</span></li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13082"></a>
<span class="tt">Fingerprint.isFingerprint(obj)</span></h2>
<p>Returns <span class="tt">true</span> if the given object is a valid <span class="tt">Fingerprint</span> object created by a version of <span class="tt">sshpk</span> compatible with this one.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">obj</span> &ndash; Object to identify</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13083"></a>
<span class="tt">Fingerprint#toString([format])</span></h2>
<p>Returns a fingerprint as a string, in the given format.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">format</span> &ndash; Optional String, format to use, valid options are <span class="tt">hex</span> and <span class="tt">base64</span>. If this <span class="tt">Fingerprint</span> uses the <span class="tt">md5</span> algorithm, the default format is <span class="tt">hex</span>. Otherwise, the default is <span class="tt">base64</span>.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13084"></a>
<span class="tt">Fingerprint#matches(keyOrCertificate)</span></h2>
<p>Verifies whether or not this <span class="tt">Fingerprint</span> matches a given <span class="tt">Key</span> or <span class="tt">Certificate</span>. This function uses double-hashing to avoid leaking timing information. Returns a boolean.</p>
<p>Note that a <span class="tt">Key</span>-type Fingerprint will always return <span class="tt">false</span> if asked to match a <span class="tt">Certificate</span> and vice versa.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">keyOrCertificate</span> &ndash; a <span class="tt">Key</span> object or <span class="tt">Certificate</span> object, the entity to match this fingerprint against</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md13085"></a>
Signatures</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13086"></a>
<span class="tt">parseSignature(signature, algorithm, format)</span></h2>
<p>Parses a signature in a given format, creating a <span class="tt">Signature</span> object. Useful for converting between the SSH and ASN.1 (PKCS/OpenSSL) signature formats, and also returned as output from <span class="tt">PrivateKey#createSign().sign()</span>.</p>
<p>A Signature object can also be passed to a verifier produced by <span class="tt">Key#createVerify()</span> and it will automatically be converted internally into the correct format for verification.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">signature</span> &ndash; a Buffer (binary) or String (base64), data of the actual signature in the given format</li>
<li><span class="tt">algorithm</span> &ndash; a String, name of the algorithm to be used, possible values are <span class="tt">rsa</span>, <span class="tt">dsa</span>, <span class="tt">ecdsa</span></li>
<li><span class="tt">format</span> &ndash; a String, either <span class="tt">asn1</span> or <span class="tt">ssh</span></li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13087"></a>
<span class="tt">Signature.isSignature(obj)</span></h2>
<p>Returns <span class="tt">true</span> if the given object is a valid <span class="tt">Signature</span> object created by a version of <span class="tt">sshpk</span> compatible with this one.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">obj</span> &ndash; Object to identify</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13088"></a>
&lsquo;Signature#toBuffer([format = 'asn1&rsquo;])`</h2>
<p>Converts a Signature to the given format and returns it as a Buffer.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">format</span> &ndash; a String, either <span class="tt">asn1</span> or <span class="tt">ssh</span></li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13089"></a>
&lsquo;Signature#toString([format = 'asn1&rsquo;])`</h2>
<p>Same as &lsquo;this.toBuffer(format).toString('base64&rsquo;)`.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md13090"></a>
Certificates</h1>
<p><span class="tt">sshpk</span> includes basic support for parsing certificates in X.509 (PEM) format and the OpenSSH certificate format. This feature is intended to be used mainly to access basic metadata about certificates, extract public keys from them, and also to generate simple self-signed certificates from an existing key.</p>
<p>Notably, there is no implementation of CA chain-of-trust verification, and only very minimal support for key usage restrictions. Please do the security world a favour, and DO NOT use this code for certificate verification in the traditional X.509 CA chain style.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13091"></a>
<span class="tt">parseCertificate(data, format)</span></h2>
<p>Parameters</p>
<ul>
<li><span class="tt">data</span> &ndash; a Buffer or String</li>
<li><span class="tt">format</span> &ndash; a String, format to use, one of &lsquo;'openssh&rsquo;<span class="tt">, </span>'pem'<span class="tt"> (X.509 in a
               PEM wrapper), or </span>'x509'` (raw DER encoded)</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13092"></a>
<span class="tt">createSelfSignedCertificate(subject, privateKey[, options])</span></h2>
<p>Parameters</p>
<ul>
<li><span class="tt">subject</span> &ndash; an Identity, the subject of the certificate</li>
<li><span class="tt">privateKey</span> &ndash; a PrivateKey, the key of the subject: will be used both to be placed in the certificate and also to sign it (since this is a self-signed certificate)</li>
<li><span class="tt">options</span> &ndash; optional Object, with keys:<ul>
<li><span class="tt">lifetime</span> &ndash; optional Number, lifetime of the certificate from now in seconds</li>
<li><span class="tt">validFrom</span>, <span class="tt">validUntil</span> &ndash; optional Dates, beginning and end of certificate validity period. If given <span class="tt">lifetime</span> will be ignored</li>
<li><span class="tt">serial</span> &ndash; optional Buffer, the serial number of the certificate</li>
<li><span class="tt">purposes</span> &ndash; optional Array of String, X.509 key usage restrictions</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13093"></a>
<span class="tt">createCertificate(subject, key, issuer, issuerKey[, options])</span></h2>
<p>Parameters</p>
<ul>
<li><span class="tt">subject</span> &ndash; an Identity, the subject of the certificate</li>
<li><span class="tt">key</span> &ndash; a Key, the public key of the subject</li>
<li><span class="tt">issuer</span> &ndash; an Identity, the issuer of the certificate who will sign it</li>
<li><span class="tt">issuerKey</span> &ndash; a PrivateKey, the issuer's private key for signing</li>
<li><span class="tt">options</span> &ndash; optional Object, with keys:<ul>
<li><span class="tt">lifetime</span> &ndash; optional Number, lifetime of the certificate from now in seconds</li>
<li><span class="tt">validFrom</span>, <span class="tt">validUntil</span> &ndash; optional Dates, beginning and end of certificate validity period. If given <span class="tt">lifetime</span> will be ignored</li>
<li><span class="tt">serial</span> &ndash; optional Buffer, the serial number of the certificate</li>
<li><span class="tt">purposes</span> &ndash; optional Array of String, X.509 key usage restrictions</li>
</ul>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13094"></a>
<span class="tt">Certificate#subjects</span></h2>
<p>Array of <span class="tt">Identity</span> instances describing the subject of this certificate.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13095"></a>
<span class="tt">Certificate#issuer</span></h2>
<p>The <span class="tt">Identity</span> of the Certificate's issuer (signer).</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13096"></a>
<span class="tt">Certificate#subjectKey</span></h2>
<p>The public key of the subject of the certificate, as a <span class="tt">Key</span> instance.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13097"></a>
<span class="tt">Certificate#issuerKey</span></h2>
<p>The public key of the signing issuer of this certificate, as a <span class="tt">Key</span> instance. May be <span class="tt">undefined</span> if the issuer's key is unknown (e.g. on an X509 certificate).</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13098"></a>
<span class="tt">Certificate#serial</span></h2>
<p>The serial number of the certificate. As this is normally a 64-bit or wider integer, it is returned as a Buffer.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13099"></a>
<span class="tt">Certificate#purposes</span></h2>
<p>Array of Strings indicating the X.509 key usage purposes that this certificate is valid for. The possible strings at the moment are:</p>
<ul>
<li>&lsquo;'signature&rsquo;<span class="tt"> -- key can be used for digital signatures</span></li>
<li><span class="tt"></span>'identity'<span class="tt"> -- key can be used to attest about the identity of the signer
                   (X.509 calls this </span>nonRepudiation<span class="tt">)</span></li>
<li><span class="tt"></span>'codeSigning'<span class="tt"> -- key can be used to sign executable code</span></li>
<li><span class="tt"></span>'keyEncryption'<span class="tt"> -- key can be used to encrypt other keys</span></li>
<li><span class="tt"></span>'encryption'<span class="tt"> -- key can be used to encrypt data (only applies for RSA)</span></li>
<li><span class="tt"></span>'keyAgreement'<span class="tt"> -- key can be used for key exchange protocols such as
                       Diffie-Hellman</span></li>
<li><span class="tt"></span>'ca'<span class="tt"> -- key can be used to sign other certificates (is a Certificate
             Authority)</span></li>
<li><span class="tt"></span>'crl'` &ndash; key can be used to sign Certificate Revocation Lists (CRLs)</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13100"></a>
<span class="tt">Certificate#getExtension(nameOrOid)</span></h2>
<p>Retrieves information about a certificate extension, if present, or returns <span class="tt">undefined</span> if not. The string argument <span class="tt">nameOrOid</span> should be either the OID (for X509 extensions) or the name (for OpenSSH extensions) of the extension to retrieve.</p>
<p>The object returned will have the following properties:</p>
<ul>
<li><span class="tt">format</span> &ndash; String, set to either &lsquo;'x509&rsquo;<span class="tt"> or </span>'openssh'<span class="tt"></span></li>
<li><span class="tt"></span>name<span class="tt"> or </span>oid<span class="tt"> -- String, only one set based on value of </span>format<span class="tt"></span></li>
<li><span class="tt"></span>data` &ndash; Buffer, the raw data inside the extension</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13101"></a>
<span class="tt">Certificate#getExtensions()</span></h2>
<p>Returns an Array of all present certificate extensions, in the same manner and format as <span class="tt">getExtension()</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13102"></a>
<span class="tt">Certificate#isExpired([when])</span></h2>
<p>Tests whether the Certificate is currently expired (i.e. the <span class="tt">validFrom</span> and <span class="tt">validUntil</span> dates specify a range of time that does not include the current time).</p>
<p>Parameters</p>
<ul>
<li><span class="tt">when</span> &ndash; optional Date, if specified, tests whether the Certificate was or will be expired at the specified time instead of now</li>
</ul>
<p>Returns a Boolean.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13103"></a>
<span class="tt">Certificate#isSignedByKey(key)</span></h2>
<p>Tests whether the Certificate was validly signed by the given (public) Key.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">key</span> &ndash; a Key instance</li>
</ul>
<p>Returns a Boolean.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13104"></a>
<span class="tt">Certificate#isSignedBy(certificate)</span></h2>
<p>Tests whether this Certificate was validly signed by the subject of the given certificate. Also tests that the issuer Identity of this Certificate and the subject Identity of the other Certificate are equivalent.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">certificate</span> &ndash; another Certificate instance</li>
</ul>
<p>Returns a Boolean.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13105"></a>
<span class="tt">Certificate#fingerprint([hashAlgo])</span></h2>
<p>Returns the X509-style fingerprint of the entire certificate (as a Fingerprint instance). This matches what a web-browser or similar would display as the certificate fingerprint and should not be confused with the fingerprint of the subject's public key.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">hashAlgo</span> &ndash; an optional String, any hash function name</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13106"></a>
<span class="tt">Certificate#toBuffer([format])</span></h2>
<p>Serializes the Certificate to a Buffer and returns it.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">format</span> &ndash; an optional String, output format, one of &lsquo;'openssh&rsquo;<span class="tt">, </span>'pem'<span class="tt"> or
               </span>'x509'<span class="tt">. Defaults to </span>'x509'`.</li>
</ul>
<p>Returns a Buffer.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13107"></a>
<span class="tt">Certificate#toString([format])</span></h2>
<ul>
<li><span class="tt">format</span> &ndash; an optional String, output format, one of &lsquo;'openssh&rsquo;<span class="tt">, </span>'pem'<span class="tt"> or
               </span>'x509'<span class="tt">. Defaults to </span>'pem'`.</li>
</ul>
<p>Returns a String.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md13108"></a>
Certificate identities</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13109"></a>
<span class="tt">identityForHost(hostname)</span></h2>
<p>Constructs a host-type Identity for a given hostname.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">hostname</span> &ndash; the fully qualified DNS name of the host</li>
</ul>
<p>Returns an Identity instance.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13110"></a>
<span class="tt">identityForUser(uid)</span></h2>
<p>Constructs a user-type Identity for a given UID.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">uid</span> &ndash; a String, user identifier (login name)</li>
</ul>
<p>Returns an Identity instance.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13111"></a>
<span class="tt">identityForEmail(email)</span></h2>
<p>Constructs an email-type Identity for a given email address.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">email</span> &ndash; a String, email address</li>
</ul>
<p>Returns an Identity instance.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13112"></a>
<span class="tt">identityFromDN(dn)</span></h2>
<p>Parses an LDAP-style DN string (e.g. &lsquo;'CN=foo, C=US&rsquo;`) and turns it into an Identity instance.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">dn</span> &ndash; a String</li>
</ul>
<p>Returns an Identity instance.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13113"></a>
<span class="tt">identityFromArray(arr)</span></h2>
<p>Constructs an Identity from an array of DN components (see <span class="tt">Identity#toArray()</span> for the format).</p>
<p>Parameters</p>
<ul>
<li><span class="tt">arr</span> &ndash; an Array of Objects, DN components with <span class="tt">name</span> and <span class="tt">value</span></li>
</ul>
<p>Returns an Identity instance.</p>
<p>Supported attributes in DNs:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Attribute name  </th><th class="markdownTableHeadNone">OID  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">cn</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.3</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">o</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.10</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">ou</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.11</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">l</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.7</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">s</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.8</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">c</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.6</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">sn</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.4</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">postalCode</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.17</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">serialNumber</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.5</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">street</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.9</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">x500UniqueIdentifier</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.45</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">role</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.72</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">telephoneNumber</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.20</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">description</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.13</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">dc</span>  </td><td class="markdownTableBodyNone"><span class="tt">0.9.2342.19200300.100.1.25</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">uid</span>  </td><td class="markdownTableBodyNone"><span class="tt">0.9.2342.19200300.100.1.1</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">mail</span>  </td><td class="markdownTableBodyNone"><span class="tt">0.9.2342.19200300.100.1.3</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">title</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.12</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">gn</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.42</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">initials</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.43</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">pseudonym</span>  </td><td class="markdownTableBodyNone"><span class="tt">2.5.4.65</span>  </td></tr>
</table>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13114"></a>
<span class="tt">Identity#toString()</span></h2>
<p>Returns the identity as an LDAP-style DN string. e.g. &lsquo;'CN=foo, O=bar corp, C=us&rsquo;`</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13115"></a>
<span class="tt">Identity#type</span></h2>
<p>The type of identity. One of &lsquo;'host&rsquo;<span class="tt">, </span>'user'<span class="tt">, </span>'email'<span class="tt"> or </span>'unknown'`</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13116"></a>
<span class="tt">Identity#hostname</span></h2>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13117"></a>
<span class="tt">Identity#uid</span></h2>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13118"></a>
<span class="tt">Identity#email</span></h2>
<p>Set when <span class="tt">type</span> is &lsquo;'host&rsquo;<span class="tt">, </span>'user'<span class="tt">, or </span>'email'`, respectively. Strings.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13119"></a>
<span class="tt">Identity#cn</span></h2>
<p>The value of the first <span class="tt">CN=</span> in the DN, if any. It's probably better to use the <span class="tt">#get()</span> method instead of this property.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13120"></a>
<span class="tt">Identity#get(name[, asArray])</span></h2>
<p>Returns the value of a named attribute in the Identity DN. If there is no attribute of the given name, returns <span class="tt">undefined</span>. If multiple components of the DN contain an attribute of this name, an exception is thrown unless the <span class="tt">asArray</span> argument is given as <span class="tt">true</span> &ndash; then they will be returned as an Array in the same order they appear in the DN.</p>
<p>Parameters</p>
<ul>
<li><span class="tt">name</span> &ndash; a String</li>
<li><span class="tt">asArray</span> &ndash; an optional Boolean</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13121"></a>
<span class="tt">Identity#toArray()</span></h2>
<p>Returns the Identity as an Array of DN component objects. This looks like:</p>
<div class="fragment"><div class="line">[ {</div>
<div class="line">  &quot;name&quot;: &quot;cn&quot;,</div>
<div class="line">  &quot;value&quot;: &quot;Joe Bloggs&quot;</div>
<div class="line">},</div>
<div class="line">{</div>
<div class="line">  &quot;name&quot;: &quot;o&quot;,</div>
<div class="line">  &quot;value&quot;: &quot;Organisation Ltd&quot;</div>
<div class="line">} ]</div>
</div><!-- fragment --><p>Each object has a <span class="tt">name</span> and a <span class="tt">value</span> property. The returned objects may be safely modified.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md13122"></a>
Errors</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13123"></a>
<span class="tt">InvalidAlgorithmError</span></h2>
<p>The specified algorithm is not valid, either because it is not supported, or because it was not included on a list of allowed algorithms.</p>
<p>Thrown by <span class="tt">Fingerprint.parse</span>, <span class="tt">Key#fingerprint</span>.</p>
<p>Properties</p>
<ul>
<li><span class="tt">algorithm</span> &ndash; the algorithm that could not be validated</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13124"></a>
<span class="tt">FingerprintFormatError</span></h2>
<p>The fingerprint string given could not be parsed as a supported fingerprint format, or the specified fingerprint format is invalid.</p>
<p>Thrown by <span class="tt">Fingerprint.parse</span>, <span class="tt">Fingerprint#toString</span>.</p>
<p>Properties</p>
<ul>
<li><span class="tt">fingerprint</span> &ndash; if caused by a fingerprint, the string value given</li>
<li><span class="tt">format</span> &ndash; if caused by an invalid format specification, the string value given</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13125"></a>
<span class="tt">KeyParseError</span></h2>
<p>The key data given could not be parsed as a valid key.</p>
<p>Properties</p>
<ul>
<li><span class="tt">keyName</span> &ndash; <span class="tt">filename</span> that was given to <span class="tt">parseKey</span></li>
<li><span class="tt">format</span> &ndash; the <span class="tt">format</span> that was trying to parse the key (see <span class="tt">parseKey</span>)</li>
<li><span class="tt">innerErr</span> &ndash; the inner Error thrown by the format parser</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13126"></a>
<span class="tt">KeyEncryptedError</span></h2>
<p>The key is encrypted with a symmetric key (ie, it is password protected). The parsing operation would succeed if it was given the <span class="tt">passphrase</span> option.</p>
<p>Properties</p>
<ul>
<li><span class="tt">keyName</span> &ndash; <span class="tt">filename</span> that was given to <span class="tt">parseKey</span></li>
<li><span class="tt">format</span> &ndash; the <span class="tt">format</span> that was trying to parse the key (currently can only be <span class="tt">"pem"</span>)</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13127"></a>
<span class="tt">CertificateParseError</span></h2>
<p>The certificate data given could not be parsed as a valid certificate.</p>
<p>Properties</p>
<ul>
<li><span class="tt">certName</span> &ndash; <span class="tt">filename</span> that was given to <span class="tt">parseCertificate</span></li>
<li><span class="tt">format</span> &ndash; the <span class="tt">format</span> that was trying to parse the key (see <span class="tt">parseCertificate</span>)</li>
<li><span class="tt">innerErr</span> &ndash; the inner Error thrown by the format parser</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md13128"></a>
Friends of sshpk</h1>
<ul>
<li><a href="https://github.com/arekinath/node-sshpk-agent"><span class="tt">sshpk-agent</span></a> is a library for speaking the <span class="tt">ssh-agent</span> protocol from node.js, which uses <span class="tt">sshpk</span> </li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_8983b1862dce8a71846356b6209105f4.html">EcoEats-Project</a></li><li class="navelem"><a href="dir_5091f2b68170d33f954320199e2fed0a.html">node_modules</a></li><li class="navelem"><a href="dir_4da34288cfb7e0b9f48f6d52e222b497.html">sshpk</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
