<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/minipass Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_6daff1275079ed755d97059af641b523.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">minipass Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for minipass:</div>
<div class="dyncontent">
<div class="center"><img src="dir_6daff1275079ed755d97059af641b523_dep.png" border="0" usemap="#adir__6daff1275079ed755d97059af641b523__dep" loading="lazy" alt="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/minipass"/></div>
</div>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9755"></a>
minipass</h1>
<p>A <em>very</em> minimal implementation of a <a href="https://nodejs.org/api/stream.html#stream_class_stream_passthrough">PassThrough stream</a></p>
<p><a href="https://docs.google.com/spreadsheets/d/1K_HR5oh3r80b8WVMWCPPjfuWXUgfkmhlX7FGI6JJ8tY/edit?usp=sharing">It's very fast</a> for objects, strings, and buffers.</p>
<p>Supports <span class="tt">pipe()</span>ing (including multi-<span class="tt">pipe()</span> and backpressure transmission), buffering data until either a <span class="tt">data</span> event handler or <span class="tt">pipe()</span> is added (so you don't lose the first chunk), and most other cases where PassThrough is a good idea.</p>
<p>There is a <span class="tt">read()</span> method, but it's much more efficient to consume data from this stream via &lsquo;'data&rsquo;<span class="tt"> events or by calling
</span>pipe()<span class="tt"> into some other stream. Calling </span>read()` requires the buffer to be flattened in some cases, which requires copying memory.</p>
<p>If you set <span class="tt">objectMode: true</span> in the options, then whatever is written will be emitted. Otherwise, it'll do a minimal amount of Buffer copying to ensure proper Streams semantics when <span class="tt">read(n)</span> is called.</p>
<p><span class="tt">objectMode</span> can only be set at instantiation. Attempting to write something other than a String or Buffer without having set <span class="tt">objectMode</span> in the options will throw an error.</p>
<p>This is not a <span class="tt">through</span> or <span class="tt">through2</span> stream. It doesn't transform the data, it just passes it right through. If you want to transform the data, extend the class, and override the <span class="tt">write()</span> method. Once you're done transforming the data however you want, call <span class="tt">super.write()</span> with the transform output.</p>
<p>For some examples of streams that extend Minipass in various ways, check out:</p>
<ul>
<li><a href="http://npm.im/minizlib">minizlib</a></li>
<li><a href="http://npm.im/fs-minipass">fs-minipass</a></li>
<li><a href="http://npm.im/tar">tar</a></li>
<li><a href="http://npm.im/minipass-collect">minipass-collect</a></li>
<li><a href="http://npm.im/minipass-flush">minipass-flush</a></li>
<li><a href="http://npm.im/minipass-pipeline">minipass-pipeline</a></li>
<li><a href="http://npm.im/tap">tap</a></li>
<li><a href="http://npm.im/tap-parser">tap-parser</a></li>
<li><a href="http://npm.im/treport">treport</a></li>
<li><a href="http://npm.im/minipass-fetch">minipass-fetch</a></li>
<li><a href="http://npm.im/pacote">pacote</a></li>
<li><a href="http://npm.im/make-fetch-happen">make-fetch-happen</a></li>
<li><a href="http://npm.im/cacache">cacache</a></li>
<li><a href="http://npm.im/ssri">ssri</a></li>
<li><a href="http://npm.im/npm-registry-fetch">npm-registry-fetch</a></li>
<li><a href="http://npm.im/minipass-json-stream">minipass-json-stream</a></li>
<li><a href="http://npm.im/minipass-sized">minipass-sized</a></li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9756"></a>
Usage in TypeScript</h1>
<p>The <span class="tt">Minipass</span> class takes three type template definitions:</p>
<ul>
<li><span class="tt">RType</span> the type being read, which defaults to <span class="tt">Buffer</span>. If <span class="tt">RType</span> is <span class="tt">string</span>, then the constructor <em>must</em> get an options object specifying either an <span class="tt">encoding</span> or <span class="tt">objectMode: true</span>. If it's anything other than <span class="tt">string</span> or <span class="tt">Buffer</span>, then it <em>must</em> get an options object specifying <span class="tt">objectMode: true</span>.</li>
<li><span class="tt">WType</span> the type being written. If <span class="tt">RType</span> is <span class="tt">Buffer</span> or <span class="tt">string</span>, then this defaults to <span class="tt">ContiguousData</span> (Buffer, string, ArrayBuffer, or ArrayBufferView). Otherwise, it defaults to <span class="tt">RType</span>.</li>
<li><span class="tt">Events</span> type mapping event names to the arguments emitted with that event, which extends <span class="tt">Minipass.Events</span>.</li>
</ul>
<p>To declare types for custom events in subclasses, extend the third parameter with your own event signatures. For example:</p>
<div class="fragment"><div class="line">import { Minipass } from &#39;minipass&#39;</div>
<div class="line"> </div>
<div class="line">// a NDJSON stream that emits &#39;jsonError&#39; when it can&#39;t stringify</div>
<div class="line">export interface Events extends Minipass.Events {</div>
<div class="line">  jsonError: [e: Error]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">export class NDJSONStream extends Minipass&lt;string, any, Events&gt; {</div>
<div class="line">  constructor() {</div>
<div class="line">    super({ objectMode: true })</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // data is type `any` because that&#39;s WType</div>
<div class="line">  write(data, encoding, cb) {</div>
<div class="line">    try {</div>
<div class="line">      const json = JSON.stringify(data)</div>
<div class="line">      return super.write(json + &#39;\n&#39;, encoding, cb)</div>
<div class="line">    } catch (er) {</div>
<div class="line">      if (!er instanceof Error) {</div>
<div class="line">        er = Object.assign(new Error(&#39;json stringify failed&#39;), {</div>
<div class="line">          cause: er,</div>
<div class="line">        })</div>
<div class="line">      }</div>
<div class="line">      // trying to emit with something OTHER than an error will</div>
<div class="line">      // fail, because we declared the event arguments type.</div>
<div class="line">      this.emit(&#39;jsonError&#39;, er)</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const s = new NDJSONStream()</div>
<div class="line">s.on(&#39;jsonError&#39;, e =&gt; {</div>
<div class="line">  // here, TS knows that e is an Error</div>
<div class="line">})</div>
</div><!-- fragment --><p>Emitting/handling events that aren't declared in this way is fine, but the arguments will be typed as <span class="tt">unknown</span>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9757"></a>
Differences from Node.js Streams</h1>
<p>There are several things that make Minipass streams different from (and in some ways superior to) Node.js core streams.</p>
<p>Please read these caveats if you are familiar with node-core streams and intend to use Minipass streams in your programs.</p>
<p>You can avoid most of these differences entirely (for a very small performance penalty) by setting <span class="tt">{async: true}</span> in the constructor options.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9758"></a>
Timing</h2>
<p>Minipass streams are designed to support synchronous use-cases. Thus, data is emitted as soon as it is available, always. It is buffered until read, but no longer. Another way to look at it is that Minipass streams are exactly as synchronous as the logic that writes into them.</p>
<p>This can be surprising if your code relies on <span class="tt">PassThrough.write()</span> always providing data on the next tick rather than the current one, or being able to call <span class="tt">resume()</span> and not have the entire buffer disappear immediately.</p>
<p>However, without this synchronicity guarantee, there would be no way for Minipass to achieve the speeds it does, or support the synchronous use cases that it does. Simply put, waiting takes time.</p>
<p>This non-deferring approach makes Minipass streams much easier to reason about, especially in the context of Promises and other flow-control mechanisms.</p>
<p>Example:</p>
<div class="fragment"><div class="line">// hybrid module, either works</div>
<div class="line">import { Minipass } from &#39;minipass&#39;</div>
<div class="line">// or:</div>
<div class="line">const { Minipass } = require(&#39;minipass&#39;)</div>
<div class="line"> </div>
<div class="line">const stream = new Minipass()</div>
<div class="line">stream.on(&#39;data&#39;, () =&gt; console.log(&#39;data event&#39;))</div>
<div class="line">console.log(&#39;before write&#39;)</div>
<div class="line">stream.write(&#39;hello&#39;)</div>
<div class="line">console.log(&#39;after write&#39;)</div>
<div class="line">// output:</div>
<div class="line">// before write</div>
<div class="line">// data event</div>
<div class="line">// after write</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9759"></a>
Exception: Async Opt-In</h2>
<p>If you wish to have a Minipass stream with behavior that more closely mimics Node.js core streams, you can set the stream in async mode either by setting <span class="tt">async: true</span> in the constructor options, or by setting <span class="tt">stream.async = true</span> later on.</p>
<div class="fragment"><div class="line">// hybrid module, either works</div>
<div class="line">import { Minipass } from &#39;minipass&#39;</div>
<div class="line">// or:</div>
<div class="line">const { Minipass } = require(&#39;minipass&#39;)</div>
<div class="line"> </div>
<div class="line">const asyncStream = new Minipass({ async: true })</div>
<div class="line">asyncStream.on(&#39;data&#39;, () =&gt; console.log(&#39;data event&#39;))</div>
<div class="line">console.log(&#39;before write&#39;)</div>
<div class="line">asyncStream.write(&#39;hello&#39;)</div>
<div class="line">console.log(&#39;after write&#39;)</div>
<div class="line">// output:</div>
<div class="line">// before write</div>
<div class="line">// after write</div>
<div class="line">// data event &lt;-- this is deferred until the next tick</div>
</div><!-- fragment --><p>Switching <em>out</em> of async mode is unsafe, as it could cause data corruption, and so is not enabled. Example:</p>
<div class="fragment"><div class="line">import { Minipass } from &#39;minipass&#39;</div>
<div class="line">const stream = new Minipass({ encoding: &#39;utf8&#39; })</div>
<div class="line">stream.on(&#39;data&#39;, chunk =&gt; console.log(chunk))</div>
<div class="line">stream.async = true</div>
<div class="line">console.log(&#39;before writes&#39;)</div>
<div class="line">stream.write(&#39;hello&#39;)</div>
<div class="line">setStreamSyncAgainSomehow(stream) // &lt;-- this doesn&#39;t actually exist!</div>
<div class="line">stream.write(&#39;world&#39;)</div>
<div class="line">console.log(&#39;after writes&#39;)</div>
<div class="line">// hypothetical output would be:</div>
<div class="line">// before writes</div>
<div class="line">// world</div>
<div class="line">// after writes</div>
<div class="line">// hello</div>
<div class="line">// NOT GOOD!</div>
</div><!-- fragment --><p>To avoid this problem, once set into async mode, any attempt to make the stream sync again will be ignored.</p>
<div class="fragment"><div class="line">const { Minipass } = require(&#39;minipass&#39;)</div>
<div class="line">const stream = new Minipass({ encoding: &#39;utf8&#39; })</div>
<div class="line">stream.on(&#39;data&#39;, chunk =&gt; console.log(chunk))</div>
<div class="line">stream.async = true</div>
<div class="line">console.log(&#39;before writes&#39;)</div>
<div class="line">stream.write(&#39;hello&#39;)</div>
<div class="line">stream.async = false // &lt;-- no-op, stream already async</div>
<div class="line">stream.write(&#39;world&#39;)</div>
<div class="line">console.log(&#39;after writes&#39;)</div>
<div class="line">// actual output:</div>
<div class="line">// before writes</div>
<div class="line">// after writes</div>
<div class="line">// hello</div>
<div class="line">// world</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9760"></a>
No High/Low Water Marks</h2>
<p>Node.js core streams will optimistically fill up a buffer, returning <span class="tt">true</span> on all writes until the limit is hit, even if the data has nowhere to go. Then, they will not attempt to draw more data in until the buffer size dips below a minimum value.</p>
<p>Minipass streams are much simpler. The <span class="tt">write()</span> method will return <span class="tt">true</span> if the data has somewhere to go (which is to say, given the timing guarantees, that the data is already there by the time <span class="tt">write()</span> returns).</p>
<p>If the data has nowhere to go, then <span class="tt">write()</span> returns false, and the data sits in a buffer, to be drained out immediately as soon as anyone consumes it.</p>
<p>Since nothing is ever buffered unnecessarily, there is much less copying data, and less bookkeeping about buffer capacity levels.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9761"></a>
Hazards of Buffering (or: Why Minipass Is So Fast)</h2>
<p>Since data written to a Minipass stream is immediately written all the way through the pipeline, and <span class="tt">write()</span> always returns true/false based on whether the data was fully flushed, backpressure is communicated immediately to the upstream caller. This minimizes buffering.</p>
<p>Consider this case:</p>
<div class="fragment"><div class="line">const { PassThrough } = require(&#39;stream&#39;)</div>
<div class="line">const p1 = new PassThrough({ highWaterMark: 1024 })</div>
<div class="line">const p2 = new PassThrough({ highWaterMark: 1024 })</div>
<div class="line">const p3 = new PassThrough({ highWaterMark: 1024 })</div>
<div class="line">const p4 = new PassThrough({ highWaterMark: 1024 })</div>
<div class="line"> </div>
<div class="line">p1.pipe(p2).pipe(p3).pipe(p4)</div>
<div class="line">p4.on(&#39;data&#39;, () =&gt; console.log(&#39;made it through&#39;))</div>
<div class="line"> </div>
<div class="line">// this returns false and buffers, then writes to p2 on next tick (1)</div>
<div class="line">// p2 returns false and buffers, pausing p1, then writes to p3 on next tick (2)</div>
<div class="line">// p3 returns false and buffers, pausing p2, then writes to p4 on next tick (3)</div>
<div class="line">// p4 returns false and buffers, pausing p3, then emits &#39;data&#39; and &#39;drain&#39;</div>
<div class="line">// on next tick (4)</div>
<div class="line">// p3 sees p4&#39;s &#39;drain&#39; event, and calls resume(), emitting &#39;resume&#39; and</div>
<div class="line">// &#39;drain&#39; on next tick (5)</div>
<div class="line">// p2 sees p3&#39;s &#39;drain&#39;, calls resume(), emits &#39;resume&#39; and &#39;drain&#39; on next tick (6)</div>
<div class="line">// p1 sees p2&#39;s &#39;drain&#39;, calls resume(), emits &#39;resume&#39; and &#39;drain&#39; on next</div>
<div class="line">// tick (7)</div>
<div class="line"> </div>
<div class="line">p1.write(Buffer.alloc(2048)) // returns false</div>
</div><!-- fragment --><p>Along the way, the data was buffered and deferred at each stage, and multiple event deferrals happened, for an unblocked pipeline where it was perfectly safe to write all the way through!</p>
<p>Furthermore, setting a <span class="tt">highWaterMark</span> of <span class="tt">1024</span> might lead someone reading the code to think an advisory maximum of 1KiB is being set for the pipeline. However, the actual advisory buffering level is the <em>sum</em> of <span class="tt">highWaterMark</span> values, since each one has its own bucket.</p>
<p>Consider the Minipass case:</p>
<div class="fragment"><div class="line">const m1 = new Minipass()</div>
<div class="line">const m2 = new Minipass()</div>
<div class="line">const m3 = new Minipass()</div>
<div class="line">const m4 = new Minipass()</div>
<div class="line"> </div>
<div class="line">m1.pipe(m2).pipe(m3).pipe(m4)</div>
<div class="line">m4.on(&#39;data&#39;, () =&gt; console.log(&#39;made it through&#39;))</div>
<div class="line"> </div>
<div class="line">// m1 is flowing, so it writes the data to m2 immediately</div>
<div class="line">// m2 is flowing, so it writes the data to m3 immediately</div>
<div class="line">// m3 is flowing, so it writes the data to m4 immediately</div>
<div class="line">// m4 is flowing, so it fires the &#39;data&#39; event immediately, returns true</div>
<div class="line">// m4&#39;s write returned true, so m3 is still flowing, returns true</div>
<div class="line">// m3&#39;s write returned true, so m2 is still flowing, returns true</div>
<div class="line">// m2&#39;s write returned true, so m1 is still flowing, returns true</div>
<div class="line">// No event deferrals or buffering along the way!</div>
<div class="line"> </div>
<div class="line">m1.write(Buffer.alloc(2048)) // returns true</div>
</div><!-- fragment --><p>It is extremely unlikely that you <em>don't</em> want to buffer any data written, or <em>ever</em> buffer data that can be flushed all the way through. Neither node-core streams nor Minipass ever fail to buffer written data, but node-core streams do a lot of unnecessary buffering and pausing.</p>
<p>As always, the faster implementation is the one that does less stuff and waits less time to do it.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9762"></a>
Immediately emit <span class="tt">end</span> for empty streams (when not paused)</h2>
<p>If a stream is not paused, and <span class="tt">end()</span> is called before writing any data into it, then it will emit <span class="tt">end</span> immediately.</p>
<p>If you have logic that occurs on the <span class="tt">end</span> event which you don't want to potentially happen immediately (for example, closing file descriptors, moving on to the next entry in an archive parse stream, etc.) then be sure to call <span class="tt">stream.pause()</span> on creation, and then <span class="tt">stream.resume()</span> once you are ready to respond to the <span class="tt">end</span> event.</p>
<p>However, this is <em>usually</em> not a problem because:</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9763"></a>
Emit <span class="tt">end</span> When Asked</h2>
<p>One hazard of immediately emitting &lsquo;'end&rsquo;<span class="tt"> is that you may not
yet have had a chance to add a listener. In order to avoid this
hazard, Minipass streams safely re-emit the </span>'end'<span class="tt"> event if a
new listener is added after </span>'end'` has been emitted.</p>
<p>Ie, if you do &lsquo;stream.on('end&rsquo;, someFunction)<span class="tt">, and the stream
has already emitted </span>end<span class="tt">, then it will call the handler right
away. (You can think of this somewhat like attaching a new
</span>.then(fn)` to a previously-resolved Promise.)</p>
<p>To prevent calling handlers multiple times who would not expect multiple ends to occur, all listeners are removed from the &lsquo;'end&rsquo;` event whenever it is emitted.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9764"></a>
Emit <span class="tt">error</span> When Asked</h2>
<p>The most recent error object passed to the &lsquo;'error&rsquo;<span class="tt"> event is
stored on the stream. If a new </span>'error'<span class="tt"> event handler is added,
and an error was previously emitted, then the event handler will
be called immediately (or on </span>process.nextTick` in the case of async streams).</p>
<p>This makes it much more difficult to end up trying to interact with a broken stream, if the error handler is added after an error was previously emitted.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9765"></a>
Impact of "immediate flow" on Tee-streams</h2>
<p>A "tee stream" is a stream piping to multiple destinations:</p>
<div class="fragment"><div class="line">const tee = new Minipass()</div>
<div class="line">t.pipe(dest1)</div>
<div class="line">t.pipe(dest2)</div>
<div class="line">t.write(&#39;foo&#39;) // goes to both destinations</div>
</div><!-- fragment --><p>Since Minipass streams <em>immediately</em> process any pending data through the pipeline when a new pipe destination is added, this can have surprising effects, especially when a stream comes in from some other function and may or may not have data in its buffer.</p>
<div class="fragment"><div class="line">// WARNING! WILL LOSE DATA!</div>
<div class="line">const src = new Minipass()</div>
<div class="line">src.write(&#39;foo&#39;)</div>
<div class="line">src.pipe(dest1) // &#39;foo&#39; chunk flows to dest1 immediately, and is gone</div>
<div class="line">src.pipe(dest2) // gets nothing!</div>
</div><!-- fragment --><p>One solution is to create a dedicated tee-stream junction that pipes to both locations, and then pipe to <em>that</em> instead.</p>
<div class="fragment"><div class="line">// Safe example: tee to both places</div>
<div class="line">const src = new Minipass()</div>
<div class="line">src.write(&#39;foo&#39;)</div>
<div class="line">const tee = new Minipass()</div>
<div class="line">tee.pipe(dest1)</div>
<div class="line">tee.pipe(dest2)</div>
<div class="line">src.pipe(tee) // tee gets &#39;foo&#39;, pipes to both locations</div>
</div><!-- fragment --><p>The same caveat applies to &lsquo;on('data&rsquo;)` event listeners. The first one added will <em>immediately</em> receive all of the data, leaving nothing for the second:</p>
<div class="fragment"><div class="line">// WARNING! WILL LOSE DATA!</div>
<div class="line">const src = new Minipass()</div>
<div class="line">src.write(&#39;foo&#39;)</div>
<div class="line">src.on(&#39;data&#39;, handler1) // receives &#39;foo&#39; right away</div>
<div class="line">src.on(&#39;data&#39;, handler2) // nothing to see here!</div>
</div><!-- fragment --><p>Using a dedicated tee-stream can be used in this case as well:</p>
<div class="fragment"><div class="line">// Safe example: tee to both data handlers</div>
<div class="line">const src = new Minipass()</div>
<div class="line">src.write(&#39;foo&#39;)</div>
<div class="line">const tee = new Minipass()</div>
<div class="line">tee.on(&#39;data&#39;, handler1)</div>
<div class="line">tee.on(&#39;data&#39;, handler2)</div>
<div class="line">src.pipe(tee)</div>
</div><!-- fragment --><p>All of the hazards in this section are avoided by setting <span class="tt">{
async: true }</span> in the Minipass constructor, or by setting <span class="tt">stream.async = true</span> afterwards. Note that this does add some overhead, so should only be done in cases where you are willing to lose a bit of performance in order to avoid having to refactor program logic.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9766"></a>
USAGE</h1>
<p>It's a stream! Use it like a stream and it'll most likely do what you want.</p>
<div class="fragment"><div class="line">import { Minipass } from &#39;minipass&#39;</div>
<div class="line">const mp = new Minipass(options) // options is optional</div>
<div class="line">mp.write(&#39;foo&#39;)</div>
<div class="line">mp.pipe(someOtherStream)</div>
<div class="line">mp.end(&#39;bar&#39;)</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9767"></a>
OPTIONS</h2>
<ul>
<li><span class="tt">encoding</span> How would you like the data coming <em>out</em> of the stream to be encoded? Accepts any values that can be passed to <span class="tt">Buffer.toString()</span>.</li>
<li><span class="tt">objectMode</span> Emit data exactly as it comes in. This will be flipped on by default if you write() something other than a string or Buffer at any point. Setting <span class="tt">objectMode: true</span> will prevent setting any encoding value.</li>
<li><span class="tt">async</span> Defaults to <span class="tt">false</span>. Set to <span class="tt">true</span> to defer data emission until next tick. This reduces performance slightly, but makes Minipass streams use timing behavior closer to Node core streams. See Timing for more details.</li>
<li><span class="tt">signal</span> An <span class="tt">AbortSignal</span> that will cause the stream to unhook itself from everything and become as inert as possible. Note that providing a <span class="tt">signal</span> parameter will make &lsquo;'error&rsquo;` events no longer throw if they are unhandled, but they will still be emitted to handlers if any are attached.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9768"></a>
API</h2>
<p>Implements the user-facing portions of Node.js's <span class="tt">Readable</span> and <span class="tt">Writable</span> streams.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9769"></a>
Methods</h2>
<ul>
<li><span class="tt">write(chunk, [encoding], [callback])</span> - Put data in. (Note that, in the base Minipass class, the same data will come out.) Returns <span class="tt">false</span> if the stream will buffer the next write, or true if it's still in "flowing" mode.</li>
<li><span class="tt">end([chunk, [encoding]], [callback])</span> - Signal that you have no more data to write. This will queue an <span class="tt">end</span> event to be fired when all the data has been consumed.</li>
<li><span class="tt">pause()</span> - No more data for a while, please. This also prevents <span class="tt">end</span> from being emitted for empty streams until the stream is resumed.</li>
<li><span class="tt">resume()</span> - Resume the stream. If there's data in the buffer, it is all discarded. Any buffered events are immediately emitted.</li>
<li><span class="tt">pipe(dest)</span> - Send all output to the stream provided. When data is emitted, it is immediately written to any and all pipe destinations. (Or written on next tick in <span class="tt">async</span> mode.)</li>
<li><span class="tt">unpipe(dest)</span> - Stop piping to the destination stream. This is immediate, meaning that any asynchronously queued data will <em>not</em> make it to the destination when running in <span class="tt">async</span> mode.<ul>
<li><span class="tt">options.end</span> - Boolean, end the destination stream when the source stream ends. Default <span class="tt">true</span>.</li>
<li><span class="tt">options.proxyErrors</span> - Boolean, proxy <span class="tt">error</span> events from the source stream to the destination stream. Note that errors are <em>not</em> proxied after the pipeline terminates, either due to the source emitting &lsquo;'end&rsquo;<span class="tt"> or manually unpiping with
    </span>src.unpipe(dest)<span class="tt">. Default </span>false<span class="tt">.</span></li>
</ul>
</li>
<li><span class="tt"></span>on(ev, fn)<span class="tt">, </span>emit(ev, fn)<span class="tt"> - Minipass streams are
  EventEmitters. Some events are given special treatment,
  however. (See below under "events".)</span></li>
<li><span class="tt"></span>promise()<span class="tt"> - Returns a Promise that resolves when the stream
  emits </span>end<span class="tt">, or rejects if the stream emits </span>error<span class="tt">.</span></li>
<li><span class="tt"></span>collect()<span class="tt"> - Return a Promise that resolves on </span>end<span class="tt"> with an
  array containing each chunk of data that was emitted, or
  rejects if the stream emits </span>error<span class="tt">. Note that this consumes
  the stream data.</span></li>
<li><span class="tt"></span>concat()<span class="tt"> - Same as </span>collect()<span class="tt">, but concatenates the data
  into a single Buffer object. Will reject the returned promise
  if the stream is in objectMode, or if it goes into objectMode
  by the end of the data.</span></li>
<li><span class="tt"></span>read(n)<span class="tt"> - Consume </span>n<span class="tt"> bytes of data out of the buffer. If </span>n<span class="tt">
  is not provided, then consume all of it. If </span>n<span class="tt"> bytes are not
  available, then it returns null. **Note** consuming streams in
  this way is less efficient, and can lead to unnecessary Buffer
  copying.</span></li>
<li><span class="tt"></span>destroy([er])<span class="tt"> - Destroy the stream. If an error is provided,
  then an </span>'error'<span class="tt"> event is emitted. If the stream has a
  </span>close()<span class="tt"> method, and has not emitted a </span>'close'<span class="tt"> event yet,
  then </span>stream.close()<span class="tt"> will be called. Any Promises returned by
  </span>.promise()<span class="tt">, </span>.collect()<span class="tt"> or </span>.concat()` will be rejected. After being destroyed, writing to the stream will emit an error. No more data will be emitted if the stream is destroyed, even if it was previously buffered.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9770"></a>
Properties</h2>
<ul>
<li><span class="tt">bufferLength</span> Read-only. Total number of bytes buffered, or in the case of objectMode, the total number of objects.</li>
<li><span class="tt">encoding</span> Read-only. The encoding that has been set.</li>
<li><span class="tt">flowing</span> Read-only. Boolean indicating whether a chunk written to the stream will be immediately emitted.</li>
<li><span class="tt">emittedEnd</span> Read-only. Boolean indicating whether the end-ish events (ie, <span class="tt">end</span>, <span class="tt">prefinish</span>, <span class="tt">finish</span>) have been emitted. Note that listening on any end-ish event will immediateyl re-emit it if it has already been emitted.</li>
<li><span class="tt">writable</span> Whether the stream is writable. Default <span class="tt">true</span>. Set to <span class="tt">false</span> when <span class="tt">end()</span></li>
<li><span class="tt">readable</span> Whether the stream is readable. Default <span class="tt">true</span>.</li>
<li><span class="tt">pipes</span> An array of Pipe objects referencing streams that this stream is piping into.</li>
<li><span class="tt">destroyed</span> A getter that indicates whether the stream was destroyed.</li>
<li><span class="tt">paused</span> True if the stream has been explicitly paused, otherwise false.</li>
<li><span class="tt">objectMode</span> Indicates whether the stream is in <span class="tt">objectMode</span>.</li>
<li><span class="tt">aborted</span> Readonly property set when the <span class="tt">AbortSignal</span> dispatches an <span class="tt">abort</span> event.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9771"></a>
Events</h2>
<ul>
<li><span class="tt">data</span> Emitted when there's data to read. Argument is the data to read. This is never emitted while not flowing. If a listener is attached, that will resume the stream.</li>
<li><span class="tt">end</span> Emitted when there's no more data to read. This will be emitted immediately for empty streams when <span class="tt">end()</span> is called. If a listener is attached, and <span class="tt">end</span> was already emitted, then it will be emitted again. All listeners are removed when <span class="tt">end</span> is emitted.</li>
<li><span class="tt">prefinish</span> An end-ish event that follows the same logic as <span class="tt">end</span> and is emitted in the same conditions where <span class="tt">end</span> is emitted. Emitted after &lsquo;'end&rsquo;<span class="tt">.</span></li>
<li><span class="tt"></span>finish<span class="tt"> An end-ish event that follows the same logic as </span>end<span class="tt">
  and is emitted in the same conditions where </span>end<span class="tt"> is emitted.
  Emitted after </span>'prefinish'<span class="tt">.</span></li>
<li><span class="tt"></span>close<span class="tt"> An indication that an underlying resource has been
  released. Minipass does not emit this event, but will defer it
  until after </span>end<span class="tt"> has been emitted, since it throws off some
  stream libraries otherwise.</span></li>
<li><span class="tt"></span>drain<span class="tt"> Emitted when the internal buffer empties, and it is
  again suitable to </span>write()<span class="tt"> into the stream.</span></li>
<li><span class="tt"></span>readable<span class="tt"> Emitted when data is buffered and ready to be read
  by a consumer.</span></li>
<li><span class="tt"></span>resume<span class="tt"> Emitted when stream changes state from buffering to
  flowing mode. (Ie, when </span>resume<span class="tt"> is called, </span>pipe<span class="tt"> is called,
  or a </span>data` event listener is added.)</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9772"></a>
Static Methods</h2>
<ul>
<li><span class="tt">Minipass.isStream(stream)</span> Returns <span class="tt">true</span> if the argument is a stream, and false otherwise. To be considered a stream, the object must be either an instance of Minipass, or an EventEmitter that has either a <span class="tt">pipe()</span> method, or both <span class="tt">write()</span> and <span class="tt">end()</span> methods. (Pretty much any stream in node-land will return <span class="tt">true</span> for this.)</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9773"></a>
EXAMPLES</h1>
<p>Here are some examples of things you can do with Minipass streams.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9774"></a>
simple "are you done yet" promise</h2>
<div class="fragment"><div class="line">mp.promise().then(</div>
<div class="line">  () =&gt; {</div>
<div class="line">    // stream is finished</div>
<div class="line">  },</div>
<div class="line">  er =&gt; {</div>
<div class="line">    // stream emitted an error</div>
<div class="line">  }</div>
<div class="line">)</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9775"></a>
collecting</h2>
<div class="fragment"><div class="line">mp.collect().then(all =&gt; {</div>
<div class="line">  // all is an array of all the data emitted</div>
<div class="line">  // encoding is supported in this case, so</div>
<div class="line">  // so the result will be a collection of strings if</div>
<div class="line">  // an encoding is specified, or buffers/objects if not.</div>
<div class="line">  //</div>
<div class="line">  // In an async function, you may do</div>
<div class="line">  // const data = await stream.collect()</div>
<div class="line">})</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9776"></a>
collecting into a single blob</h2>
<p>This is a bit slower because it concatenates the data into one chunk for you, but if you're going to do it yourself anyway, it's convenient this way:</p>
<div class="fragment"><div class="line">mp.concat().then(onebigchunk =&gt; {</div>
<div class="line">  // onebigchunk is a string if the stream</div>
<div class="line">  // had an encoding set, or a buffer otherwise.</div>
<div class="line">})</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9777"></a>
iteration</h2>
<p>You can iterate over streams synchronously or asynchronously in platforms that support it.</p>
<p>Synchronous iteration will end when the currently available data is consumed, even if the <span class="tt">end</span> event has not been reached. In string and buffer mode, the data is concatenated, so unless multiple writes are occurring in the same tick as the <span class="tt">read()</span>, sync iteration loops will generally only have a single iteration.</p>
<p>To consume chunks in this way exactly as they have been written, with no flattening, create the stream with the <span class="tt">{ objectMode:
true }</span> option.</p>
<div class="fragment"><div class="line">const mp = new Minipass({ objectMode: true })</div>
<div class="line">mp.write(&#39;a&#39;)</div>
<div class="line">mp.write(&#39;b&#39;)</div>
<div class="line">for (let letter of mp) {</div>
<div class="line">  console.log(letter) // a, b</div>
<div class="line">}</div>
<div class="line">mp.write(&#39;c&#39;)</div>
<div class="line">mp.write(&#39;d&#39;)</div>
<div class="line">for (let letter of mp) {</div>
<div class="line">  console.log(letter) // c, d</div>
<div class="line">}</div>
<div class="line">mp.write(&#39;e&#39;)</div>
<div class="line">mp.end()</div>
<div class="line">for (let letter of mp) {</div>
<div class="line">  console.log(letter) // e</div>
<div class="line">}</div>
<div class="line">for (let letter of mp) {</div>
<div class="line">  console.log(letter) // nothing</div>
<div class="line">}</div>
</div><!-- fragment --><p>Asynchronous iteration will continue until the end event is reached, consuming all of the data.</p>
<div class="fragment"><div class="line">const mp = new Minipass({ encoding: &#39;utf8&#39; })</div>
<div class="line"> </div>
<div class="line">// some source of some data</div>
<div class="line">let i = 5</div>
<div class="line">const inter = setInterval(() =&gt; {</div>
<div class="line">  if (i-- &gt; 0) mp.write(Buffer.from(&#39;foo\n&#39;, &#39;utf8&#39;))</div>
<div class="line">  else {</div>
<div class="line">    mp.end()</div>
<div class="line">    clearInterval(inter)</div>
<div class="line">  }</div>
<div class="line">}, 100)</div>
<div class="line"> </div>
<div class="line">// consume the data with asynchronous iteration</div>
<div class="line">async function consume() {</div>
<div class="line">  for await (let chunk of mp) {</div>
<div class="line">    console.log(chunk)</div>
<div class="line">  }</div>
<div class="line">  return &#39;ok&#39;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">consume().then(res =&gt; console.log(res))</div>
<div class="line">// logs `foo\n` 5 times, and then `ok`</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9778"></a>
subclass that <span class="tt">console.log()</span>s everything written into it</h2>
<div class="fragment"><div class="line">class Logger extends Minipass {</div>
<div class="line">  write(chunk, encoding, callback) {</div>
<div class="line">    console.log(&#39;WRITE&#39;, chunk, encoding)</div>
<div class="line">    return super.write(chunk, encoding, callback)</div>
<div class="line">  }</div>
<div class="line">  end(chunk, encoding, callback) {</div>
<div class="line">    console.log(&#39;END&#39;, chunk, encoding)</div>
<div class="line">    return super.end(chunk, encoding, callback)</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">someSource.pipe(new Logger()).pipe(someDest)</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9779"></a>
same thing, but using an inline anonymous class</h2>
<div class="fragment"><div class="line">// js classes are fun</div>
<div class="line">someSource</div>
<div class="line">  .pipe(</div>
<div class="line">    new (class extends Minipass {</div>
<div class="line">      emit(ev, ...data) {</div>
<div class="line">        // let&#39;s also log events, because debugging some weird thing</div>
<div class="line">        console.log(&#39;EMIT&#39;, ev)</div>
<div class="line">        return super.emit(ev, ...data)</div>
<div class="line">      }</div>
<div class="line">      write(chunk, encoding, callback) {</div>
<div class="line">        console.log(&#39;WRITE&#39;, chunk, encoding)</div>
<div class="line">        return super.write(chunk, encoding, callback)</div>
<div class="line">      }</div>
<div class="line">      end(chunk, encoding, callback) {</div>
<div class="line">        console.log(&#39;END&#39;, chunk, encoding)</div>
<div class="line">        return super.end(chunk, encoding, callback)</div>
<div class="line">      }</div>
<div class="line">    })()</div>
<div class="line">  )</div>
<div class="line">  .pipe(someDest)</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9780"></a>
subclass that defers 'end' for some reason</h2>
<div class="fragment"><div class="line">class SlowEnd extends Minipass {</div>
<div class="line">  emit(ev, ...args) {</div>
<div class="line">    if (ev === &#39;end&#39;) {</div>
<div class="line">      console.log(&#39;going to end, hold on a sec&#39;)</div>
<div class="line">      setTimeout(() =&gt; {</div>
<div class="line">        console.log(&#39;ok, ready to end now&#39;)</div>
<div class="line">        super.emit(&#39;end&#39;, ...args)</div>
<div class="line">      }, 100)</div>
<div class="line">      return true</div>
<div class="line">    } else {</div>
<div class="line">      return super.emit(ev, ...args)</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9781"></a>
transform that creates newline-delimited JSON</h2>
<div class="fragment"><div class="line">class NDJSONEncode extends Minipass {</div>
<div class="line">  write(obj, cb) {</div>
<div class="line">    try {</div>
<div class="line">      // JSON.stringify can throw, emit an error on that</div>
<div class="line">      return super.write(JSON.stringify(obj) + &#39;\n&#39;, &#39;utf8&#39;, cb)</div>
<div class="line">    } catch (er) {</div>
<div class="line">      this.emit(&#39;error&#39;, er)</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  end(obj, cb) {</div>
<div class="line">    if (typeof obj === &#39;function&#39;) {</div>
<div class="line">      cb = obj</div>
<div class="line">      obj = undefined</div>
<div class="line">    }</div>
<div class="line">    if (obj !== undefined) {</div>
<div class="line">      this.write(obj)</div>
<div class="line">    }</div>
<div class="line">    return super.end(cb)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9782"></a>
transform that parses newline-delimited JSON</h2>
<div class="fragment"><div class="line">class NDJSONDecode extends Minipass {</div>
<div class="line">  constructor(options) {</div>
<div class="line">    // always be in object mode, as far as Minipass is concerned</div>
<div class="line">    super({ objectMode: true })</div>
<div class="line">    this._jsonBuffer = &#39;&#39;</div>
<div class="line">  }</div>
<div class="line">  write(chunk, encoding, cb) {</div>
<div class="line">    if (</div>
<div class="line">      typeof chunk === &#39;string&#39; &amp;&amp;</div>
<div class="line">      typeof encoding === &#39;string&#39; &amp;&amp;</div>
<div class="line">      encoding !== &#39;utf8&#39;</div>
<div class="line">    ) {</div>
<div class="line">      chunk = Buffer.from(chunk, encoding).toString()</div>
<div class="line">    } else if (Buffer.isBuffer(chunk)) {</div>
<div class="line">      chunk = chunk.toString()</div>
<div class="line">    }</div>
<div class="line">    if (typeof encoding === &#39;function&#39;) {</div>
<div class="line">      cb = encoding</div>
<div class="line">    }</div>
<div class="line">    const jsonData = (this._jsonBuffer + chunk).split(&#39;\n&#39;)</div>
<div class="line">    this._jsonBuffer = jsonData.pop()</div>
<div class="line">    for (let i = 0; i &lt; jsonData.length; i++) {</div>
<div class="line">      try {</div>
<div class="line">        // JSON.parse can throw, emit an error on that</div>
<div class="line">        super.write(JSON.parse(jsonData[i]))</div>
<div class="line">      } catch (er) {</div>
<div class="line">        this.emit(&#39;error&#39;, er)</div>
<div class="line">        continue</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    if (cb) cb()</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_8983b1862dce8a71846356b6209105f4.html">EcoEats-Project</a></li><li class="navelem"><a href="dir_5091f2b68170d33f954320199e2fed0a.html">node_modules</a></li><li class="navelem"><a href="dir_6daff1275079ed755d97059af641b523.html">minipass</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
