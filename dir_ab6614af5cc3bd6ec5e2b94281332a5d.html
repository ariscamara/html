<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@cypress/request Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_ab6614af5cc3bd6ec5e2b94281332a5d.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">request Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for request:</div>
<div class="dyncontent">
<div class="center"><img src="dir_ab6614af5cc3bd6ec5e2b94281332a5d_dep.png" border="0" usemap="#adir__ab6614af5cc3bd6ec5e2b94281332a5d__dep" loading="lazy" alt="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/@cypress/request"/></div>
</div>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md539"></a>
@cypress/request - Simplified HTTP client</h1>
<p><a href="https://nodei.co/npm/@cypress/request/"><img src="https://nodei.co/npm/@cypress/request.png?downloads=true&amp;downloadRank=true&amp;stars=true" alt="npm package" class="inline"/></a></p>
<p><b>This is a fork of <a href="https://github.com/request/request"><span class="tt">request</span></a> for use in <a href="https://github.com/cypress-io/cypress">Cypress</a>.</b></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md540"></a>
Super simple to use</h1>
<p>Request is designed to be the simplest way possible to make http calls. It supports HTTPS and follows redirects by default.</p>
<div class="fragment"><div class="line">const request = require(&#39;@cypress/request&#39;);</div>
<div class="line">request(&#39;http://www.google.com&#39;, function (error, response, body) {</div>
<div class="line">  console.error(&#39;error:&#39;, error); // Print the error if one occurred</div>
<div class="line">  console.log(&#39;statusCode:&#39;, response &amp;&amp; response.statusCode); // Print the response status code if a response was received</div>
<div class="line">  console.log(&#39;body:&#39;, body); // Print the HTML for the Google homepage.</div>
<div class="line">});</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md541"></a>
Table of contents</h1>
<ul>
<li>Streaming</li>
<li>Promises &amp; Async/Await</li>
<li>Forms</li>
<li>HTTP Authentication</li>
<li>Custom HTTP Headers</li>
<li>Proxies</li>
<li>Unix Domain Sockets</li>
<li>TLS/SSL Protocol</li>
<li>Support for HAR 1.2</li>
<li>**All Available Options**</li>
</ul>
<p>Request also offers convenience methods like <span class="tt">request.defaults</span> and <span class="tt">request.post</span>, and there are lots of usage examples and several debugging techniques.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md543"></a>
Streaming</h1>
<p>You can stream any response to a file stream.</p>
<div class="fragment"><div class="line">request(&#39;http://google.com/doodle.png&#39;).pipe(fs.createWriteStream(&#39;doodle.png&#39;))</div>
</div><!-- fragment --><p>You can also stream a file to a PUT or POST request. This method will also check the file extension against a mapping of file extensions to content-types (in this case <span class="tt">application/json</span>) and use the proper <span class="tt">content-type</span> in the PUT request (if the headers don’t already provide one).</p>
<div class="fragment"><div class="line">fs.createReadStream(&#39;file.json&#39;).pipe(request.put(&#39;http://mysite.com/obj.json&#39;))</div>
</div><!-- fragment --><p>Request can also <span class="tt">pipe</span> to itself. When doing so, <span class="tt">content-type</span> and <span class="tt">content-length</span> are preserved in the PUT headers.</p>
<div class="fragment"><div class="line">request.get(&#39;http://google.com/img.png&#39;).pipe(request.put(&#39;http://mysite.com/img.png&#39;))</div>
</div><!-- fragment --><p>Request emits a "response" event when a response is received. The <span class="tt">response</span> argument will be an instance of <a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage">http.IncomingMessage</a>.</p>
<div class="fragment"><div class="line">request</div>
<div class="line">  .get(&#39;http://google.com/img.png&#39;)</div>
<div class="line">  .on(&#39;response&#39;, function(response) {</div>
<div class="line">    console.log(response.statusCode) // 200</div>
<div class="line">    console.log(response.headers[&#39;content-type&#39;]) // &#39;image/png&#39;</div>
<div class="line">  })</div>
<div class="line">  .pipe(request.put(&#39;http://mysite.com/img.png&#39;))</div>
</div><!-- fragment --><p>To easily handle errors when streaming requests, listen to the <span class="tt">error</span> event before piping:</p>
<div class="fragment"><div class="line">request</div>
<div class="line">  .get(&#39;http://mysite.com/doodle.png&#39;)</div>
<div class="line">  .on(&#39;error&#39;, function(err) {</div>
<div class="line">    console.error(err)</div>
<div class="line">  })</div>
<div class="line">  .pipe(fs.createWriteStream(&#39;doodle.png&#39;))</div>
</div><!-- fragment --><p>Now let’s get fancy.</p>
<div class="fragment"><div class="line">http.createServer(function (req, resp) {</div>
<div class="line">  if (req.url === &#39;/doodle.png&#39;) {</div>
<div class="line">    if (req.method === &#39;PUT&#39;) {</div>
<div class="line">      req.pipe(request.put(&#39;http://mysite.com/doodle.png&#39;))</div>
<div class="line">    } else if (req.method === &#39;GET&#39; || req.method === &#39;HEAD&#39;) {</div>
<div class="line">      request.get(&#39;http://mysite.com/doodle.png&#39;).pipe(resp)</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">})</div>
</div><!-- fragment --><p>You can also <span class="tt">pipe()</span> from <span class="tt">http.ServerRequest</span> instances, as well as to <span class="tt">http.ServerResponse</span> instances. The HTTP method, headers, and entity-body data will be sent. Which means that, if you don't really care about security, you can do:</p>
<div class="fragment"><div class="line">http.createServer(function (req, resp) {</div>
<div class="line">  if (req.url === &#39;/doodle.png&#39;) {</div>
<div class="line">    const x = request(&#39;http://mysite.com/doodle.png&#39;)</div>
<div class="line">    req.pipe(x)</div>
<div class="line">    x.pipe(resp)</div>
<div class="line">  }</div>
<div class="line">})</div>
</div><!-- fragment --><p>And since <span class="tt">pipe()</span> returns the destination stream in ≥ Node 0.5.x you can do one line proxying. :)</p>
<div class="fragment"><div class="line">req.pipe(request(&#39;http://mysite.com/doodle.png&#39;)).pipe(resp)</div>
</div><!-- fragment --><p>Also, none of this new functionality conflicts with requests previous features, it just expands them.</p>
<div class="fragment"><div class="line">const r = request.defaults({&#39;proxy&#39;:&#39;http://localproxy.com&#39;})</div>
<div class="line"> </div>
<div class="line">http.createServer(function (req, resp) {</div>
<div class="line">  if (req.url === &#39;/doodle.png&#39;) {</div>
<div class="line">    r.get(&#39;http://google.com/doodle.png&#39;).pipe(resp)</div>
<div class="line">  }</div>
<div class="line">})</div>
</div><!-- fragment --><p>You can still use intermediate proxies, the requests will still follow HTTP forwards, etc.</p>
<p>back to top</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md545"></a>
Promises &amp; Async/Await</h1>
<p><span class="tt">request</span> supports both streaming and callback interfaces natively. If you'd like <span class="tt">request</span> to return a Promise instead, you can use an alternative interface wrapper for <span class="tt">request</span>. These wrappers can be useful if you prefer to work with Promises, or if you'd like to use <span class="tt">async</span>/<span class="tt">await</span> in ES2017.</p>
<p>Several alternative interfaces are provided by the request team, including:</p><ul>
<li><a href="https://github.com/cypress-io/request-promise"><span class="tt">request-promise</span></a> (uses <a href="https://github.com/petkaantonov/bluebird">Bluebird</a> Promises)</li>
<li><a href="https://github.com/cypress-io/request-promise-native"><span class="tt">request-promise-native</span></a> (uses native Promises)</li>
<li><a href="https://github.com/cypress-io/request-promise-any"><span class="tt">request-promise-any</span></a> (uses <a href="https://www.npmjs.com/package/any-promise">any-promise</a> Promises)</li>
</ul>
<p>Also, <a href="https://nodejs.org/api/util.html#util_util_promisify_original"><span class="tt">util.promisify</span></a>, which is available from Node.js v8.0 can be used to convert a regular function that takes a callback to return a promise instead.</p>
<p>back to top</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md547"></a>
Forms</h1>
<p><span class="tt">request</span> supports <span class="tt">application/x-www-form-urlencoded</span> and <span class="tt">multipart/form-data</span> form uploads. For <span class="tt">multipart/related</span> refer to the <span class="tt">multipart</span> API.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md548"></a>
application/x-www-form-urlencoded (URL-Encoded Forms)</h3>
<p>URL-encoded forms are simple.</p>
<div class="fragment"><div class="line">request.post(&#39;http://service.com/upload&#39;, {form:{key:&#39;value&#39;}})</div>
<div class="line">// or</div>
<div class="line">request.post(&#39;http://service.com/upload&#39;).form({key:&#39;value&#39;})</div>
<div class="line">// or</div>
<div class="line">request.post({url:&#39;http://service.com/upload&#39;, form: {key:&#39;value&#39;}}, function(err,httpResponse,body){ /* ... */ })</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md549"></a>
multipart/form-data (Multipart Form Uploads)</h3>
<p>For <span class="tt">multipart/form-data</span> we use the <a href="https://github.com/form-data/form-data">form-data</a> library by <a href="https://github.com/felixge">@felixge</a>. For the most cases, you can pass your upload form data via the <span class="tt">formData</span> option.</p>
<div class="fragment"><div class="line">const formData = {</div>
<div class="line">  // Pass a simple key-value pair</div>
<div class="line">  my_field: &#39;my_value&#39;,</div>
<div class="line">  // Pass data via Buffers</div>
<div class="line">  my_buffer: Buffer.from([1, 2, 3]),</div>
<div class="line">  // Pass data via Streams</div>
<div class="line">  my_file: fs.createReadStream(__dirname + &#39;/unicycle.jpg&#39;),</div>
<div class="line">  // Pass multiple values /w an Array</div>
<div class="line">  attachments: [</div>
<div class="line">    fs.createReadStream(__dirname + &#39;/attachment1.jpg&#39;),</div>
<div class="line">    fs.createReadStream(__dirname + &#39;/attachment2.jpg&#39;)</div>
<div class="line">  ],</div>
<div class="line">  // Pass optional meta-data with an &#39;options&#39; object with style: {value: DATA, options: OPTIONS}</div>
<div class="line">  // Use case: for some types of streams, you&#39;ll need to provide &quot;file&quot;-related information manually.</div>
<div class="line">  // See the `form-data` README for more information about options: https://github.com/form-data/form-data</div>
<div class="line">  custom_file: {</div>
<div class="line">    value:  fs.createReadStream(&#39;/dev/urandom&#39;),</div>
<div class="line">    options: {</div>
<div class="line">      filename: &#39;topsecret.jpg&#39;,</div>
<div class="line">      contentType: &#39;image/jpeg&#39;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">request.post({url:&#39;http://service.com/upload&#39;, formData: formData}, function optionalCallback(err, httpResponse, body) {</div>
<div class="line">  if (err) {</div>
<div class="line">    return console.error(&#39;upload failed:&#39;, err);</div>
<div class="line">  }</div>
<div class="line">  console.log(&#39;Upload successful!  Server responded with:&#39;, body);</div>
<div class="line">});</div>
</div><!-- fragment --><p>For advanced cases, you can access the form-data object itself via <span class="tt">r.form()</span>. This can be modified until the request is fired on the next cycle of the event-loop. (Note that this calling <span class="tt">form()</span> will clear the currently set form data for that request.)</p>
<div class="fragment"><div class="line">// NOTE: Advanced use-case, for normal use see &#39;formData&#39; usage above</div>
<div class="line">const r = request.post(&#39;http://service.com/upload&#39;, function optionalCallback(err, httpResponse, body) {...})</div>
<div class="line">const form = r.form();</div>
<div class="line">form.append(&#39;my_field&#39;, &#39;my_value&#39;);</div>
<div class="line">form.append(&#39;my_buffer&#39;, Buffer.from([1, 2, 3]));</div>
<div class="line">form.append(&#39;custom_file&#39;, fs.createReadStream(__dirname + &#39;/unicycle.jpg&#39;), {filename: &#39;unicycle.jpg&#39;});</div>
</div><!-- fragment --><p> See the <a href="https://github.com/form-data/form-data">form-data README</a> for more information &amp; examples.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md550"></a>
multipart/related</h3>
<p>Some variations in different HTTP implementations require a newline/CRLF before, after, or both before and after the boundary of a <span class="tt">multipart/related</span> request (using the multipart option). This has been observed in the .NET WebAPI version 4.0. You can turn on a boundary preambleCRLF or postamble by passing them as <span class="tt">true</span> to your request options.</p>
<div class="fragment"><div class="line">request({</div>
<div class="line">  method: &#39;PUT&#39;,</div>
<div class="line">  preambleCRLF: true,</div>
<div class="line">  postambleCRLF: true,</div>
<div class="line">  uri: &#39;http://service.com/upload&#39;,</div>
<div class="line">  multipart: [</div>
<div class="line">    {</div>
<div class="line">      &#39;content-type&#39;: &#39;application/json&#39;,</div>
<div class="line">      body: JSON.stringify({foo: &#39;bar&#39;, _attachments: {&#39;message.txt&#39;: {follows: true, length: 18, &#39;content_type&#39;: &#39;text/plain&#39; }}})</div>
<div class="line">    },</div>
<div class="line">    { body: &#39;I am an attachment&#39; },</div>
<div class="line">    { body: fs.createReadStream(&#39;image.png&#39;) }</div>
<div class="line">  ],</div>
<div class="line">  // alternatively pass an object containing additional options</div>
<div class="line">  multipart: {</div>
<div class="line">    chunked: false,</div>
<div class="line">    data: [</div>
<div class="line">      {</div>
<div class="line">        &#39;content-type&#39;: &#39;application/json&#39;,</div>
<div class="line">        body: JSON.stringify({foo: &#39;bar&#39;, _attachments: {&#39;message.txt&#39;: {follows: true, length: 18, &#39;content_type&#39;: &#39;text/plain&#39; }}})</div>
<div class="line">      },</div>
<div class="line">      { body: &#39;I am an attachment&#39; }</div>
<div class="line">    ]</div>
<div class="line">  }</div>
<div class="line">},</div>
<div class="line">function (error, response, body) {</div>
<div class="line">  if (error) {</div>
<div class="line">    return console.error(&#39;upload failed:&#39;, error);</div>
<div class="line">  }</div>
<div class="line">  console.log(&#39;Upload successful!  Server responded with:&#39;, body);</div>
<div class="line">})</div>
</div><!-- fragment --><p>back to top</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md552"></a>
HTTP Authentication</h1>
<div class="fragment"><div class="line">request.get(&#39;http://some.server.com/&#39;).auth(&#39;username&#39;, &#39;password&#39;, false);</div>
<div class="line">// or</div>
<div class="line">request.get(&#39;http://some.server.com/&#39;, {</div>
<div class="line">  &#39;auth&#39;: {</div>
<div class="line">    &#39;user&#39;: &#39;username&#39;,</div>
<div class="line">    &#39;pass&#39;: &#39;password&#39;,</div>
<div class="line">    &#39;sendImmediately&#39;: false</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line">// or</div>
<div class="line">request.get(&#39;http://some.server.com/&#39;).auth(null, null, true, &#39;bearerToken&#39;);</div>
<div class="line">// or</div>
<div class="line">request.get(&#39;http://some.server.com/&#39;, {</div>
<div class="line">  &#39;auth&#39;: {</div>
<div class="line">    &#39;bearer&#39;: &#39;bearerToken&#39;</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><p>If passed as an option, <span class="tt">auth</span> should be a hash containing values:</p>
<ul>
<li><span class="tt">user</span> || <span class="tt">username</span></li>
<li><span class="tt">pass</span> || <span class="tt">password</span></li>
<li><span class="tt">sendImmediately</span> (optional)</li>
<li><span class="tt">bearer</span> (optional)</li>
</ul>
<p>The method form takes parameters <span class="tt">auth(username, password, sendImmediately, bearer)</span>.</p>
<p><span class="tt">sendImmediately</span> defaults to <span class="tt">true</span>, which causes a basic or bearer authentication header to be sent. If <span class="tt">sendImmediately</span> is <span class="tt">false</span>, then <span class="tt">request</span> will retry with a proper authentication header after receiving a <span class="tt">401</span> response from the server (which must contain a <span class="tt">WWW-Authenticate</span> header indicating the required authentication method).</p>
<p>Note that you can also specify basic authentication using the URL itself, as detailed in <a href="http://www.ietf.org/rfc/rfc1738.txt">RFC 1738</a>. Simply pass the <span class="tt">user:password</span> before the host with an <span class="tt">@</span> sign:</p>
<div class="fragment"><div class="line">const username = &#39;username&#39;,</div>
<div class="line">    password = &#39;password&#39;,</div>
<div class="line">    url = &#39;http://&#39; + username + &#39;:&#39; + password + &#39;@some.server.com&#39;;</div>
<div class="line"> </div>
<div class="line">request({url}, function (error, response, body) {</div>
<div class="line">   // Do more stuff with &#39;body&#39; here</div>
<div class="line">});</div>
</div><!-- fragment --><p>Digest authentication is supported, but it only works with <span class="tt">sendImmediately</span> set to <span class="tt">false</span>; otherwise <span class="tt">request</span> will send basic authentication on the initial request, which will probably cause the request to fail.</p>
<p>Bearer authentication is supported, and is activated when the <span class="tt">bearer</span> value is available. The value may be either a <span class="tt">String</span> or a <span class="tt">Function</span> returning a <span class="tt">String</span>. Using a function to supply the bearer token is particularly useful if used in conjunction with <span class="tt">defaults</span> to allow a single function to supply the last known token at the time of sending a request, or to compute one on the fly.</p>
<p>back to top</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md554"></a>
Custom HTTP Headers</h1>
<p>HTTP Headers, such as <span class="tt">User-Agent</span>, can be set in the <span class="tt">options</span> object. In the example below, we call the github API to find out the number of stars and forks for the request repository. This requires a custom <span class="tt">User-Agent</span> header as well as https.</p>
<div class="fragment"><div class="line">const request = require(&#39;request&#39;);</div>
<div class="line"> </div>
<div class="line">const options = {</div>
<div class="line">  url: &#39;https://api.github.com/repos/cypress-io/request&#39;,</div>
<div class="line">  headers: {</div>
<div class="line">    &#39;User-Agent&#39;: &#39;request&#39;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">function callback(error, response, body) {</div>
<div class="line">  if (!error &amp;&amp; response.statusCode == 200) {</div>
<div class="line">    const info = JSON.parse(body);</div>
<div class="line">    console.log(info.stargazers_count + &quot; Stars&quot;);</div>
<div class="line">    console.log(info.forks_count + &quot; Forks&quot;);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">request(options, callback);</div>
</div><!-- fragment --><p>back to top</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md556"></a>
Proxies</h1>
<p>If you specify a <span class="tt">proxy</span> option, then the request (and any subsequent redirects) will be sent via a connection to the proxy server.</p>
<p>If your endpoint is an <span class="tt">https</span> url, and you are using a proxy, then request will send a <span class="tt">CONNECT</span> request to the proxy server <em>first</em>, and then use the supplied connection to connect to the endpoint.</p>
<p>That is, first it will make a request like:</p>
<div class="fragment"><div class="line">HTTP/1.1 CONNECT endpoint-server.com:80</div>
<div class="line">Host: proxy-server.com</div>
<div class="line">User-Agent: whatever user agent you specify</div>
</div><!-- fragment --><p>and then the proxy server make a TCP connection to <span class="tt">endpoint-server</span> on port <span class="tt">80</span>, and return a response that looks like:</p>
<div class="fragment"><div class="line">HTTP/1.1 200 OK</div>
</div><!-- fragment --><p>At this point, the connection is left open, and the client is communicating directly with the <span class="tt">endpoint-server.com</span> machine.</p>
<p>See <a href="https://en.wikipedia.org/wiki/HTTP_tunnel">the wikipedia page on HTTP Tunneling</a> for more information.</p>
<p>By default, when proxying <span class="tt">http</span> traffic, request will simply make a standard proxied <span class="tt">http</span> request. This is done by making the <span class="tt">url</span> section of the initial line of the request a fully qualified url to the endpoint.</p>
<p>For example, it will make a single request that looks like:</p>
<div class="fragment"><div class="line">HTTP/1.1 GET http://endpoint-server.com/some-url</div>
<div class="line">Host: proxy-server.com</div>
<div class="line">Other-Headers: all go here</div>
<div class="line"> </div>
<div class="line">request body or whatever</div>
</div><!-- fragment --><p>Because a pure "http over http" tunnel offers no additional security or other features, it is generally simpler to go with a straightforward HTTP proxy in this case. However, if you would like to force a tunneling proxy, you may set the <span class="tt">tunnel</span> option to <span class="tt">true</span>.</p>
<p>You can also make a standard proxied <span class="tt">http</span> request by explicitly setting <span class="tt">tunnel : false</span>, but <b>note that this will allow the proxy to see the traffic to/from the destination server</b>.</p>
<p>If you are using a tunneling proxy, you may set the <span class="tt">proxyHeaderWhiteList</span> to share certain headers with the proxy.</p>
<p>You can also set the <span class="tt">proxyHeaderExclusiveList</span> to share certain headers only with the proxy and not with destination host.</p>
<p>By default, this set is:</p>
<div class="fragment"><div class="line">accept</div>
<div class="line">accept-charset</div>
<div class="line">accept-encoding</div>
<div class="line">accept-language</div>
<div class="line">accept-ranges</div>
<div class="line">cache-control</div>
<div class="line">content-encoding</div>
<div class="line">content-language</div>
<div class="line">content-length</div>
<div class="line">content-location</div>
<div class="line">content-md5</div>
<div class="line">content-range</div>
<div class="line">content-type</div>
<div class="line">connection</div>
<div class="line">date</div>
<div class="line">expect</div>
<div class="line">max-forwards</div>
<div class="line">pragma</div>
<div class="line">proxy-authorization</div>
<div class="line">referer</div>
<div class="line">te</div>
<div class="line">transfer-encoding</div>
<div class="line">user-agent</div>
<div class="line">via</div>
</div><!-- fragment --><p>Note that, when using a tunneling proxy, the <span class="tt">proxy-authorization</span> header and any headers from custom <span class="tt">proxyHeaderExclusiveList</span> are <em>never</em> sent to the endpoint server, but only to the proxy server.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md557"></a>
Controlling proxy behaviour using environment variables</h2>
<p>The following environment variables are respected by <span class="tt">request</span>:</p>
<ul>
<li><span class="tt">HTTP_PROXY</span> / <span class="tt">http_proxy</span></li>
<li><span class="tt">HTTPS_PROXY</span> / <span class="tt">https_proxy</span></li>
<li><span class="tt">NO_PROXY</span> / <span class="tt">no_proxy</span></li>
</ul>
<p>When <span class="tt">HTTP_PROXY</span> / <span class="tt">http_proxy</span> are set, they will be used to proxy non-SSL requests that do not have an explicit <span class="tt">proxy</span> configuration option present. Similarly, <span class="tt">HTTPS_PROXY</span> / <span class="tt">https_proxy</span> will be respected for SSL requests that do not have an explicit <span class="tt">proxy</span> configuration option. It is valid to define a proxy in one of the environment variables, but then override it for a specific request, using the <span class="tt">proxy</span> configuration option. Furthermore, the <span class="tt">proxy</span> configuration option can be explicitly set to false / null to opt out of proxying altogether for that request.</p>
<p><span class="tt">request</span> is also aware of the <span class="tt">NO_PROXY</span>/<span class="tt">no_proxy</span> environment variables. These variables provide a granular way to opt out of proxying, on a per-host basis. It should contain a comma separated list of hosts to opt out of proxying. It is also possible to opt of proxying when a particular destination port is used. Finally, the variable may be set to <span class="tt">*</span> to opt out of the implicit proxy configuration of the other environment variables.</p>
<p>Here's some examples of valid <span class="tt">no_proxy</span> values:</p>
<ul>
<li><span class="tt">google.com</span> - don't proxy HTTP/HTTPS requests to Google.</li>
<li><span class="tt">google.com:443</span> - don't proxy HTTPS requests to Google, but <em>do</em> proxy HTTP requests to Google.</li>
<li><span class="tt">google.com:443, yahoo.com:80</span> - don't proxy HTTPS requests to Google, and don't proxy HTTP requests to Yahoo!</li>
<li><span class="tt">*</span> - ignore <span class="tt">https_proxy</span>/<span class="tt">http_proxy</span> environment variables altogether.</li>
</ul>
<p>back to top</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md559"></a>
UNIX Domain Sockets</h1>
<p><span class="tt">request</span> supports making requests to <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">UNIX Domain Sockets</a>. To make one, use the following URL scheme:</p>
<div class="fragment"><div class="line">/* Pattern */ &#39;http://unix:SOCKET:PATH&#39;</div>
<div class="line">/* Example */ request.get(&#39;http://unix:/absolute/path/to/unix.socket:/request/path&#39;)</div>
</div><!-- fragment --><p>Note: The <span class="tt">SOCKET</span> path is assumed to be absolute to the root of the host file system.</p>
<p>back to top</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md561"></a>
TLS/SSL Protocol</h1>
<p>TLS/SSL Protocol options, such as <span class="tt">cert</span>, <span class="tt">key</span> and <span class="tt">passphrase</span>, can be set directly in <span class="tt">options</span> object, in the <span class="tt">agentOptions</span> property of the <span class="tt">options</span> object, or even in <span class="tt">https.globalAgent.options</span>. Keep in mind that, although <span class="tt">agentOptions</span> allows for a slightly wider range of configurations, the recommended way is via <span class="tt">options</span> object directly, as using <span class="tt">agentOptions</span> or <span class="tt">https.globalAgent.options</span> would not be applied in the same way in proxied environments (as data travels through a TLS connection instead of an http/https agent).</p>
<div class="fragment"><div class="line">const fs = require(&#39;fs&#39;)</div>
<div class="line">    , path = require(&#39;path&#39;)</div>
<div class="line">    , certFile = path.resolve(__dirname, &#39;ssl/client.crt&#39;)</div>
<div class="line">    , keyFile = path.resolve(__dirname, &#39;ssl/client.key&#39;)</div>
<div class="line">    , caFile = path.resolve(__dirname, &#39;ssl/ca.cert.pem&#39;)</div>
<div class="line">    , request = require(&#39;request&#39;);</div>
<div class="line"> </div>
<div class="line">const options = {</div>
<div class="line">    url: &#39;https://api.some-server.com/&#39;,</div>
<div class="line">    cert: fs.readFileSync(certFile),</div>
<div class="line">    key: fs.readFileSync(keyFile),</div>
<div class="line">    passphrase: &#39;password&#39;,</div>
<div class="line">    ca: fs.readFileSync(caFile)</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">request.get(options);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md562"></a>
Using <span class="tt">options.agentOptions</span></h2>
<p>In the example below, we call an API that requires client side SSL certificate (in PEM format) with passphrase protected private key (in PEM format) and disable the SSLv3 protocol:</p>
<div class="fragment"><div class="line">const fs = require(&#39;fs&#39;)</div>
<div class="line">    , path = require(&#39;path&#39;)</div>
<div class="line">    , certFile = path.resolve(__dirname, &#39;ssl/client.crt&#39;)</div>
<div class="line">    , keyFile = path.resolve(__dirname, &#39;ssl/client.key&#39;)</div>
<div class="line">    , request = require(&#39;request&#39;);</div>
<div class="line"> </div>
<div class="line">const options = {</div>
<div class="line">    url: &#39;https://api.some-server.com/&#39;,</div>
<div class="line">    agentOptions: {</div>
<div class="line">        cert: fs.readFileSync(certFile),</div>
<div class="line">        key: fs.readFileSync(keyFile),</div>
<div class="line">        // Or use `pfx` property replacing `cert` and `key` when using private key, certificate and CA certs in PFX or PKCS12 format:</div>
<div class="line">        // pfx: fs.readFileSync(pfxFilePath),</div>
<div class="line">        passphrase: &#39;password&#39;,</div>
<div class="line">        securityOptions: &#39;SSL_OP_NO_SSLv3&#39;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">request.get(options);</div>
</div><!-- fragment --><p>It is able to force using SSLv3 only by specifying <span class="tt">secureProtocol</span>:</p>
<div class="fragment"><div class="line">request.get({</div>
<div class="line">    url: &#39;https://api.some-server.com/&#39;,</div>
<div class="line">    agentOptions: {</div>
<div class="line">        secureProtocol: &#39;SSLv3_method&#39;</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><p>It is possible to accept other certificates than those signed by generally allowed Certificate Authorities (CAs). This can be useful, for example, when using self-signed certificates. To require a different root certificate, you can specify the signing CA by adding the contents of the CA's certificate file to the <span class="tt">agentOptions</span>. The certificate the domain presents must be signed by the root certificate specified:</p>
<div class="fragment"><div class="line">request.get({</div>
<div class="line">    url: &#39;https://api.some-server.com/&#39;,</div>
<div class="line">    agentOptions: {</div>
<div class="line">        ca: fs.readFileSync(&#39;ca.cert.pem&#39;)</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><p>The <span class="tt">ca</span> value can be an array of certificates, in the event you have a private or internal corporate public-key infrastructure hierarchy. For example, if you want to connect to <a href="https://api.some-server.com">https://api.some-server.com</a> which presents a key chain consisting of:</p><ol type="1">
<li>its own public key, which is signed by:</li>
<li>an intermediate "Corp Issuing Server", that is in turn signed by:</li>
<li>a root CA "Corp Root CA";</li>
</ol>
<p>you can configure your request as follows:</p>
<div class="fragment"><div class="line">request.get({</div>
<div class="line">    url: &#39;https://api.some-server.com/&#39;,</div>
<div class="line">    agentOptions: {</div>
<div class="line">        ca: [</div>
<div class="line">          fs.readFileSync(&#39;Corp Issuing Server.pem&#39;),</div>
<div class="line">          fs.readFileSync(&#39;Corp Root CA.pem&#39;)</div>
<div class="line">        ]</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><p>back to top</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md564"></a>
Support for HAR 1.2</h1>
<p>The <span class="tt">options.har</span> property will override the values: <span class="tt">url</span>, <span class="tt">method</span>, <span class="tt">qs</span>, <span class="tt">headers</span>, <span class="tt">form</span>, <span class="tt">formData</span>, <span class="tt">body</span>, <span class="tt">json</span>, as well as construct multipart data and read files from disk when <span class="tt">request.postData.params[].fileName</span> is present without a matching <span class="tt">value</span>.</p>
<p>A validation step will check if the HAR Request format matches the latest spec (v1.2) and will skip parsing if not matching.</p>
<div class="fragment"><div class="line">const request = require(&#39;request&#39;)</div>
<div class="line">request({</div>
<div class="line">  // will be ignored</div>
<div class="line">  method: &#39;GET&#39;,</div>
<div class="line">  uri: &#39;http://www.google.com&#39;,</div>
<div class="line"> </div>
<div class="line">  // HTTP Archive Request Object</div>
<div class="line">  har: {</div>
<div class="line">    url: &#39;http://www.mockbin.com/har&#39;,</div>
<div class="line">    method: &#39;POST&#39;,</div>
<div class="line">    headers: [</div>
<div class="line">      {</div>
<div class="line">        name: &#39;content-type&#39;,</div>
<div class="line">        value: &#39;application/x-www-form-urlencoded&#39;</div>
<div class="line">      }</div>
<div class="line">    ],</div>
<div class="line">    postData: {</div>
<div class="line">      mimeType: &#39;application/x-www-form-urlencoded&#39;,</div>
<div class="line">      params: [</div>
<div class="line">        {</div>
<div class="line">          name: &#39;foo&#39;,</div>
<div class="line">          value: &#39;bar&#39;</div>
<div class="line">        },</div>
<div class="line">        {</div>
<div class="line">          name: &#39;hello&#39;,</div>
<div class="line">          value: &#39;world&#39;</div>
<div class="line">        }</div>
<div class="line">      ]</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">// a POST request will be sent to http://www.mockbin.com</div>
<div class="line">// with body an application/x-www-form-urlencoded body:</div>
<div class="line">// foo=bar&amp;hello=world</div>
</div><!-- fragment --><p>back to top</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md566"></a>
request(options, callback)</h1>
<p>The first argument can be either a <span class="tt">url</span> or an <span class="tt">options</span> object. The only required option is <span class="tt">uri</span>; all others are optional.</p>
<ul>
<li><span class="tt">uri</span> || <span class="tt">url</span> - fully qualified uri or a parsed url object from <span class="tt">url.parse()</span></li>
<li><span class="tt">baseUrl</span> - fully qualified uri string used as the base url. Most useful with <span class="tt">request.defaults</span>, for example when you want to do many requests to the same domain. If <span class="tt">baseUrl</span> is <span class="tt"><a href="https://example.com/api/">https://example.com/api/</a></span>, then requesting <span class="tt">/end/point?test=true</span> will fetch <span class="tt"><a href="https://example.com/api/end/point?test=true">https://example.com/api/end/point?test=true</a></span>. When <span class="tt">baseUrl</span> is given, <span class="tt">uri</span> must also be a string.</li>
<li><span class="tt">method</span> - http method (default: <span class="tt">"GET"</span>)</li>
<li><span class="tt">headers</span> - http headers (default: <span class="tt">{}</span>)</li>
</ul>
<hr  />
<ul>
<li><span class="tt">qs</span> - object containing querystring values to be appended to the <span class="tt">uri</span></li>
<li><span class="tt">qsParseOptions</span> - object containing options to pass to the <a href="https://github.com/hapijs/qs#parsing-objects">qs.parse</a> method. Alternatively pass options to the <a href="https://nodejs.org/docs/v0.12.0/api/querystring.html#querystring_querystring_parse_str_sep_eq_options">querystring.parse</a> method using this format &lsquo;{sep:&rsquo;;', eq:':', options:{}}<span class="tt"></span></li>
<li><span class="tt"></span>qsStringifyOptions<span class="tt"> - object containing options to pass to the [qs.stringify](<a href="https://github.com/hapijs/qs">https://github.com/hapijs/qs</a>#stringifying) method. Alternatively pass options to the  [querystring.stringify](<a href="https://nodejs.org/docs/v0.12.0/api/querystring.html">https://nodejs.org/docs/v0.12.0/api/querystring.html</a>#querystring_querystring_stringify_obj_sep_eq_options) method using this format </span>{sep:';', eq:':', options:{}}<span class="tt">. For example, to change the way arrays are converted to query strings using the </span>qs<span class="tt"> module pass the </span>arrayFormat<span class="tt"> option with one of </span>indices|brackets|repeat<span class="tt"></span></li>
<li><span class="tt"></span>useQuerystring<span class="tt"> - if true, use </span>querystring<span class="tt"> to stringify and parse
  querystrings, otherwise use </span>qs<span class="tt"> (default: </span>false<span class="tt">). Set this option to
  </span>true<span class="tt"> if you need arrays to be serialized as </span>foo=bar&amp;foo=baz<span class="tt"> instead of the
  default </span>foo[0]=bar&amp;foo[1]=baz`.</li>
</ul>
<hr  />
<ul>
<li><span class="tt">body</span> - entity body for PATCH, POST and PUT requests. Must be a <span class="tt">Buffer</span>, <span class="tt">String</span> or <span class="tt">ReadStream</span>. If <span class="tt">json</span> is <span class="tt">true</span>, then <span class="tt">body</span> must be a JSON-serializable object.</li>
<li><span class="tt">form</span> - when passed an object or a querystring, this sets <span class="tt">body</span> to a querystring representation of value, and adds <span class="tt">Content-type: application/x-www-form-urlencoded</span> header. When passed no options, a <span class="tt">FormData</span> instance is returned (and is piped to request). See "Forms" section above.</li>
<li><span class="tt">formData</span> - data to pass for a <span class="tt">multipart/form-data</span> request. See Forms section above.</li>
<li><span class="tt">multipart</span> - array of objects which contain their own headers and <span class="tt">body</span> attributes. Sends a <span class="tt">multipart/related</span> request. See Forms section above.<ul>
<li>Alternatively you can pass in an object <span class="tt">{chunked: false, data: []}</span> where <span class="tt">chunked</span> is used to specify whether the request is sent in <a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding">chunked transfer encoding</a> In non-chunked requests, data items with body streams are not allowed.</li>
</ul>
</li>
<li><span class="tt">preambleCRLF</span> - append a newline/CRLF before the boundary of your <span class="tt">multipart/form-data</span> request.</li>
<li><span class="tt">postambleCRLF</span> - append a newline/CRLF at the end of the boundary of your <span class="tt">multipart/form-data</span> request.</li>
<li><span class="tt">json</span> - sets <span class="tt">body</span> to JSON representation of value and adds <span class="tt">Content-type: application/json</span> header. Additionally, parses the response body as JSON.</li>
<li><span class="tt">jsonReviver</span> - a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">reviver function</a> that will be passed to <span class="tt">JSON.parse()</span> when parsing a JSON response body.</li>
<li><span class="tt">jsonReplacer</span> - a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">replacer function</a> that will be passed to <span class="tt">JSON.stringify()</span> when stringifying a JSON request body.</li>
</ul>
<hr  />
<ul>
<li><span class="tt">auth</span> - a hash containing values <span class="tt">user</span> || <span class="tt">username</span>, <span class="tt">pass</span> || <span class="tt">password</span>, and <span class="tt">sendImmediately</span> (optional). See documentation above.</li>
<li><span class="tt">hawk</span> - options for <a href="https://github.com/hueniverse/hawk">Hawk signing</a>. The <span class="tt">credentials</span> key must contain the necessary signing info, <a href="https://github.com/hueniverse/hawk#usage-example">see hawk docs for details</a>.</li>
<li><span class="tt">aws</span> - <span class="tt">object</span> containing AWS signing information. Should have the properties <span class="tt">key</span>, <span class="tt">secret</span>, and optionally <span class="tt">session</span> (note that this only works for services that require session as part of the canonical string). Also requires the property <span class="tt">bucket</span>, unless you’re specifying your <span class="tt">bucket</span> as part of the path, or the request doesn’t use a bucket (i.e. GET Services). If you want to use AWS sign version 4 use the parameter <span class="tt">sign_version</span> with value <span class="tt">4</span> otherwise the default is version 2. If you are using SigV4, you can also include a <span class="tt">service</span> property that specifies the service name. <b>Note:</b> you need to <span class="tt">npm install aws4</span> first.</li>
<li><span class="tt">httpSignature</span> - options for the <a href="https://github.com/joyent/node-http-signature/blob/master/http_signing.md">HTTP Signature Scheme</a> using <a href="https://github.com/joyent/node-http-signature">Joyent's library</a>. The <span class="tt">keyId</span> and <span class="tt">key</span> properties must be specified. See the docs for other options.</li>
</ul>
<hr  />
<ul>
<li><span class="tt">followRedirect</span> - follow HTTP 3xx responses as redirects (default: <span class="tt">true</span>). This property can also be implemented as function which gets <span class="tt">response</span> object as the first argument.<ul>
<li><em>(synchronous usage)</em> It should return <span class="tt">true</span> if redirects should continue or <span class="tt">false</span> otherwise. If it returns a url string, the destination of the redirect will be overridden.</li>
<li><em>(async callback usage)</em> If the function has two arguments, it will be treated as an asynchronous function and will be passed a callback as the second argument. Invoke the callback with an error (<span class="tt">null</span> if no error) and the boolean/url result as the second.</li>
<li><em>(async promise usage)</em> Return a promise that resolves to the boolean/url result.</li>
</ul>
</li>
<li><span class="tt">followAllRedirects</span> - follow non-GET HTTP 3xx responses as redirects (default: <span class="tt">false</span>)</li>
<li><span class="tt">followOriginalHttpMethod</span> - by default we redirect to HTTP method GET. you can enable this property to redirect to the original HTTP method (default: <span class="tt">false</span>)</li>
<li><span class="tt">maxRedirects</span> - the maximum number of redirects to follow (default: <span class="tt">10</span>)</li>
<li><span class="tt">removeRefererHeader</span> - removes the referer header when a redirect happens (default: <span class="tt">false</span>). <b>Note:</b> if true, referer header set in the initial request is preserved during redirect chain.</li>
<li><span class="tt">allowInsecureRedirect</span> - allows cross-protocol redirects (HTTP to HTTPS and vice versa). <b>Warning:</b> may lead to bypassing anti SSRF filters (default: <span class="tt">false</span>)</li>
</ul>
<hr  />
<ul>
<li><span class="tt">encoding</span> - encoding to be used on <span class="tt">setEncoding</span> of response data. If <span class="tt">null</span>, the <span class="tt">body</span> is returned as a <span class="tt">Buffer</span>. Anything else <b>(including the default value of <span class="tt">undefined</span>)</b> will be passed as the <a href="http://nodejs.org/api/buffer.html#buffer_buffer">encoding</a> parameter to <span class="tt">toString()</span> (meaning this is effectively <span class="tt">utf8</span> by default). (<b>Note:</b> if you expect binary data, you should set <span class="tt">encoding: null</span>.)</li>
<li><span class="tt">gzip</span> - if <span class="tt">true</span>, add an <span class="tt">Accept-Encoding</span> header to request compressed content encodings from the server (if not already present) and decode supported content encodings in the response. <b>Note:</b> Automatic decoding of the response content is performed on the body data returned through <span class="tt">request</span> (both through the <span class="tt">request</span> stream and passed to the callback function) but is not performed on the <span class="tt">response</span> stream (available from the <span class="tt">response</span> event) which is the unmodified <span class="tt">http.IncomingMessage</span> object which may contain compressed data. See example below.</li>
<li><span class="tt">jar</span> - if <span class="tt">true</span>, remember cookies for future use (or define your custom cookie jar; see examples section)</li>
</ul>
<hr  />
<ul>
<li><span class="tt">agent</span> - <span class="tt">http(s).Agent</span> instance to use</li>
<li><span class="tt">agentClass</span> - alternatively specify your agent's class name</li>
<li><span class="tt">agentOptions</span> - and pass its options. <b>Note:</b> for HTTPS see <a href="http://nodejs.org/api/tls.html#tls_tls_connect_options_callback">tls API doc for TLS/SSL options</a> and the documentation above.</li>
<li><span class="tt">forever</span> - set to <span class="tt">true</span> to use the <a href="https://github.com/request/forever-agent">forever-agent</a> <b>Note:</b> Defaults to <span class="tt">http(s).Agent({keepAlive:true})</span> in node 0.12+</li>
<li><span class="tt">pool</span> - an object describing which agents to use for the request. If this option is omitted the request will use the global agent (as long as your options allow for it). Otherwise, request will search the pool for your custom agent. If no custom agent is found, a new agent will be created and added to the pool. <b>Note:</b> <span class="tt">pool</span> is used only when the <span class="tt">agent</span> option is not specified.<ul>
<li>A <span class="tt">maxSockets</span> property can also be provided on the <span class="tt">pool</span> object to set the max number of sockets for all agents created (ex: <span class="tt">pool: {maxSockets: Infinity}</span>).</li>
<li>Note that if you are sending multiple requests in a loop and creating multiple new <span class="tt">pool</span> objects, <span class="tt">maxSockets</span> will not work as intended. To work around this, either use `request.defaults` with your pool options or create the pool object with the <span class="tt">maxSockets</span> property outside of the loop.</li>
</ul>
</li>
<li><span class="tt">timeout</span> - integer containing number of milliseconds, controls two timeouts.<ul>
<li><b>Read timeout</b>: Time to wait for a server to send response headers (and start the response body) before aborting the request.</li>
<li><b>Connection timeout</b>: Sets the socket to timeout after <span class="tt">timeout</span> milliseconds of inactivity. Note that increasing the timeout beyond the OS-wide TCP connection timeout will not have any effect (<a href="http://www.sekuda.com/overriding_the_default_linux_kernel_20_second_tcp_socket_connect_timeout">the default in Linux can be anywhere from 20-120 seconds</a>)</li>
</ul>
</li>
</ul>
<hr  />
<ul>
<li><span class="tt">localAddress</span> - local interface to bind for network connections.</li>
<li><span class="tt">proxy</span> - an HTTP proxy to be used. Supports proxy Auth with Basic Auth, identical to support for the <span class="tt">url</span> parameter (by embedding the auth info in the <span class="tt">uri</span>)</li>
<li><span class="tt">strictSSL</span> - if <span class="tt">true</span>, requires SSL certificates be valid. <b>Note:</b> to use your own certificate authority, you need to specify an agent that was created with that CA as an option.</li>
<li><span class="tt">tunnel</span> - controls the behavior of <a href="https://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_tunneling">HTTP <span class="tt">CONNECT</span> tunneling</a> as follows:<ul>
<li><span class="tt">undefined</span> (default) - <span class="tt">true</span> if the destination is <span class="tt">https</span>, <span class="tt">false</span> otherwise</li>
<li><span class="tt">true</span> - always tunnel to the destination by making a <span class="tt">CONNECT</span> request to the proxy</li>
<li><span class="tt">false</span> - request the destination as a <span class="tt">GET</span> request.</li>
</ul>
</li>
<li><span class="tt">proxyHeaderWhiteList</span> - a whitelist of headers to send to a tunneling proxy.</li>
<li><span class="tt">proxyHeaderExclusiveList</span> - a whitelist of headers to send exclusively to a tunneling proxy and not to destination.</li>
</ul>
<hr  />
<ul>
<li><span class="tt">time</span> - if <span class="tt">true</span>, the request-response cycle (including all redirects) is timed at millisecond resolution. When set, the following properties are added to the response object:<ul>
<li><span class="tt">elapsedTime</span> Duration of the entire request/response in milliseconds (<em>deprecated</em>).</li>
<li><span class="tt">responseStartTime</span> Timestamp when the response began (in Unix Epoch milliseconds) (<em>deprecated</em>).</li>
<li><span class="tt">timingStart</span> Timestamp of the start of the request (in Unix Epoch milliseconds).</li>
<li><span class="tt">timings</span> Contains event timestamps in millisecond resolution relative to <span class="tt">timingStart</span>. If there were redirects, the properties reflect the timings of the final request in the redirect chain:<ul>
<li><span class="tt">socket</span> Relative timestamp when the <a href="https://nodejs.org/api/http.html#http_event_socket"><span class="tt">http</span></a> module's <span class="tt">socket</span> event fires. This happens when the socket is assigned to the request.</li>
<li><span class="tt">lookup</span> Relative timestamp when the <a href="https://nodejs.org/api/net.html#net_event_lookup"><span class="tt">net</span></a> module's <span class="tt">lookup</span> event fires. This happens when the DNS has been resolved.</li>
<li><span class="tt">connect</span>: Relative timestamp when the <a href="https://nodejs.org/api/net.html#net_event_connect"><span class="tt">net</span></a> module's <span class="tt">connect</span> event fires. This happens when the server acknowledges the TCP connection.</li>
<li><span class="tt">response</span>: Relative timestamp when the <a href="https://nodejs.org/api/http.html#http_event_response"><span class="tt">http</span></a> module's <span class="tt">response</span> event fires. This happens when the first bytes are received from the server.</li>
<li><span class="tt">end</span>: Relative timestamp when the last bytes of the response are received.</li>
</ul>
</li>
<li><span class="tt">timingPhases</span> Contains the durations of each request phase. If there were redirects, the properties reflect the timings of the final request in the redirect chain:<ul>
<li><span class="tt">wait</span>: Duration of socket initialization (<span class="tt">timings.socket</span>)</li>
<li><span class="tt">dns</span>: Duration of DNS lookup (<span class="tt">timings.lookup</span> - <span class="tt">timings.socket</span>)</li>
<li><span class="tt">tcp</span>: Duration of TCP connection (<span class="tt">timings.connect</span> - <span class="tt">timings.socket</span>)</li>
<li><span class="tt">firstByte</span>: Duration of HTTP server response (<span class="tt">timings.response</span> - <span class="tt">timings.connect</span>)</li>
<li><span class="tt">download</span>: Duration of HTTP download (<span class="tt">timings.end</span> - <span class="tt">timings.response</span>)</li>
<li><span class="tt">total</span>: Duration entire HTTP round-trip (<span class="tt">timings.end</span>)</li>
</ul>
</li>
</ul>
</li>
<li><span class="tt">har</span> - a <a href="http://www.softwareishard.com/blog/har-12-spec/#request">HAR 1.2 Request Object</a>, will be processed from HAR format into options overwriting matching values <em>(see the HAR 1.2 section for details)</em></li>
<li><span class="tt">callback</span> - alternatively pass the request's callback in the options object</li>
</ul>
<p>The callback argument gets 3 arguments:</p>
<ol type="1">
<li>An <span class="tt">error</span> when applicable (usually from <a href="http://nodejs.org/api/http.html#http_class_http_clientrequest"><span class="tt">http.ClientRequest</span></a> object)</li>
<li>An <a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage"><span class="tt">http.IncomingMessage</span></a> object (Response object)</li>
<li>The third is the <span class="tt">response</span> body (<span class="tt">String</span> or <span class="tt">Buffer</span>, or JSON object if the <span class="tt">json</span> option is supplied)</li>
</ol>
<p>back to top</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md576"></a>
Convenience methods</h1>
<p>There are also shorthand methods for different HTTP METHODs and some other conveniences.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md577"></a>
request.defaults(options)</h2>
<p>This method <b>returns a wrapper</b> around the normal request API that defaults to whatever options you pass to it.</p>
<p><b>Note:</b> <span class="tt">request.defaults()</span> <b>does not</b> modify the global request API; instead, it <b>returns a wrapper</b> that has your default settings applied to it.</p>
<p><b>Note:</b> You can call <span class="tt">.defaults()</span> on the wrapper that is returned from <span class="tt">request.defaults</span> to add/override defaults that were previously defaulted.</p>
<p>For example: </p><div class="fragment"><div class="line">//requests using baseRequest() will set the &#39;x-token&#39; header</div>
<div class="line">const baseRequest = request.defaults({</div>
<div class="line">  headers: {&#39;x-token&#39;: &#39;my-token&#39;}</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">//requests using specialRequest() will include the &#39;x-token&#39; header set in</div>
<div class="line">//baseRequest and will also include the &#39;special&#39; header</div>
<div class="line">const specialRequest = baseRequest.defaults({</div>
<div class="line">  headers: {special: &#39;special value&#39;}</div>
<div class="line">})</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md578"></a>
request.METHOD()</h2>
<p>These HTTP method convenience functions act just like <span class="tt">request()</span> but with a default method already set for you:</p>
<ul>
<li><em>request.get()</em>: Defaults to <span class="tt">method: "GET"</span>.</li>
<li><em>request.post()</em>: Defaults to <span class="tt">method: "POST"</span>.</li>
<li><em>request.put()</em>: Defaults to <span class="tt">method: "PUT"</span>.</li>
<li><em>request.patch()</em>: Defaults to <span class="tt">method: "PATCH"</span>.</li>
<li><em>request.del() / request.delete()</em>: Defaults to <span class="tt">method: "DELETE"</span>.</li>
<li><em>request.head()</em>: Defaults to <span class="tt">method: "HEAD"</span>.</li>
<li><em>request.options()</em>: Defaults to <span class="tt">method: "OPTIONS"</span>.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md579"></a>
request.cookie()</h2>
<p>Function that creates a new cookie.</p>
<div class="fragment"><div class="line">request.cookie(&#39;key1=value1&#39;)</div>
</div><!-- fragment --> <h2 class="doxsection"><a class="anchor" id="autotoc_md580"></a>
request.jar()</h2>
<p>Function that creates a new cookie jar.</p>
<div class="fragment"><div class="line">request.jar()</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md581"></a>
response.caseless.get('header-name')</h2>
<p>Function that returns the specified response header field using a <a href="https://tools.ietf.org/html/rfc7230#section-3.2">case-insensitive match</a></p>
<div class="fragment"><div class="line">request(&#39;http://www.google.com&#39;, function (error, response, body) {</div>
<div class="line">  // print the Content-Type header even if the server returned it as &#39;content-type&#39; (lowercase)</div>
<div class="line">  console.log(&#39;Content-Type is:&#39;, response.caseless.get(&#39;Content-Type&#39;));</div>
<div class="line">});</div>
</div><!-- fragment --><p>back to top</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md583"></a>
Debugging</h1>
<p>There are at least three ways to debug the operation of <span class="tt">request</span>:</p>
<ol type="1">
<li>Launch the node process like <span class="tt">NODE_DEBUG=request node script.js</span> (<span class="tt">lib,request,otherlib</span> works too).</li>
<li>Set &lsquo;require('request&rsquo;).debug = true` at any time (this does the same thing as #1).</li>
<li>Use the <a href="https://github.com/cypress-io/request-debug">request-debug module</a> to view request and response headers and bodies.</li>
</ol>
<p>back to top</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md585"></a>
Timeouts</h1>
<p>Most requests to external servers should have a timeout attached, in case the server is not responding in a timely manner. Without a timeout, your code may have a socket open/consume resources for minutes or more.</p>
<p>There are two main types of timeouts: <b>connection timeouts</b> and <b>read timeouts</b>. A connect timeout occurs if the timeout is hit while your client is attempting to establish a connection to a remote machine (corresponding to the <a href="http://linux.die.net/man/2/connect">connect() call</a> on the socket). A read timeout occurs any time the server is too slow to send back a part of the response.</p>
<p>These two situations have widely different implications for what went wrong with the request, so it's useful to be able to distinguish them. You can detect timeout errors by checking <span class="tt">err.code</span> for an 'ETIMEDOUT' value. Further, you can detect whether the timeout was a connection timeout by checking if the <span class="tt">err.connect</span> property is set to <span class="tt">true</span>.</p>
<div class="fragment"><div class="line">request.get(&#39;http://10.255.255.1&#39;, {timeout: 1500}, function(err) {</div>
<div class="line">    console.log(err.code === &#39;ETIMEDOUT&#39;);</div>
<div class="line">    // Set to `true` if the timeout was a connection timeout, `false` or</div>
<div class="line">    // `undefined` otherwise.</div>
<div class="line">    console.log(err.connect === true);</div>
<div class="line">    process.exit(0);</div>
<div class="line">});</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md586"></a>
Examples:</h1>
<div class="fragment"><div class="line">const request = require(&#39;request&#39;)</div>
<div class="line">  , rand = Math.floor(Math.random()*100000000).toString()</div>
<div class="line">  ;</div>
<div class="line">request(</div>
<div class="line">  { method: &#39;PUT&#39;</div>
<div class="line">  , uri: &#39;http://mikeal.iriscouch.com/testjs/&#39; + rand</div>
<div class="line">  , multipart:</div>
<div class="line">    [ { &#39;content-type&#39;: &#39;application/json&#39;</div>
<div class="line">      ,  body: JSON.stringify({foo: &#39;bar&#39;, _attachments: {&#39;message.txt&#39;: {follows: true, length: 18, &#39;content_type&#39;: &#39;text/plain&#39; }}})</div>
<div class="line">      }</div>
<div class="line">    , { body: &#39;I am an attachment&#39; }</div>
<div class="line">    ]</div>
<div class="line">  }</div>
<div class="line">, function (error, response, body) {</div>
<div class="line">    if(response.statusCode == 201){</div>
<div class="line">      console.log(&#39;document saved as: http://mikeal.iriscouch.com/testjs/&#39;+ rand)</div>
<div class="line">    } else {</div>
<div class="line">      console.log(&#39;error: &#39;+ response.statusCode)</div>
<div class="line">      console.log(body)</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">)</div>
</div><!-- fragment --><p>For backwards-compatibility, response compression is not supported by default. To accept gzip-compressed responses, set the <span class="tt">gzip</span> option to <span class="tt">true</span>. Note that the body data passed through <span class="tt">request</span> is automatically decompressed while the response object is unmodified and will contain compressed data if the server sent a compressed response.</p>
<div class="fragment"><div class="line">const request = require(&#39;request&#39;)</div>
<div class="line">request(</div>
<div class="line">  { method: &#39;GET&#39;</div>
<div class="line">  , uri: &#39;http://www.google.com&#39;</div>
<div class="line">  , gzip: true</div>
<div class="line">  }</div>
<div class="line">, function (error, response, body) {</div>
<div class="line">    // body is the decompressed response body</div>
<div class="line">    console.log(&#39;server encoded the data as: &#39; + (response.headers[&#39;content-encoding&#39;] || &#39;identity&#39;))</div>
<div class="line">    console.log(&#39;the decoded data is: &#39; + body)</div>
<div class="line">  }</div>
<div class="line">)</div>
<div class="line">.on(&#39;data&#39;, function(data) {</div>
<div class="line">  // decompressed data as it is received</div>
<div class="line">  console.log(&#39;decoded chunk: &#39; + data)</div>
<div class="line">})</div>
<div class="line">.on(&#39;response&#39;, function(response) {</div>
<div class="line">  // unmodified http.IncomingMessage object</div>
<div class="line">  response.on(&#39;data&#39;, function(data) {</div>
<div class="line">    // compressed data as it is received</div>
<div class="line">    console.log(&#39;received &#39; + data.length + &#39; bytes of compressed data&#39;)</div>
<div class="line">  })</div>
<div class="line">})</div>
</div><!-- fragment --><p>Cookies are disabled by default (else, they would be used in subsequent requests). To enable cookies, set <span class="tt">jar</span> to <span class="tt">true</span> (either in <span class="tt">defaults</span> or <span class="tt">options</span>).</p>
<div class="fragment"><div class="line">const request = request.defaults({jar: true})</div>
<div class="line">request(&#39;http://www.google.com&#39;, function () {</div>
<div class="line">  request(&#39;http://images.google.com&#39;)</div>
<div class="line">})</div>
</div><!-- fragment --><p>To use a custom cookie jar (instead of <span class="tt">request</span>’s global cookie jar), set <span class="tt">jar</span> to an instance of <span class="tt">request.jar()</span> (either in <span class="tt">defaults</span> or <span class="tt">options</span>)</p>
<div class="fragment"><div class="line">const j = request.jar()</div>
<div class="line">const request = request.defaults({jar:j})</div>
<div class="line">request(&#39;http://www.google.com&#39;, function () {</div>
<div class="line">  request(&#39;http://images.google.com&#39;)</div>
<div class="line">})</div>
</div><!-- fragment --><p>OR</p>
<div class="fragment"><div class="line">const j = request.jar();</div>
<div class="line">const cookie = request.cookie(&#39;key1=value1&#39;);</div>
<div class="line">const url = &#39;http://www.google.com&#39;;</div>
<div class="line">j.setCookie(cookie, url);</div>
<div class="line">request({url: url, jar: j}, function () {</div>
<div class="line">  request(&#39;http://images.google.com&#39;)</div>
<div class="line">})</div>
</div><!-- fragment --><p>To use a custom cookie store (such as a <a href="https://github.com/mitsuru/tough-cookie-filestore"><span class="tt">FileCookieStore</span></a> which supports saving to and restoring from JSON files), pass it as a parameter to <span class="tt">request.jar()</span>:</p>
<div class="fragment"><div class="line">const FileCookieStore = require(&#39;tough-cookie-filestore&#39;);</div>
<div class="line">// NOTE - currently the &#39;cookies.json&#39; file must already exist!</div>
<div class="line">const j = request.jar(new FileCookieStore(&#39;cookies.json&#39;));</div>
<div class="line">request = request.defaults({ jar : j })</div>
<div class="line">request(&#39;http://www.google.com&#39;, function() {</div>
<div class="line">  request(&#39;http://images.google.com&#39;)</div>
<div class="line">})</div>
</div><!-- fragment --><p>The cookie store must be a <a href="https://github.com/SalesforceEng/tough-cookie"><span class="tt">tough-cookie</span></a> store and it must support synchronous operations; see the <a href="https://github.com/SalesforceEng/tough-cookie#api"><span class="tt">CookieStore</span> API docs</a> for details.</p>
<p>To inspect your cookie jar after a request:</p>
<div class="fragment"><div class="line">const j = request.jar()</div>
<div class="line">request({url: &#39;http://www.google.com&#39;, jar: j}, function () {</div>
<div class="line">  const cookie_string = j.getCookieString(url); // &quot;key1=value1; key2=value2; ...&quot;</div>
<div class="line">  const cookies = j.getCookies(url);</div>
<div class="line">  // [{key: &#39;key1&#39;, value: &#39;value1&#39;, domain: &quot;www.google.com&quot;, ...}, ...]</div>
<div class="line">})</div>
</div><!-- fragment --><p>back to top </p>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_8983b1862dce8a71846356b6209105f4.html">EcoEats-Project</a></li><li class="navelem"><a href="dir_5091f2b68170d33f954320199e2fed0a.html">node_modules</a></li><li class="navelem"><a href="dir_76755337dd0c7a85b221ed2c49985cdb.html">@cypress</a></li><li class="navelem"><a href="dir_ab6614af5cc3bd6ec5e2b94281332a5d.html">request</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
