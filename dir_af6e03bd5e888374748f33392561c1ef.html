<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/saxes Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_af6e03bd5e888374748f33392561c1ef.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">saxes Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for saxes:</div>
<div class="dyncontent">
<div class="center"><img src="dir_af6e03bd5e888374748f33392561c1ef_dep.png" border="0" usemap="#adir__af6e03bd5e888374748f33392561c1ef__dep" loading="lazy" alt="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/saxes"/></div>
</div>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md12730"></a>
saxes</h1>
<p>A sax-style non-validating parser for XML.</p>
<p>Saxes is a fork of <a href="https://github.com/isaacs/sax-js">sax</a> 1.2.4. All mentions of sax in this project's documentation are references to sax 1.2.4.</p>
<p>Designed with <a href="http://nodejs.org/">node</a> in mind, but should work fine in the browser or other CommonJS implementations.</p>
<p>Saxes does not support Node versions older than 10.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md12731"></a>
Notable Differences from Sax.</h1>
<ul>
<li><p class="startli">Saxes aims to be much stricter than sax with regards to XML well-formedness. Sax, even in its so-called "strict mode", is not strict. It silently accepts structures that are not well-formed XML. Projects that need better compliance with well-formedness constraints cannot use sax as-is.</p>
<p class="startli">Consequently, saxes does not support HTML, or pseudo-XML, or bad XML. Saxes will report well-formedness errors in all these cases but it won't try to extract data from malformed documents like sax does.</p>
</li>
<li>Saxes is much much faster than sax, mostly because of a substantial redesign of the internal parsing logic. The speed improvement is not merely due to removing features that were supported by sax. That helped a bit, but saxes adds some expensive checks in its aim for conformance with the XML specification. Redesigning the parsing logic is what accounts for most of the performance improvement.</li>
<li>Saxes does not aim to support antiquated platforms. We will not pollute the source or the default build with support for antiquated platforms. If you want support for IE 11, you are welcome to produce a PR that adds a <em>new build</em> transpiled to ES5.</li>
<li>Saxes handles errors differently from sax: it provides a default onerror handler which throws. You can replace it with your own handler if you want. If your handler does nothing, there is no <span class="tt">resume</span> method to call.</li>
<li>There's no <span class="tt">Stream</span> API. A revamped API may be introduced later. (It is still a "streaming parser" in the general sense that you write a character stream to it.)</li>
<li>Saxes does not have facilities for limiting the size the data chunks passed to event handlers. See the FAQ entry for more details.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md12732"></a>
Conformance</h1>
<p>Saxes supports:</p>
<ul>
<li><a href="https://www.w3.org/TR/2008/REC-xml-20081126/">XML 1.0 fifth edition</a></li>
<li><a href="https://www.w3.org/TR/2006/REC-xml11-20060816/">XML 1.1 second edition</a></li>
<li><a href="https://www.w3.org/TR/2009/REC-xml-names-20091208/">Namespaces in XML 1.0 (Third Edition)</a>.</li>
<li><a href="https://www.w3.org/TR/2006/REC-xml-names11-20060816/">Namespaces in XML 1.1 (Second Edition)</a>.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md12733"></a>
Limitations</h1>
<p>This is a non-validating parser so it only verifies whether the document is well-formed. We do aim to raise errors for all malformed constructs encountered. However, this parser does not thorougly parse the contents of DTDs. So most malformedness errors caused by errors <b>in DTDs</b> cannot be reported.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md12734"></a>
Regarding <span class="tt">&lt;!DOCTYPE</span> and <span class="tt">&lt;!ENTITY</span></h1>
<p>The parser will handle the basic XML entities in text nodes and attribute values: <span class="tt">&amp;amp; &amp;lt; &amp;gt; &amp;apos; &amp;quot;</span>. It's possible to define additional entities in XML by putting them in the DTD. This parser doesn't do anything with that. If you want to listen to the <span class="tt">doctype</span> event, and then fetch the doctypes, and read the entities and add them to <span class="tt">parser.ENTITIES</span>, then be my guest.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md12735"></a>
Documentation</h1>
<p>The source code contains JSDOC comments. Use them. What follows is a brief summary of what is available. The final authority is the source code.</p>
<p><b>PAY CLOSE ATTENTION TO WHAT IS PUBLIC AND WHAT IS PRIVATE.</b></p>
<p>The move to TypeScript makes it so that everything is now formally private, protected, or public.</p>
<p>If you use anything not public, that's at your own peril.</p>
<p>If there's a mistake in the documentation, raise an issue. If you just assume, you may assume incorrectly.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md12736"></a>
Summary Usage Information</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md12737"></a>
Example</h2>
<div class="fragment"><div class="line">var saxes = require(&quot;./lib/saxes&quot;),</div>
<div class="line">  parser = new saxes.SaxesParser();</div>
<div class="line"> </div>
<div class="line">parser.on(&quot;error&quot;, function (e) {</div>
<div class="line">  // an error happened.</div>
<div class="line">});</div>
<div class="line">parser.on(&quot;text&quot;, function (t) {</div>
<div class="line">  // got some text.  t is the string of text.</div>
<div class="line">});</div>
<div class="line">parser.on(&quot;opentag&quot;, function (node) {</div>
<div class="line">  // opened a tag.  node has &quot;name&quot; and &quot;attributes&quot;</div>
<div class="line">});</div>
<div class="line">parser.on(&quot;end&quot;, function () {</div>
<div class="line">  // parser stream is done, and ready to have more stuff written to it.</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">parser.write(&#39;&lt;xml&gt;Hello, &lt;who name=&quot;world&quot;&gt;world&lt;/who&gt;!&lt;/xml&gt;&#39;).close();</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md12738"></a>
Constructor Arguments</h2>
<p>Settings supported:</p>
<ul>
<li><span class="tt">xmlns</span> - Boolean. If <span class="tt">true</span>, then namespaces are supported. Default is <span class="tt">false</span>.</li>
<li><span class="tt">position</span> - Boolean. If <span class="tt">false</span>, then don't track line/col/position. Unset is treated as <span class="tt">true</span>. Default is unset. Currently, setting this to <span class="tt">false</span> only results in a cosmetic change: the errors reported do not contain position information. sax-js would literally turn off the position-computing logic if this flag was set to false. The notion was that it would optimize execution. In saxes at least it turns out that continually testing this flag causes a cost that offsets the benefits of turning off this logic.</li>
<li><span class="tt">fileName</span> - String. Set a file name for error reporting. This is useful only when tracking positions. You may leave it unset.</li>
<li><span class="tt">fragment</span> - Boolean. If <span class="tt">true</span>, parse the XML as an XML fragment. Default is <span class="tt">false</span>.</li>
<li><span class="tt">additionalNamespaces</span> - A plain object whose key, value pairs define namespaces known before parsing the XML file. It is not legal to pass bindings for the namespaces <span class="tt">"xml"</span> or <span class="tt">"xmlns"</span>.</li>
<li><span class="tt">defaultXMLVersion</span> - The default version of the XML specification to use if the document contains no XML declaration. If the document does contain an XML declaration, then this setting is ignored. Must be <span class="tt">"1.0"</span> or <span class="tt">"1.1"</span>. The default is <span class="tt">"1.0"</span>.</li>
<li><p class="startli"><span class="tt">forceXMLVersion</span> - Boolean. A flag indicating whether to force the XML version used for parsing to the value of <span class="tt">defaultXMLVersion</span>. When this flag is <span class="tt">true</span>, <span class="tt">defaultXMLVersion</span> must be specified. If unspecified, the default value of this flag is <span class="tt">false</span>.</p>
<p class="startli">Example: suppose you are parsing a document that has an XML declaration specifying XML version 1.1.</p>
<p class="startli">If you set <span class="tt">defaultXMLVersion</span> to <span class="tt">"1.0"</span> without setting <span class="tt">forceXMLVersion</span> then the XML declaration will override the value of <span class="tt">defaultXMLVersion</span> and the document will be parsed according to XML 1.1.</p>
<p class="startli">If you set <span class="tt">defaultXMLVersion</span> to <span class="tt">"1.0"</span> and set <span class="tt">forceXMLVersion</span> to <span class="tt">true</span>, then the XML declaration will be ignored and the document will be parsed according to XML 1.0.</p>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md12739"></a>
Methods</h2>
<p><span class="tt">write</span> - Write bytes onto the stream. You don't have to pass the whole document in one <span class="tt">write</span> call. You can read your source chunk by chunk and call <span class="tt">write</span> with each chunk.</p>
<p><span class="tt">close</span> - Close the stream. Once closed, no more data may be written until it is done processing the buffer, which is signaled by the <span class="tt">end</span> event.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md12740"></a>
Properties</h2>
<p>The parser has the following properties:</p>
<p><span class="tt">line</span>, <span class="tt">column</span>, <span class="tt">columnIndex</span>, <span class="tt">position</span> - Indications of the position in the XML document where the parser currently is looking. The <span class="tt">columnIndex</span> property counts columns as if indexing into a JavaScript string, whereas the <span class="tt">column</span> property counts Unicode characters.</p>
<p><span class="tt">closed</span> - Boolean indicating whether or not the parser can be written to. If it's <span class="tt">true</span>, then wait for the <span class="tt">ready</span> event to write again.</p>
<p><span class="tt">opt</span> - Any options passed into the constructor.</p>
<p><span class="tt">xmlDecl</span> - The XML declaration for this document. It contains the fields <span class="tt">version</span>, <span class="tt">encoding</span> and <span class="tt">standalone</span>. They are all <span class="tt">undefined</span> before encountering the XML declaration. If they are undefined after the XML declaration, the corresponding value was not set by the declaration. There is no event associated with the XML declaration. In a well-formed document, the XML declaration may be preceded only by an optional BOM. So by the time any event generated by the parser happens, the declaration has been processed if present at all. Otherwise, you have a malformed document, and as stated above, you cannot rely on the parser data!</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md12741"></a>
Error Handling</h2>
<p>The parser continues to parse even upon encountering errors, and does its best to continue reporting errors. You should heed all errors reported. After an error, however, saxes may interpret your document incorrectly. For instance <span class="tt">&lt;foo a=bc="d"/&gt;</span> is invalid XML. Did you mean to have <span class="tt">&lt;foo a="bc=d"/&gt;</span> or <span class="tt">&lt;foo a="b" c="d"/&gt;</span> or some other variation? For the sake of continuing to provide errors, saxes will continue parsing the document, but the structure it reports may be incorrect. It is only after the errors are fixed in the document that saxes can provide a reliable interpretation of the document.</p>
<p>That leaves you with two rules of thumb when using saxes:</p>
<ul>
<li>Pay attention to the errors that saxes report. The default <span class="tt">onerror</span> handler throws, so by default, you cannot miss errors.</li>
<li><b>ONCE AN ERROR HAS BEEN ENCOUNTERED, STOP RELYING ON THE EVENT HANDLERS OTHER THAN <span class="tt">onerror</span>.</b> As explained above, when saxes runs into a well-formedness problem, it makes a guess in order to continue reporting more errors. The guess may be wrong.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md12742"></a>
Events</h2>
<p>To listen to an event, override <span class="tt">on&lt;eventname&gt;</span>. The list of supported events are also in the exported <span class="tt">EVENTS</span> array.</p>
<p>See the JSDOC comments in the source code for a description of each supported event.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md12743"></a>
Parsing XML Fragments</h2>
<p>The XML specification does not define any method by which to parse XML fragments. However, there are usage scenarios in which it is desirable to parse fragments. In order to allow this, saxes provides three initialization options.</p>
<p>If you pass the option <span class="tt">fragment: true</span> to the parser constructor, the parser will expect an XML fragment. It essentially starts with a parsing state equivalent to the one it would be in if <span class="tt">parser.write("&lt;foo"&gt;)</span> had been called right after initialization. In other words, it expects content which is acceptable inside an element. This also turns off well-formedness checks that are inappropriate when parsing a fragment.</p>
<p>The option <span class="tt">additionalNamespaces</span> allows you to define additional prefix-to-URI bindings known before parsing starts. You would use this over <span class="tt">resolvePrefix</span> if you have at the ready a series of namespaces bindings to use.</p>
<p>The option <span class="tt">resolvePrefix</span> allows you to pass a function which saxes will use if it is unable to resolve a namespace prefix by itself. You would use this over <span class="tt">additionalNamespaces</span> in a context where getting a complete list of defined namespaces is onerous.</p>
<p>Note that you can use <span class="tt">additionalNamespaces</span> and <span class="tt">resolvePrefix</span> together if you want. <span class="tt">additionalNamespaces</span> applies before <span class="tt">resolvePrefix</span>.</p>
<p>The options <span class="tt">additionalNamespaces</span> and <span class="tt">resolvePrefix</span> are really meant to be used for parsing fragments. However, saxes won't prevent you from using them with <span class="tt">fragment: false</span>. Note that if you do this, your document may parse without errors and yet be malformed because the document can refer to namespaces which are not defined <em>in</em> the document.</p>
<p>Of course, <span class="tt">additionalNamespaces</span> and <span class="tt">resolvePrefix</span> are used only if <span class="tt">xmlns</span> is <span class="tt">true</span>. If you are parsing a fragment that does not use namespaces, there's no point in setting these options.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md12744"></a>
Performance Tips</h2>
<ul>
<li>saxes works faster on files that use newlines (<span class="tt">\u000A</span>) as end of line markers than files that use other end of line markers (like <span class="tt">\r</span> or <span class="tt">\r\n</span>). The XML specification requires that conformant applications behave as if all characters that are to be treated as end of line characters are converted to <span class="tt">\u000A</span> prior to parsing. The optimal code path for saxes is a file in which all end of line characters are already <span class="tt">\u000A</span>.</li>
<li>Don't split Unicode strings you feed to saxes across surrogates. When you naively split a string in JavaScript, you run the risk of splitting a Unicode character into two surrogates. e.g. In the following example <span class="tt">a</span> and <span class="tt">b</span> each contain half of a single Unicode character: <span class="tt">const a = "\u{1F4A9}"[0];
  const b = "\u{1F4A9}"[1]</span> If you feed such split surrogates to versions of saxes prior to 4, you'd get errors. Saxes version 4 and over are able to detect when a chunk of data ends with a surrogate and carry over the surrogate to the next chunk. However this operation entails slicing and concatenating strings. If you can feed your data in a way that does not split surrogates, you should do it. (Obviously, feeding all the data at once with a single write is fastest.)</li>
<li>Don't set event handlers you don't need. Saxes has always aimed to avoid doing work that will just be tossed away but future improvements hope to do this more aggressively. One way saxes knows whether or not some data is needed is by checking whether a handler has been set for a specific event.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md12745"></a>
FAQ</h1>
<p>Q. Why has saxes dropped support for limiting the size of data chunks passed to event handlers?</p>
<p>A. With sax you could set <span class="tt">MAX_BUFFER_LENGTH</span> to cause the parser to limit the size of data chunks passed to event handlers. So if you ran into a span of text above the limit, multiple <span class="tt">text</span> events with smaller data chunks were fired instead of a single event with a large chunk.</p>
<p>However, that functionality had some problematic characteristics. It had an arbitrary default value. It was library-wide so all parsers created from a single instance of the <span class="tt">sax</span> library shared it. This could potentially cause conflicts among libraries running in the same VM but using sax for different purposes.</p>
<p>These issues could have been easily fixed, but there were larger issues. The buffer limit arbitrarily applied to some events but not others. It would split <span class="tt">text</span>, <span class="tt">cdata</span> and <span class="tt">script</span> events. However, if a <span class="tt">comment</span>, <span class="tt">doctype</span>, <span class="tt">attribute</span> or <span class="tt">processing instruction</span> were more than the limit, the parser would generate an error and you were left picking up the pieces.</p>
<p>It was not intuitive to use. You'd think setting the limit to 1K would prevent chunks bigger than 1K to be passed to event handlers. But that was not the case. A comment in the source code told you that you might go over the limit if you passed large chunks to <span class="tt">write</span>. So if you want a 1K limit, don't pass 64K chunks to <span class="tt">write</span>. Fair enough. You know what limit you want so you can control the size of the data you pass to <span class="tt">write</span>. So you limit the chunks to <span class="tt">write</span> to 1K at a time. Even if you do this, your event handlers may get data chunks that are 2K in size. Suppose on the previous <span class="tt">write</span> the parser has just finished processing an open tag, so it is ready for text. Your <span class="tt">write</span> passes 1K of text. You are not above the limit yet, so no event is generated yet. The next <span class="tt">write</span> passes another 1K of text. It so happens that sax checks buffer limits only once per <span class="tt">write</span>, after the chunk of data has been processed. Now you've hit the limit and you get a <span class="tt">text</span> event with 2K of data. So even if you limit your <span class="tt">write</span> calls to the buffer limit you've set, you may still get events with chunks at twice the buffer size limit you've specified.</p>
<p>We may consider reinstating an equivalent functionality, provided that it addresses the issues above and does not cause a huge performance drop for use-case scenarios that don't need it. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_8983b1862dce8a71846356b6209105f4.html">EcoEats-Project</a></li><li class="navelem"><a href="dir_5091f2b68170d33f954320199e2fed0a.html">node_modules</a></li><li class="navelem"><a href="dir_af6e03bd5e888374748f33392561c1ef.html">saxes</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
