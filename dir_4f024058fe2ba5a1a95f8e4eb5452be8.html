<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/jest-worker Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_4f024058fe2ba5a1a95f8e4eb5452be8.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jest-worker Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for jest-worker:</div>
<div class="dyncontent">
<div class="center"><img src="dir_4f024058fe2ba5a1a95f8e4eb5452be8_dep.png" border="0" usemap="#adir__4f024058fe2ba5a1a95f8e4eb5452be8__dep" loading="lazy" alt="C:/Users/arisc/OneDrive/Documents/GitHub/FINAL/EcoEats-Project/node_modules/jest-worker"/></div>
</div>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8323"></a>
jest-worker</h1>
<p>Module for executing heavy tasks under forked processes in parallel, by providing a <span class="tt">Promise</span> based interface, minimum overhead, and bound workers.</p>
<p>The module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be <span class="tt">await</span>'ed. Child (worker) methods can either be synchronous or asynchronous.</p>
<p>The module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the <span class="tt">computeWorkerKey</span> method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a <span class="tt">computeWorkerKey</span> method because you want <em>some</em> of the tasks to be sticked, you can return <span class="tt">null</span> from it.</p>
<p>The list of exposed methods can be explicitly provided via the <span class="tt">exposedMethods</span> option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the "minimal example" section for a valid one.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8324"></a>
Install</h1>
<div class="fragment"><div class="line">yarn add jest-worker</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md8325"></a>
Example</h1>
<p>This example covers the minimal usage:</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8326"></a>
File <span class="tt">parent.js</span></h2>
<div class="fragment"><div class="line">import {Worker as JestWorker} from &#39;jest-worker&#39;;</div>
<div class="line"> </div>
<div class="line">async function main() {</div>
<div class="line">  const worker = new JestWorker(require.resolve(&#39;./worker&#39;));</div>
<div class="line">  const result = await worker.hello(&#39;Alice&#39;); // &quot;Hello, Alice&quot;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">main();</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md8327"></a>
File <span class="tt">worker.js</span></h2>
<div class="fragment"><div class="line">export function hello(param) {</div>
<div class="line">  return `Hello, ${param}`;</div>
<div class="line">}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md8328"></a>
Experimental worker</h1>
<p>Node shipped with <a href="https://nodejs.org/api/worker_threads.html"><span class="tt">worker_threads</span></a>, a "threading API" that uses <span class="tt">SharedArrayBuffers</span> to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in <span class="tt">jest-worker</span>.</p>
<p>To use <span class="tt">worker_threads</span> instead of default <span class="tt">child_process</span> you have to pass <span class="tt">enableWorkerThreads: true</span> when instantiating the worker.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8329"></a>
API</h1>
<p>The <span class="tt">Worker</span> export is a constructor that is initialized by passing the worker path, plus an options object.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8330"></a>
<span class="tt">workerPath: string | URL</span> (required)</h2>
<p>Node module name or absolute path or file URL of the file to be loaded in the child processes. You can use <span class="tt">require.resolve</span> to transform a relative path into an absolute one.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8331"></a>
<span class="tt">options: Object</span> (optional)</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8332"></a>
<span class="tt">computeWorkerKey: (method: string, ...args: Array&lt;unknown&gt;) =&gt; string | null</span> (optional)</h3>
<p>Every time a method exposed via the API is called, <span class="tt">computeWorkerKey</span> is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making <span class="tt">computeWorkerKey</span> return the same identifier for all different calls. If you do not want to bind the call to any worker, return <span class="tt">null</span>.</p>
<p>The callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the "bound worker usage" section.</p>
<p>By default, no process is bound to any worker.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8333"></a>
<span class="tt">enableWorkerThreads: boolean</span> (optional)</h3>
<p>By default, <span class="tt">jest-worker</span> will use <span class="tt">child_process</span> threads to spawn new Node.js processes. If you prefer <a href="https://nodejs.org/api/worker_threads.html"><span class="tt">worker_threads</span></a> instead, pass <span class="tt">enableWorkerThreads: true</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8334"></a>
<span class="tt">exposedMethods: ReadonlyArray&lt;string&gt;</span> (optional)</h3>
<p>List of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public <span class="tt">Worker</span> method, or starting with <span class="tt">_</span>. If you use method auto-discovery, then these methods will not be exposed, even if they exist.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8335"></a>
<span class="tt">forkOptions: ForkOptions</span> (optional)</h3>
<p>Allow customizing all options passed to <span class="tt">child_process.fork</span>. By default, some values are set (<span class="tt">cwd</span>, <span class="tt">env</span>, <span class="tt">execArgv</span> and <span class="tt">serialization</span>), but you can override them and customize the rest. For a list of valid values, check <a href="https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options">the Node documentation</a>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8336"></a>
<span class="tt">idleMemoryLimit: number</span> (optional)</h3>
<p>Specifies the memory limit for workers before they are recycled and is primarily a work-around for <a href="https://github.com/jestjs/jest/issues/11956">this issue</a>;</p>
<p>After the worker has executed a task the memory usage of it is checked. If it exceeds the value specified the worker is killed and restarted. If no limit is set this process does not occur. The limit can be specified in 2 ways:</p>
<ul>
<li><span class="tt">&lt;= 1</span> - The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory</li>
<li><span class="tt">\&gt; 1</span> - Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use <span class="tt">1.1</span>.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8337"></a>
<span class="tt">maxRetries: number</span> (optional)</h3>
<p>Maximum amount of times that a dead child can be re-spawned, per call. Defaults to <span class="tt">3</span>, pass <span class="tt">Infinity</span> to allow endless retries.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8338"></a>
<span class="tt">numWorkers: number</span> (optional)</h3>
<p>Amount of workers to spawn. Defaults to the number of CPUs minus 1.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8339"></a>
<span class="tt">resourceLimits: ResourceLimits</span> (optional)</h3>
<p>The <span class="tt">resourceLimits</span> option which will be passed to <span class="tt">worker_threads</span> workers.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8340"></a>
<span class="tt">silent: Boolean</span> (optional)</h3>
<p>Set to false for <span class="tt">stdout</span> and <span class="tt">stderr</span> to be logged to console.</p>
<p>By default this is true.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8341"></a>
<span class="tt">setupArgs: Array&lt;unknown&gt;</span> (optional)</h3>
<p>The arguments that will be passed to the <span class="tt">setup</span> method during initialization.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8342"></a>
<span class="tt">taskQueue: TaskQueue</span> (optional)</h3>
<p>The task queue defines in which order tasks (method calls) are processed by the workers. <span class="tt">jest-worker</span> ships with a <span class="tt">FifoQueue</span> and <span class="tt">PriorityQueue</span>:</p>
<ul>
<li><span class="tt">FifoQueue</span> (default): Processes the method calls (tasks) in the call order.</li>
<li><span class="tt">PriorityQueue</span>: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: &lsquo;new require('jest-worker&rsquo;).PriorityQueue((method, filename) =&gt; filename.length)`.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8343"></a>
<span class="tt">WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) =&gt; WorkerPoolInterface</span> (optional)</h3>
<p>Provide a custom WorkerPool class to be used for spawning child processes.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8344"></a>
&lsquo;workerSchedulingPolicy: 'round-robin&rsquo; | 'in-order'` (optional)</h3>
<p>Specifies the policy how tasks are assigned to workers if multiple workers are <em>idle</em>:</p>
<ul>
<li><span class="tt">round-robin</span> (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.</li>
<li><span class="tt">in-order</span>: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.</li>
</ul>
<p>Tasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8345"></a>
JestWorker</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8346"></a>
Methods</h2>
<p>The returned <span class="tt">JestWorker</span> instance has all the exposed methods, plus some additional ones to interact with the workers itself:</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8347"></a>
<span class="tt">getStdout(): Readable</span></h3>
<p>Returns a <span class="tt">ReadableStream</span> where the standard output of all workers is piped. Note that the <span class="tt">silent</span> option of the child workers must be set to <span class="tt">true</span> to make it work. This is the default set by <span class="tt">jest-worker</span>, but keep it in mind when overriding options through <span class="tt">forkOptions</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8348"></a>
<span class="tt">getStderr(): Readable</span></h3>
<p>Returns a <span class="tt">ReadableStream</span> where the standard error of all workers is piped. Note that the <span class="tt">silent</span> option of the child workers must be set to <span class="tt">true</span> to make it work. This is the default set by <span class="tt">jest-worker</span>, but keep it in mind when overriding options through <span class="tt">forkOptions</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8349"></a>
<span class="tt">start()</span></h3>
<p>Starts up every worker and calls their <span class="tt">setup</span> function, if it exists. Returns a <span class="tt">Promise</span> which resolves when all workers are running and have completed their <span class="tt">setup</span>.</p>
<p>This is useful if you want to start up all your workers eagerly before they are used to call any other functions.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8350"></a>
<span class="tt">end()</span></h3>
<p>Finishes the workers by killing all workers. No further calls can be done to the <span class="tt">Worker</span> instance.</p>
<p>Returns a <span class="tt">Promise</span> that resolves with <span class="tt">{ forceExited: boolean }</span> once all workers are dead. If <span class="tt">forceExited</span> is <span class="tt">true</span>, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.</p>
<p><b>Note:</b></p>
<p><span class="tt">await</span>ing the <span class="tt">end()</span> Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, <span class="tt">jest-worker</span> may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.</p>
<p>Consider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8351"></a>
Worker IDs</h2>
<p>Each worker has a unique id (index that starts with &lsquo;'1&rsquo;<span class="tt">), which is available inside the worker as </span>process.env.JEST_WORKER_ID`.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8352"></a>
Setting up and tearing down the child process</h1>
<p>The child process can define two special methods (both of them can be asynchronous):</p>
<ul>
<li><span class="tt">setup()</span>: If defined, it's executed before the first call to any method in the child.</li>
<li><span class="tt">teardown()</span>: If defined, it's executed when the farm ends.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8353"></a>
More examples</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8354"></a>
Standard usage</h2>
<p>This example covers the standard usage:</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8355"></a>
File <span class="tt">parent.js</span></h3>
<div class="fragment"><div class="line">import {Worker as JestWorker} from &#39;jest-worker&#39;;</div>
<div class="line"> </div>
<div class="line">async function main() {</div>
<div class="line">  const myWorker = new JestWorker(require.resolve(&#39;./worker&#39;), {</div>
<div class="line">    exposedMethods: [&#39;foo&#39;, &#39;bar&#39;, &#39;getWorkerId&#39;],</div>
<div class="line">    numWorkers: 4,</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  console.log(await myWorker.foo(&#39;Alice&#39;)); // &quot;Hello from foo: Alice&quot;</div>
<div class="line">  console.log(await myWorker.bar(&#39;Bob&#39;)); // &quot;Hello from bar: Bob&quot;</div>
<div class="line">  console.log(await myWorker.getWorkerId()); // &quot;3&quot; -&gt; this message has sent from the 3rd worker</div>
<div class="line"> </div>
<div class="line">  const {forceExited} = await myWorker.end();</div>
<div class="line">  if (forceExited) {</div>
<div class="line">    console.error(&#39;Workers failed to exit gracefully&#39;);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">main();</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md8356"></a>
File <span class="tt">worker.js</span></h3>
<div class="fragment"><div class="line">export function foo(param) {</div>
<div class="line">  return `Hello from foo: ${param}`;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">export function bar(param) {</div>
<div class="line">  return `Hello from bar: ${param}`;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">export function getWorkerId() {</div>
<div class="line">  return process.env.JEST_WORKER_ID;</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md8357"></a>
Bound worker usage:</h2>
<p>This example covers the usage with a <span class="tt">computeWorkerKey</span> method:</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8358"></a>
File <span class="tt">parent.js</span></h3>
<div class="fragment"><div class="line">import {Worker as JestWorker} from &#39;jest-worker&#39;;</div>
<div class="line"> </div>
<div class="line">async function main() {</div>
<div class="line">  const myWorker = new JestWorker(require.resolve(&#39;./worker&#39;), {</div>
<div class="line">    computeWorkerKey: (method, filename) =&gt; filename,</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  // Transform the given file, within the first available worker.</div>
<div class="line">  console.log(await myWorker.transform(&#39;/tmp/foo.js&#39;));</div>
<div class="line"> </div>
<div class="line">  // Wait a bit.</div>
<div class="line">  await sleep(10000);</div>
<div class="line"> </div>
<div class="line">  // Transform the same file again. Will immediately return because the</div>
<div class="line">  // transformed file is cached in the worker, and `computeWorkerKey` ensures</div>
<div class="line">  // the same worker that processed the file the first time will process it now.</div>
<div class="line">  console.log(await myWorker.transform(&#39;/tmp/foo.js&#39;));</div>
<div class="line"> </div>
<div class="line">  const {forceExited} = await myWorker.end();</div>
<div class="line">  if (forceExited) {</div>
<div class="line">    console.error(&#39;Workers failed to exit gracefully&#39;);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">main();</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md8359"></a>
File <span class="tt">worker.js</span></h3>
<div class="fragment"><div class="line">import babel from &#39;@babel/core&#39;;</div>
<div class="line"> </div>
<div class="line">const cache = Object.create(null);</div>
<div class="line"> </div>
<div class="line">export function transform(filename) {</div>
<div class="line">  if (cache[filename]) {</div>
<div class="line">    return cache[filename];</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // jest-worker can handle both immediate results and thenables. If a</div>
<div class="line">  // thenable is returned, it will be await&#39;ed until it resolves.</div>
<div class="line">  return babel.transformFileAsync(filename).then(result =&gt; {</div>
<div class="line">    cache[filename] = result;</div>
<div class="line"> </div>
<div class="line">    return result;</div>
<div class="line">  });</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_8983b1862dce8a71846356b6209105f4.html">EcoEats-Project</a></li><li class="navelem"><a href="dir_5091f2b68170d33f954320199e2fed0a.html">node_modules</a></li><li class="navelem"><a href="dir_4f024058fe2ba5a1a95f8e4eb5452be8.html">jest-worker</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
