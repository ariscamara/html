<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: API Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md__c_1_2_users_2arisc_2_one_drive_2_documents_2_git_hub_2_f_i_n_a_l_2_eco_eats-_project_2node__edd2fb3cf357cf4bdfc3374c47d7abfb.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">API Documentation </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md10855"></a></p>
<p><em>Please use only this documented API when working with the parser. Methods not documented here are subject to change at any point.</em></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md10856"></a>
<span class="tt">parser</span> function</h1>
<p>This is the module's main entry point.</p>
<div class="fragment"><div class="line">const parser = require(&#39;postcss-selector-parser&#39;);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md10857"></a>
<span class="tt">parser([transform], [options])</span></h2>
<p>Creates a new <span class="tt">processor</span> instance</p>
<div class="fragment"><div class="line">const processor = parser();</div>
</div><!-- fragment --><p>Or, with optional transform function</p>
<div class="fragment"><div class="line">const transform = selectors =&gt; {</div>
<div class="line">    selectors.walkUniversals(selector =&gt; {</div>
<div class="line">        selector.remove();</div>
<div class="line">    });</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">const processor = parser(transform)</div>
<div class="line"> </div>
<div class="line">// Example</div>
<div class="line">const result = processor.processSync(&#39;*.class&#39;);</div>
<div class="line">// =&gt; .class</div>
</div><!-- fragment --><p>See processor documentation</p>
<p>Arguments:</p>
<ul>
<li><span class="tt">transform (function)</span>: Provide a function to work with the parsed AST.</li>
<li><span class="tt">options (object)</span>: Provide default options for all calls on the returned <span class="tt">Processor</span>.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10858"></a>
<span class="tt">parser.attribute([props])</span></h2>
<p>Creates a new attribute selector.</p>
<div class="fragment"><div class="line">parser.attribute({attribute: &#39;href&#39;});</div>
<div class="line">// =&gt; [href]</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">props (object)</span>: The new node's properties.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10859"></a>
<span class="tt">parser.className([props])</span></h2>
<p>Creates a new class selector.</p>
<div class="fragment"><div class="line">parser.className({value: &#39;button&#39;});</div>
<div class="line">// =&gt; .button</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">props (object)</span>: The new node's properties.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10860"></a>
<span class="tt">parser.combinator([props])</span></h2>
<p>Creates a new selector combinator.</p>
<div class="fragment"><div class="line">parser.combinator({value: &#39;+&#39;});</div>
<div class="line">// =&gt; +</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">props (object)</span>: The new node's properties.</li>
</ul>
<p>Notes:</p><ul>
<li><b>Descendant Combinators</b> The value of descendant combinators created by the parser always just a single space (<span class="tt">" "</span>). For descendant selectors with no comments, additional space is now stored in <span class="tt">node.spaces.before</span>. Depending on the location of comments, additional spaces may be stored in <span class="tt">node.raws.spaces.before</span>, <span class="tt">node.raws.spaces.after</span>, or <span class="tt">node.raws.value</span>.</li>
<li><b>Named Combinators</b> Although, nonstandard and unlikely to ever become a standard, named combinators like <span class="tt">/deep/</span> and <span class="tt">/for/</span> are parsed as combinators. The <span class="tt">node.value</span> is name after being unescaped and normalized as lowercase. The original value for the combinator name is stored in <span class="tt">node.raws.value</span>.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10861"></a>
<span class="tt">parser.comment([props])</span></h2>
<p>Creates a new comment.</p>
<div class="fragment"><div class="line">parser.comment({value: &#39;/* Affirmative, Dave. I read you. */&#39;});</div>
<div class="line">// =&gt; /* Affirmative, Dave. I read you. */</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">props (object)</span>: The new node's properties.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10862"></a>
<span class="tt">parser.id([props])</span></h2>
<p>Creates a new id selector.</p>
<div class="fragment"><div class="line">parser.id({value: &#39;search&#39;});</div>
<div class="line">// =&gt; #search</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">props (object)</span>: The new node's properties.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10863"></a>
<span class="tt">parser.nesting([props])</span></h2>
<p>Creates a new nesting selector.</p>
<div class="fragment"><div class="line">parser.nesting();</div>
<div class="line">// =&gt; &amp;</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">props (object)</span>: The new node's properties.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10864"></a>
<span class="tt">parser.pseudo([props])</span></h2>
<p>Creates a new pseudo selector.</p>
<div class="fragment"><div class="line">parser.pseudo({value: &#39;::before&#39;});</div>
<div class="line">// =&gt; ::before</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">props (object)</span>: The new node's properties.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10865"></a>
<span class="tt">parser.root([props])</span></h2>
<p>Creates a new root node.</p>
<div class="fragment"><div class="line">parser.root();</div>
<div class="line">// =&gt; (empty)</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">props (object)</span>: The new node's properties.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10866"></a>
<span class="tt">parser.selector([props])</span></h2>
<p>Creates a new selector node.</p>
<div class="fragment"><div class="line">parser.selector();</div>
<div class="line">// =&gt; (empty)</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">props (object)</span>: The new node's properties.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10867"></a>
<span class="tt">parser.string([props])</span></h2>
<p>Creates a new string node.</p>
<div class="fragment"><div class="line">parser.string();</div>
<div class="line">// =&gt; (empty)</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">props (object)</span>: The new node's properties.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10868"></a>
<span class="tt">parser.tag([props])</span></h2>
<p>Creates a new tag selector.</p>
<div class="fragment"><div class="line">parser.tag({value: &#39;button&#39;});</div>
<div class="line">// =&gt; button</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">props (object)</span>: The new node's properties.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10869"></a>
<span class="tt">parser.universal([props])</span></h2>
<p>Creates a new universal selector.</p>
<div class="fragment"><div class="line">parser.universal();</div>
<div class="line">// =&gt; *</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">props (object)</span>: The new node's properties.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md10870"></a>
Node types</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10871"></a>
<span class="tt">node.type</span></h2>
<p>A string representation of the selector type. It can be one of the following; <span class="tt">attribute</span>, <span class="tt">class</span>, <span class="tt">combinator</span>, <span class="tt">comment</span>, <span class="tt">id</span>, <span class="tt">nesting</span>, <span class="tt">pseudo</span>, <span class="tt">root</span>, <span class="tt">selector</span>, <span class="tt">string</span>, <span class="tt">tag</span>, or <span class="tt">universal</span>. Note that for convenience, these constants are exposed on the main <span class="tt">parser</span> as uppercased keys. So for example you can get <span class="tt">id</span> by querying <span class="tt">parser.ID</span>.</p>
<div class="fragment"><div class="line">parser.attribute({attribute: &#39;href&#39;}).type;</div>
<div class="line">// =&gt; &#39;attribute&#39;</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md10872"></a>
<span class="tt">node.parent</span></h2>
<p>Returns the parent node.</p>
<div class="fragment"><div class="line">root.nodes[0].parent === root;</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md10873"></a>
<span class="tt">node.toString()</span>, <span class="tt">String(node)</span>, or &lsquo;&rsquo;' + node`</h2>
<p>Returns a string representation of the node.</p>
<div class="fragment"><div class="line">const id = parser.id({value: &#39;search&#39;});</div>
<div class="line">console.log(String(id));</div>
<div class="line">// =&gt; #search</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md10874"></a>
<span class="tt">node.next()</span> &amp; <span class="tt">node.prev()</span></h2>
<p>Returns the next/previous child of the parent node.</p>
<div class="fragment"><div class="line">const next = id.next();</div>
<div class="line">if (next &amp;&amp; next.type !== &#39;combinator&#39;) {</div>
<div class="line">    throw new Error(&#39;Qualified IDs are not allowed!&#39;);</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md10875"></a>
<span class="tt">node.replaceWith(node)</span></h2>
<p>Replace a node with another.</p>
<div class="fragment"><div class="line">const attr = selectors.first.first;</div>
<div class="line">const className = parser.className({value: &#39;test&#39;});</div>
<div class="line">attr.replaceWith(className);</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">node</span>: The node to substitute the original with.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10876"></a>
<span class="tt">node.remove()</span></h2>
<p>Removes the node from its parent node.</p>
<div class="fragment"><div class="line">if (node.type === &#39;id&#39;) {</div>
<div class="line">    node.remove();</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md10877"></a>
<span class="tt">node.clone([opts])</span></h2>
<p>Returns a copy of a node, detached from any parent containers that the original might have had.</p>
<div class="fragment"><div class="line">const cloned = node.clone();</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md10878"></a>
<span class="tt">node.isAtPosition(line, column)</span></h2>
<p>Return a <span class="tt">boolean</span> indicating whether this node includes the character at the position of the given line and column. Returns <span class="tt">undefined</span> if the nodes lack sufficient source metadata to determine the position.</p>
<p>Arguments:</p>
<ul>
<li><span class="tt">line</span>: 1-index based line number relative to the start of the selector.</li>
<li><span class="tt">column</span>: 1-index based column number relative to the start of the selector.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10879"></a>
<span class="tt">node.spaces</span></h2>
<p>Extra whitespaces around the node will be moved into <span class="tt">node.spaces.before</span> and <span class="tt">node.spaces.after</span>. So for example, these spaces will be moved as they have no semantic meaning:</p>
<div class="fragment"><div class="line">h1     ,     h2   {}</div>
</div><!-- fragment --><p>For descendent selectors, the value is always a single space.</p>
<div class="fragment"><div class="line">h1        h2 {}</div>
</div><!-- fragment --><p>Additional whitespace is found in either the <span class="tt">node.spaces.before</span> and <span class="tt">node.spaces.after</span> depending on the presence of comments or other whitespace characters. If the actual whitespace does not start or end with a single space, the node's raw value is set to the actual space(s) found in the source.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10880"></a>
<span class="tt">node.source</span></h2>
<p>An object describing the node's start/end, line/column source position.</p>
<p>Within the following CSS, the <span class="tt">.bar</span> class node ...</p>
<div class="fragment"><div class="line">.foo,</div>
<div class="line">  .bar {}</div>
</div><!-- fragment --><p>... will contain the following <span class="tt">source</span> object.</p>
<div class="fragment"><div class="line">source: {</div>
<div class="line">    start: {</div>
<div class="line">        line: 2,</div>
<div class="line">        column: 3</div>
<div class="line">    },</div>
<div class="line">    end: {</div>
<div class="line">        line: 2,</div>
<div class="line">        column: 6</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md10881"></a>
<span class="tt">node.sourceIndex</span></h2>
<p>The zero-based index of the node within the original source string.</p>
<p>Within the following CSS, the <span class="tt">.baz</span> class node will have a <span class="tt">sourceIndex</span> of <span class="tt">12</span>.</p>
<div class="fragment"><div class="line">.foo, .bar, .baz {}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md10882"></a>
Container types</h1>
<p>The <span class="tt">root</span>, <span class="tt">selector</span>, and <span class="tt">pseudo</span> nodes have some helper methods for working with their children.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10883"></a>
<span class="tt">container.nodes</span></h2>
<p>An array of the container's children.</p>
<div class="fragment"><div class="line">// Input: h1 h2</div>
<div class="line">selectors.at(0).nodes.length   // =&gt; 3</div>
<div class="line">selectors.at(0).nodes[0].value // =&gt; &#39;h1&#39;</div>
<div class="line">selectors.at(0).nodes[1].value // =&gt; &#39; &#39;</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md10884"></a>
<span class="tt">container.first</span> &amp; <span class="tt">container.last</span></h2>
<p>The first/last child of the container.</p>
<div class="fragment"><div class="line">selector.first === selector.nodes[0];</div>
<div class="line">selector.last === selector.nodes[selector.nodes.length - 1];</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md10885"></a>
<span class="tt">container.at(index)</span></h2>
<p>Returns the node at position <span class="tt">index</span>.</p>
<div class="fragment"><div class="line">selector.at(0) === selector.first;</div>
<div class="line">selector.at(0) === selector.nodes[0];</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">index</span>: The index of the node to return.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10886"></a>
<span class="tt">container.atPosition(line, column)</span></h2>
<p>Returns the node at the source position <span class="tt">line</span> and <span class="tt">column</span>.</p>
<div class="fragment"><div class="line">// Input: :not(.foo),\n#foo &gt; :matches(ol, ul)</div>
<div class="line">selector.atPosition(1, 1); // =&gt; :not(.foo)</div>
<div class="line">selector.atPosition(2, 1); // =&gt; \n#foo</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">line</span>: The line number of the node to return.</li>
<li><span class="tt">column</span>: The column number of the node to return.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10887"></a>
<span class="tt">container.index(node)</span></h2>
<p>Return the index of the node within its container.</p>
<div class="fragment"><div class="line">selector.index(selector.nodes[2]) // =&gt; 2</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">node</span>: A node within the current container.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10888"></a>
<span class="tt">container.length</span></h2>
<p>Proxy to the length of the container's nodes.</p>
<div class="fragment"><div class="line">container.length === container.nodes.length</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md10889"></a>
<span class="tt">container</span> Array iterators</h2>
<p>The container class provides proxies to certain Array methods; these are:</p>
<ul>
<li><span class="tt">container.map === container.nodes.map</span></li>
<li><span class="tt">container.reduce === container.nodes.reduce</span></li>
<li><span class="tt">container.every === container.nodes.every</span></li>
<li><span class="tt">container.some === container.nodes.some</span></li>
<li><span class="tt">container.filter === container.nodes.filter</span></li>
<li><span class="tt">container.sort === container.nodes.sort</span></li>
</ul>
<p>Note that these methods only work on a container's immediate children; recursive iteration is provided by <span class="tt">container.walk</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10890"></a>
<span class="tt">container.each(callback)</span></h2>
<p>Iterate the container's immediate children, calling <span class="tt">callback</span> for each child. You may return <span class="tt">false</span> within the callback to break the iteration.</p>
<div class="fragment"><div class="line">let className;</div>
<div class="line">selectors.each((selector, index) =&gt; {</div>
<div class="line">    if (selector.type === &#39;class&#39;) {</div>
<div class="line">        className = selector.value;</div>
<div class="line">        return false;</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><p>Note that unlike <span class="tt">Array#forEach()</span>, this iterator is safe to use whilst adding or removing nodes from the container.</p>
<p>Arguments:</p>
<ul>
<li><span class="tt">callback (function)</span>: A function to call for each node, which receives <span class="tt">node</span> and <span class="tt">index</span> arguments.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10891"></a>
<span class="tt">container.walk(callback)</span></h2>
<p>Like <span class="tt">container#each</span>, but will also iterate child nodes as long as they are <span class="tt">container</span> types.</p>
<div class="fragment"><div class="line">selectors.walk((selector, index) =&gt; {</div>
<div class="line">    // all nodes</div>
<div class="line">});</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">callback (function)</span>: A function to call for each node, which receives <span class="tt">node</span> and <span class="tt">index</span> arguments.</li>
</ul>
<p>This iterator is safe to use whilst mutating <span class="tt">container.nodes</span>, like <span class="tt">container#each</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10892"></a>
<span class="tt">container.walk</span> proxies</h2>
<p>The container class provides proxy methods for iterating over types of nodes, so that it is easier to write modules that target specific selectors. Those methods are:</p>
<ul>
<li><span class="tt">container.walkAttributes</span></li>
<li><span class="tt">container.walkClasses</span></li>
<li><span class="tt">container.walkCombinators</span></li>
<li><span class="tt">container.walkComments</span></li>
<li><span class="tt">container.walkIds</span></li>
<li><span class="tt">container.walkNesting</span></li>
<li><span class="tt">container.walkPseudos</span></li>
<li><span class="tt">container.walkTags</span></li>
<li><span class="tt">container.walkUniversals</span></li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10893"></a>
<span class="tt">container.split(callback)</span></h2>
<p>This method allows you to split a group of nodes by returning <span class="tt">true</span> from a callback. It returns an array of arrays, where each inner array corresponds to the groups that you created via the callback.</p>
<div class="fragment"><div class="line">// (input) =&gt; h1 h2&gt;&gt;h3</div>
<div class="line">const list = selectors.first.split(selector =&gt; {</div>
<div class="line">    return selector.type === &#39;combinator&#39;;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// (node values) =&gt; [[&#39;h1&#39;, &#39; &#39;], [&#39;h2&#39;, &#39;&gt;&gt;&#39;], [&#39;h3&#39;]]</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">callback (function)</span>: A function to call for each node, which receives <span class="tt">node</span> as an argument.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10894"></a>
<span class="tt">container.prepend(node)</span> &amp; <span class="tt">container.append(node)</span></h2>
<p>Add a node to the start/end of the container. Note that doing so will set the parent property of the node to this container.</p>
<div class="fragment"><div class="line">const id = parser.id({value: &#39;search&#39;});</div>
<div class="line">selector.append(id);</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">node</span>: The node to add.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10895"></a>
<span class="tt">container.insertBefore(old, new)</span> &amp; <span class="tt">container.insertAfter(old, new)</span></h2>
<p>Add a node before or after an existing node in a container:</p>
<div class="fragment"><div class="line">selectors.walk(selector =&gt; {</div>
<div class="line">    if (selector.type !== &#39;class&#39;) {</div>
<div class="line">        const className = parser.className({value: &#39;theme-name&#39;});</div>
<div class="line">        selector.parent.insertAfter(selector, className);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">old</span>: The existing node in the container.</li>
<li><span class="tt">new</span>: The new node to add before/after the existing node.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10896"></a>
<span class="tt">container.removeChild(node)</span></h2>
<p>Remove the node from the container. Note that you can also use <span class="tt">node.remove()</span> if you would like to remove just a single node.</p>
<div class="fragment"><div class="line">selector.length // =&gt; 2</div>
<div class="line">selector.remove(id)</div>
<div class="line">selector.length // =&gt; 1;</div>
<div class="line">id.parent       // undefined</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">node</span>: The node to remove.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10897"></a>
<span class="tt">container.removeAll()</span> or <span class="tt">container.empty()</span></h2>
<p>Remove all children from the container.</p>
<div class="fragment"><div class="line">selector.removeAll();</div>
<div class="line">selector.length // =&gt; 0</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md10898"></a>
Root nodes</h1>
<p>A root node represents a comma separated list of selectors. Indeed, all a root's <span class="tt">toString()</span> method does is join its selector children with a ','. Other than this, it has no special functionality and acts like a container.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10899"></a>
<span class="tt">root.trailingComma</span></h2>
<p>This will be set to <span class="tt">true</span> if the input has a trailing comma, in order to support parsing of legacy CSS hacks.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md10900"></a>
Selector nodes</h1>
<p>A selector node represents a single complex selector. For example, this selector string <span class="tt">h1 h2 h3, [href] &gt; p</span>, is represented as two selector nodes. It has no special functionality of its own.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md10901"></a>
Pseudo nodes</h1>
<p>A pseudo selector extends a container node; if it has any parameters of its own (such as <span class="tt">h1:not(h2, h3)</span>), they will be its children. Note that the pseudo <span class="tt">value</span> will always contain the colons preceding the pseudo identifier. This is so that both <span class="tt">:before</span> and <span class="tt">::before</span> are properly represented in the AST.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md10902"></a>
Attribute nodes</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10903"></a>
<span class="tt">attribute.quoted</span></h2>
<p>Returns <span class="tt">true</span> if the attribute's value is wrapped in quotation marks, false if it is not. Remains <span class="tt">undefined</span> if there is no attribute value.</p>
<div class="fragment"><div class="line">[href=foo] /* false */</div>
<div class="line">[href=&#39;foo&#39;] /* true */</div>
<div class="line">[href=&quot;foo&quot;] /* true */</div>
<div class="line">[href] /* undefined */</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md10904"></a>
<span class="tt">attribute.qualifiedAttribute</span></h2>
<p>Returns the attribute name qualified with the namespace if one is given.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10905"></a>
<span class="tt">attribute.offsetOf(part)</span></h2>
<p>Returns the offset of the attribute part specified relative to the start of the node of the output string. This is useful in raising error messages about a specific part of the attribute, especially in combination with <span class="tt">attribute.sourceIndex</span>.</p>
<p>Returns <span class="tt">-1</span> if the name is invalid or the value doesn't exist in this attribute.</p>
<p>The legal values for <span class="tt">part</span> are:</p>
<ul>
<li><span class="tt">"ns"</span> - alias for "namespace"</li>
<li><span class="tt">"namespace"</span> - the namespace if it exists.</li>
<li><span class="tt">"attribute"</span> - the attribute name</li>
<li><span class="tt">"attributeNS"</span> - the start of the attribute or its namespace</li>
<li><span class="tt">"operator"</span> - the match operator of the attribute</li>
<li><span class="tt">"value"</span> - The value (string or identifier)</li>
<li><span class="tt">"insensitive"</span> - the case insensitivity flag</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10906"></a>
<span class="tt">attribute.raws.unquoted</span></h2>
<p>Returns the unquoted content of the attribute's value. Remains <span class="tt">undefined</span> if there is no attribute value.</p>
<div class="fragment"><div class="line">[href=foo] /* foo */</div>
<div class="line">[href=&#39;foo&#39;] /* foo */</div>
<div class="line">[href=&quot;foo&quot;] /* foo */</div>
<div class="line">[href] /* undefined */</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md10907"></a>
<span class="tt">attribute.spaces</span></h2>
<p>Like <span class="tt">node.spaces</span> with the <span class="tt">before</span> and <span class="tt">after</span> values containing the spaces around the element, the parts of the attribute can also have spaces before and after them. The for each of <span class="tt">attribute</span>, <span class="tt">operator</span>, <span class="tt">value</span> and <span class="tt">insensitive</span> there is corresponding property of the same nam in <span class="tt">node.spaces</span> that has an optional <span class="tt">before</span> or <span class="tt">after</span> string containing only whitespace.</p>
<p>Note that corresponding values in <span class="tt">attributes.raws.spaces</span> contain values including any comments. If set, these values will override the <span class="tt">attribute.spaces</span> value. Take care to remove them if changing <span class="tt">attribute.spaces</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10908"></a>
<span class="tt">attribute.raws</span></h2>
<p>The raws object stores comments and other information necessary to re-render the node exactly as it was in the source.</p>
<p>If a comment is embedded within the identifiers for the <span class="tt">namespace</span>, <span class="tt">attribute</span> or <span class="tt">value</span> then a property is placed in the raws for that value containing the full source of the propery including comments.</p>
<p>If a comment is embedded within the space between parts of the attribute then the raw for that space is set accordingly.</p>
<p>Setting an attribute's property <span class="tt">raws</span> value to be deleted.</p>
<p>For now, changing the spaces required also updating or removing any of the raws values that override them.</p>
<p>Example: <span class="tt">[ /*before*/ href /* after-attr */ = /* after-operator */ te/*inside-value*/st/* wow */ /*omg*/i/*bbq*/ /*whodoesthis*/]</span> would parse as:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  attribute: &quot;href&quot;,</div>
<div class="line">  operator: &quot;=&quot;,</div>
<div class="line">  value: &quot;test&quot;,</div>
<div class="line">  spaces: {</div>
<div class="line">    before: &#39;&#39;,</div>
<div class="line">    after: &#39;&#39;,</div>
<div class="line">    attribute: { before: &#39;  &#39;, after: &#39;  &#39; },</div>
<div class="line">    operator: { after: &#39;  &#39; },</div>
<div class="line">    value: { after: &#39; &#39; },</div>
<div class="line">    insensitive: { after: &#39; &#39; }</div>
<div class="line">  },</div>
<div class="line">  raws: {</div>
<div class="line">    spaces: {</div>
<div class="line">      attribute: { before: &#39; /*before*/ &#39;, after: &#39; /* after-attr */ &#39; },</div>
<div class="line">      operator: { after: &#39; /* after-operator */ &#39; },</div>
<div class="line">      value: { after: &#39;/* wow */ /*omg*/&#39; },</div>
<div class="line">      insensitive: { after: &#39;/*bbq*/ /*whodoesthis*/&#39; }</div>
<div class="line">    },</div>
<div class="line">    unquoted: &#39;test&#39;,</div>
<div class="line">    value: &#39;te/*inside-value*/st&#39;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md10909"></a>
<span class="tt">Processor</span></h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10910"></a>
<span class="tt">ProcessorOptions</span></h2>
<ul>
<li><span class="tt">lossless</span> - When <span class="tt">true</span>, whitespace is preserved. Defaults to <span class="tt">true</span>.</li>
<li><span class="tt">updateSelector</span> - When <span class="tt">true</span>, if any processor methods are passed a postcss <span class="tt">Rule</span> node instead of a string, then that Rule's selector is updated with the results of the processing. Defaults to <span class="tt">true</span>.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10911"></a>
<span class="tt">process|processSync(selectors, [options])</span></h2>
<p>Processes the <span class="tt">selectors</span>, returning a string from the result of processing.</p>
<p>Note: when the <span class="tt">updateSelector</span> option is set, the rule's selector will be updated with the resulting string.</p>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">const parser = require(&quot;postcss-selector-parser&quot;);</div>
<div class="line">const processor = parser();</div>
<div class="line"> </div>
<div class="line">let result = processor.processSync(&#39; .class&#39;);</div>
<div class="line">console.log(result);</div>
<div class="line">// =&gt;  .class</div>
<div class="line"> </div>
<div class="line">// Asynchronous operation</div>
<div class="line">let promise = processor.process(&#39; .class&#39;).then(result =&gt; {</div>
<div class="line">    console.log(result)</div>
<div class="line">    // =&gt; .class</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// To have the parser normalize whitespace values, utilize the options</div>
<div class="line">result = processor.processSync(&#39;  .class  &#39;, {lossless: false});</div>
<div class="line">console.log(result);</div>
<div class="line">// =&gt; .class</div>
<div class="line"> </div>
<div class="line">// For better syntax errors, pass a PostCSS Rule node.</div>
<div class="line">const postcss = require(&#39;postcss&#39;);</div>
<div class="line">rule = postcss.rule({selector: &#39; #foo    &gt; a,  .class  &#39;});</div>
<div class="line">processor.process(rule, {lossless: false, updateSelector: true}).then(result =&gt; {</div>
<div class="line">    console.log(result);</div>
<div class="line">    // =&gt; #foo&gt;a,.class</div>
<div class="line">    console.log(&quot;rule:&quot;, rule.selector);</div>
<div class="line">    // =&gt; rule: #foo&gt;a,.class</div>
<div class="line">})</div>
</div><!-- fragment --><p>Arguments:</p>
<ul>
<li><span class="tt">selectors (string|postcss.Rule)</span>: Either a selector string or a PostCSS Rule node.</li>
<li><span class="tt">[options] (object)</span>: Process options</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10912"></a>
<span class="tt">ast|astSync(selectors, [options])</span></h2>
<p>Like <span class="tt">process()</span> and <span class="tt">processSync()</span> but after processing the <span class="tt">selectors</span> these methods return the <span class="tt">Root</span> node of the result instead of a string.</p>
<p>Note: when the <span class="tt">updateSelector</span> option is set, the rule's selector will be updated with the resulting string.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10913"></a>
<span class="tt">transform|transformSync(selectors, [options])</span></h2>
<p>Like <span class="tt">process()</span> and <span class="tt">processSync()</span> but after processing the <span class="tt">selectors</span> these methods return the value returned by the processor callback.</p>
<p>Note: when the <span class="tt">updateSelector</span> option is set, the rule's selector will be updated with the resulting string.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10914"></a>
Error Handling Within Selector Processors</h2>
<p>The root node passed to the selector processor callback has a method <span class="tt">error(message, options)</span> that returns an error object. This method should always be used to raise errors relating to the syntax of selectors. The options to this method are passed to postcss's error constructor (<a href="http://postcss.org/api/#container-error">documentation</a>).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10915"></a>
Async Error Example</h3>
<div class="fragment"><div class="line">let processor = (root) =&gt; {</div>
<div class="line">    return new Promise((resolve, reject) =&gt; {</div>
<div class="line">        root.walkClasses((classNode) =&gt; {</div>
<div class="line">            if (/^(.*)[-_]/.test(classNode.value)) {</div>
<div class="line">                let msg = &quot;classes may not have underscores or dashes in them&quot;;</div>
<div class="line">                reject(root.error(msg, {</div>
<div class="line">                    index: classNode.sourceIndex + RegExp.$1.length + 1,</div>
<div class="line">                    word: classNode.value</div>
<div class="line">                }));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        resolve();</div>
<div class="line">    });</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">const postcss = require(&quot;postcss&quot;);</div>
<div class="line">const parser = require(&quot;postcss-selector-parser&quot;);</div>
<div class="line">const selectorProcessor = parser(processor);</div>
<div class="line">const plugin = postcss.plugin(&#39;classValidator&#39;, (options) =&gt; {</div>
<div class="line">    return (root) =&gt; {</div>
<div class="line">        let promises = [];</div>
<div class="line">        root.walkRules(rule =&gt; {</div>
<div class="line">            promises.push(selectorProcessor.process(rule));</div>
<div class="line">        });</div>
<div class="line">        return Promise.all(promises);</div>
<div class="line">    };</div>
<div class="line">});</div>
<div class="line">postcss(plugin()).process(`</div>
<div class="line">.foo-bar {</div>
<div class="line">  color: red;</div>
<div class="line">}</div>
<div class="line">`.trim(), {from: &#39;test.css&#39;}).catch((e) =&gt; console.error(e.toString()));</div>
<div class="line"> </div>
<div class="line">// CssSyntaxError: classValidator: ./test.css:1:5: classes may not have underscores or dashes in them</div>
<div class="line">//</div>
<div class="line">// &gt; 1 | .foo-bar {</div>
<div class="line">//     |     ^</div>
<div class="line">//   2 |   color: red;</div>
<div class="line">//   3 | }</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md10916"></a>
Synchronous Error Example</h3>
<div class="fragment"><div class="line">let processor = (root) =&gt; {</div>
<div class="line">    root.walkClasses((classNode) =&gt; {</div>
<div class="line">        if (/.*[-_]/.test(classNode.value)) {</div>
<div class="line">            let msg = &quot;classes may not have underscores or dashes in them&quot;;</div>
<div class="line">            throw root.error(msg, {</div>
<div class="line">                index: classNode.sourceIndex,</div>
<div class="line">                word: classNode.value</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">const postcss = require(&quot;postcss&quot;);</div>
<div class="line">const parser = require(&quot;postcss-selector-parser&quot;);</div>
<div class="line">const selectorProcessor = parser(processor);</div>
<div class="line">const plugin = postcss.plugin(&#39;classValidator&#39;, (options) =&gt; {</div>
<div class="line">    return (root) =&gt; {</div>
<div class="line">        root.walkRules(rule =&gt; {</div>
<div class="line">            selectorProcessor.processSync(rule);</div>
<div class="line">        });</div>
<div class="line">    };</div>
<div class="line">});</div>
<div class="line">postcss(plugin()).process(`</div>
<div class="line">.foo-bar {</div>
<div class="line">  color: red;</div>
<div class="line">}</div>
<div class="line">`.trim(), {from: &#39;test.css&#39;}).catch((e) =&gt; console.error(e.toString()));</div>
<div class="line"> </div>
<div class="line">// CssSyntaxError: classValidator: ./test.css:1:5: classes may not have underscores or dashes in them</div>
<div class="line">//</div>
<div class="line">// &gt; 1 | .foo-bar {</div>
<div class="line">//     |     ^</div>
<div class="line">//   2 |   color: red;</div>
<div class="line">//   3 | }</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
